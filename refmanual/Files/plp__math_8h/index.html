
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-9.0.15">
    
    
      
        <title>/github/workspace/include/plp_math.h - PULP DSP</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.113286f1.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.a0c5b2b5.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#githubworkspaceincludeplp_mathh" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="PULP DSP" class="md-header__button md-logo" aria-label="PULP DSP" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            PULP DSP
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              /github/workspace/include/plp_math.h
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/pulp-platform/pulp-dsp" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    pulp-platform/pulp-dsp
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="PULP DSP" class="md-nav__button md-logo" aria-label="PULP DSP" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    PULP DSP
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/pulp-platform/pulp-dsp" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.3.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    pulp-platform/pulp-dsp
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../test-framework-index/" class="md-nav__link">
        Test Framework
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../tutorial-index/" class="md-nav__link">
        Tutorial
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../troubles/" class="md-nav__link">
        Troubles Shooting
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
      
      
      
        <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
          Reference Manual
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Reference Manual
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Pages/" class="md-nav__link">
        Pages
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        Files
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Classes/" class="md-nav__link">
        Classes
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Examples/" class="md-nav__link">
        Examples
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Modules/" class="md-nav__link">
        Modules
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../Namespaces/" class="md-nav__link">
        Namespaces
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#types" class="md-nav__link">
    Types
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#defines" class="md-nav__link">
    Defines
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#detailed-description" class="md-nav__link">
    Detailed Description
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="githubworkspaceincludeplp_mathh">/github/workspace/include/plp_math.h</h1>
<p>Public header file for PULP DSP Library.  <a href="#detailed-description">More...</a></p>
<h2 id="classes">Classes</h2>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dot__prod__instance__i32/">plp_dot_prod_instance_i32</a></strong> <br>Instance structure for integer parallel dot product.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dot__prod__instance__q32/">plp_dot_prod_instance_q32</a></strong> <br>Instance structure for fixed point parallel dot product.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dot__prod__instance__f32/">plp_dot_prod_instance_f32</a></strong> <br>Instance structure for float parallel dot product.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mult__instance__f32/">plp_mult_instance_f32</a></strong> <br>Instance structure for float parallel multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__log__instance__f32/">plp_log_instance_f32</a></strong> <br>Instance structure for float parallel log.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__conv__instance__i32/">plp_conv_instance_i32</a></strong> <br>Instance structure for basic integer convolution.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__conv__instance__i16/">plp_conv_instance_i16</a></strong> <br>Instance structure for basic integer convolution.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__conv__instance__i8/">plp_conv_instance_i8</a></strong> <br>Instance structure for basic integer convolution.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__conv__tree__add__instance/">plp_conv_tree_add_instance</a></strong> <br>Instance structure for basic integer convolution.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q16/">plp_cfft_instance_q16</a></strong> <br>Instance structure for the fixed-point CFFT/CIFFT function.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q16__parallel/">plp_cfft_instance_q16_parallel</a></strong> <br>Instance structure for the parallel CFFT Q16.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q32/">plp_cfft_instance_q32</a></strong> <br>Instance structure for the fixed-point CFFT/CIFFT function.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q32__parallel/">plp_cfft_instance_q32_parallel</a></strong> <br>Instance structure for the parallel CFFT Q16.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__f32/">plp_cfft_instance_f32</a></strong> <br>Instance structure for the floating-point CFFT/CIFFT function.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__f32__parallel/">plp_cfft_instance_f32_parallel</a></strong> <br>Instance structure for floating-point FFT (parallel version)</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a></strong> <br>Instance structure for floating-point FFT.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__fft__fast__instance__f32/">plp_fft_fast_instance_f32</a></strong> <br>Instance structure for floating-point FFT.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__fft__fast__instance__f32__parallel/">plp_fft_fast_instance_f32_parallel</a></strong> <br>Instance structure for floating-point FFT.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32__parallel/">plp_fft_instance_f32_parallel</a></strong> <br>Instance structure for floating-point FFT (parallel version)</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__triangular__filter__f32/">plp_triangular_filter_f32</a></strong> <br>structure containing non-zero values of triangular filterbanks</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structComplex__type__f32/">Complex_type_f32</a></strong> <br>Helper type to represent complex values with float32 components.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i8/">plp_mat_mult_instance_i8</a></strong> <br>Instance structure for integer parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i16/">plp_mat_mult_instance_i16</a></strong> <br>Instance structure for integer parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i32/">plp_mat_mult_instance_i32</a></strong> <br>Instance structure for integer parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__f32/">plp_mat_mult_instance_f32</a></strong> <br>Instance structure for floating-point parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q8/">plp_mat_mult_instance_q8</a></strong> <br>Instance structure for 8-bit fix-point parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q16/">plp_mat_mult_instance_q16</a></strong> <br>Instance structure for 16-bit fix-point parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q32/">plp_mat_mult_instance_q32</a></strong> <br>Instance structure for 32-bit fix-point parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__i8/">plp_mat_mult_cmplx_instance_i8</a></strong> <br>Instance structure for integer parallel complex matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__i16/">plp_mat_mult_cmplx_instance_i16</a></strong> <br>Instance structure for integer parallel complex matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__i32/">plp_mat_mult_cmplx_instance_i32</a></strong> <br>Instance structure for integer parallel complex matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__f32/">plp_mat_mult_cmplx_instance_f32</a></strong> <br>Instance structure for floating-point parallel complex matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__q8/">plp_mat_mult_cmplx_instance_q8</a></strong> <br>Instance structure for 8-bit fix-point parallel complex matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__q16/">plp_mat_mult_cmplx_instance_q16</a></strong> <br>Instance structure for 16-bit fix-point parallel complex matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__q32/">plp_mat_mult_cmplx_instance_q32</a></strong> <br>Instance structure for 32-bit fix-point parallel complex matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__i8/">plp_mat_add_instance_i8</a></strong> <br>Instance structure for integer parallel matrix addition.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__i16/">plp_mat_add_instance_i16</a></strong> <br>Instance structure for integer parallel matrix addition.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__i32/">plp_mat_add_instance_i32</a></strong> <br>Instance structure for integer parallel matrix addition.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__f32/">plp_mat_add_instance_f32</a></strong> <br>Instance structure for floating-point parallel matrix addition.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__i8/">plp_mat_sub_instance_i8</a></strong> <br>Instance structure for integer parallel matrix subtraction.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__i16/">plp_mat_sub_instance_i16</a></strong> <br>Instance structure for integer parallel matrix subtraction.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__i32/">plp_mat_sub_instance_i32</a></strong> <br>Instance structure for integer parallel matrix subtraction.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__f32/">plp_mat_sub_instance_f32</a></strong> <br>Instance structure for floating-point parallel matrix subtraction.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__i8/">plp_mat_scale_instance_i8</a></strong> <br>Instance structure for integer parallel matrix scale.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__i16/">plp_mat_scale_instance_i16</a></strong> <br>Instance structure for integer parallel matrix scale.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__i32/">plp_mat_scale_instance_i32</a></strong> <br>Instance structure for integer parallel matrix scale.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__f32/">plp_mat_scale_instance_f32</a></strong> <br>Instance structure for floating-point parallel matrix scale.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__trans__instance__i8/">plp_mat_trans_instance_i8</a></strong> <br>Instance structure for integer parallel matrix transpose.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__trans__instance__i16/">plp_mat_trans_instance_i16</a></strong> <br>Instance structure for integer parallel matrix transpose.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__trans__instance__i32/">plp_mat_trans_instance_i32</a></strong> <br>Instance structure for integer parallel matrix transpose.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__i8/">plp_mat_fill_I_instance_i8</a></strong> <br>Instance structure for integer parallel identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__i16/">plp_mat_fill_I_instance_i16</a></strong> <br>Instance structure for integer parallel identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__i32/">plp_mat_fill_I_instance_i32</a></strong> <br>Instance structure for integer parallel identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__f32/">plp_mat_fill_I_instance_f32</a></strong> <br>Instance structure for floating-point parallel identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__q8/">plp_mat_fill_I_instance_q8</a></strong> <br>Instance structure for fix-point parallel identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__q16/">plp_mat_fill_I_instance_q16</a></strong> <br>Instance structure for fix-point parallel identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__q32/">plp_mat_fill_I_instance_q32</a></strong> <br>Instance structure for fix-point parallel identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__inv__instance__f32/">plp_mat_inv_instance_f32</a></strong> <br>Instance structure for floating-point parallel matrix inversion.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i8/">plp_mat_mult_stride_instance_i8</a></strong> <br>Instance structure for strided integer parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i16/">plp_mat_mult_stride_instance_i16</a></strong> <br>Instance structure for strided integer parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i32/">plp_mat_mult_stride_instance_i32</a></strong> <br>Instance structure for strided integer parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__f32/">plp_mat_mult_stride_instance_f32</a></strong> <br>Instance structure for strided floating-point parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q8/">plp_mat_mult_stride_instance_q8</a></strong> <br>Instance structure for strided 8-bit fix-point parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q16/">plp_mat_mult_stride_instance_q16</a></strong> <br>Instance structure for strided 16-bit fix-point parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q32/">plp_mat_mult_stride_instance_q32</a></strong> <br>Instance structure for strided 32-bit fix-point parallel matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__i8/">plp_mat_mult_cmplx_stride_instance_i8</a></strong> <br>Instance structure for integer parallel complex strided matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__i16/">plp_mat_mult_cmplx_stride_instance_i16</a></strong> <br>Instance structure for integer parallel complex strided matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__i32/">plp_mat_mult_cmplx_stride_instance_i32</a></strong> <br>Instance structure for integer parallel complex strided matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__f32/">plp_mat_mult_cmplx_stride_instance_f32</a></strong> <br>Instance structure for floating-point parallel complex strided matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__q8/">plp_mat_mult_cmplx_stride_instance_q8</a></strong> <br>Instance structure for 8-bit fix-point parallel complex strided matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__q16/">plp_mat_mult_cmplx_stride_instance_q16</a></strong> <br>Instance structure for 16-bit fix-point parallel complex strided matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__q32/">plp_mat_mult_cmplx_stride_instance_q32</a></strong> <br>Instance structure for 32-bit fix-point parallel complex strided matrix matrix multiplication.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__i8/">plp_mat_add_stride_instance_i8</a></strong> <br>Instance structure for strided integer parallel matrix addition.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__i16/">plp_mat_add_stride_instance_i16</a></strong> <br>Instance structure for strided integer parallel matrix addition.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__i32/">plp_mat_add_stride_instance_i32</a></strong> <br>Instance structure for strided integer parallel matrix addition.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__f32/">plp_mat_add_stride_instance_f32</a></strong> <br>Instance structure for strided floating-point parallel matrix addition.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__i8/">plp_mat_sub_stride_instance_i8</a></strong> <br>Instance structure for strided integer parallel matrix subtraction.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__i16/">plp_mat_sub_stride_instance_i16</a></strong> <br>Instance structure for strided integer parallel matrix subtraction.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__i32/">plp_mat_sub_stride_instance_i32</a></strong> <br>Instance structure for strided integer parallel matrix subtraction.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__f32/">plp_mat_sub_stride_instance_f32</a></strong> <br>Instance structure for strided floating-point parallel matrix subtraction.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__i8/">plp_mat_scale_stride_instance_i8</a></strong> <br>Instance structure for strided integer parallel matrix scale.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__i16/">plp_mat_scale_stride_instance_i16</a></strong> <br>Instance structure for strided integer parallel matrix scale.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__i32/">plp_mat_scale_stride_instance_i32</a></strong> <br>Instance structure for strided integer parallel matrix scale.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__f32/">plp_mat_scale_stride_instance_f32</a></strong> <br>Instance structure for strided floating-point parallel matrix scale.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__i8/">plp_mat_fill_I_stride_instance_i8</a></strong> <br>Instance structure for integer parallel strided identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__i16/">plp_mat_fill_I_stride_instance_i16</a></strong> <br>Instance structure for integer parallel strided identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__i32/">plp_mat_fill_I_stride_instance_i32</a></strong> <br>Instance structure for integer parallel strided identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__f32/">plp_mat_fill_I_stride_instance_f32</a></strong> <br>Instance structure for floating-point parallel strided identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__q8/">plp_mat_fill_I_stride_instance_q8</a></strong> <br>Instance structure for 8-bit fix-point parallel strided identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__q16/">plp_mat_fill_I_stride_instance_q16</a></strong> <br>Instance structure for 16-bit fix-point parallel strided identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__q32/">plp_mat_fill_I_stride_instance_q32</a></strong> <br>Instance structure for 32-bit fix-point parallel strided identity matrix creation.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__stride__instance__i8/">plp_mat_fill_stride_instance_i8</a></strong> <br>Instance structure for filling an integer matrix in parallel.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__stride__instance__i16/">plp_mat_fill_stride_instance_i16</a></strong> <br>Instance structure for filling an integer matrix in parallel.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__stride__instance__i32/">plp_mat_fill_stride_instance_i32</a></strong> <br>Instance structure for filling an integer matrix in parallel.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__stride__instance__f32/">plp_mat_fill_stride_instance_f32</a></strong> <br>Instance structure for filling a floating-point matrix in parallel.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__copy__stride__instance__i8/">plp_mat_copy_stride_instance_i8</a></strong> <br>Instance structure for integer parallel strided matrix copy.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__copy__stride__instance__i16/">plp_mat_copy_stride_instance_i16</a></strong> <br>Instance structure for integer parallel strided matrix copy.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__copy__stride__instance__i32/">plp_mat_copy_stride_instance_i32</a></strong> <br>Instance structure for integer parallel strided matrix copy.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__mat__copy__stride__instance__f32/">plp_mat_copy_stride_instance_f32</a></strong> <br>Instance structure for floating-point parallel strided matrix copy.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__euclidean__distance__instance__f32/">plp_euclidean_distance_instance_f32</a></strong> <br>Instance structure for float parallel Euclidean distance.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__euclidean__distance__instance__q32/">plp_euclidean_distance_instance_q32</a></strong> <br>Instance structure for float parallel Euclidean distance.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__cosine__distance__instance__f32/">plp_cosine_distance_instance_f32</a></strong> <br>Instance structure for float parallel cosine distance.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__power__instance__q32/">plp_power_instance_q32</a></strong> <br>Instance structure for fixed point parallel power.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__power__instance__f32/">plp_power_instance_f32</a></strong> <br>Instance structure for float parallel power.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__f32/">plp_dwt_wavelet_f32</a></strong></td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q32/">plp_dwt_wavelet_q32</a></strong></td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q16/">plp_dwt_wavelet_q16</a></strong></td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q8/">plp_dwt_wavelet_q8</a></strong></td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__f32/">plp_dwt_instance_f32</a></strong> <br>Instance structure for float parallel dwt.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__q32/">plp_dwt_instance_q32</a></strong> <br>Instance structure for Q32 parallel dwt.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__q16/">plp_dwt_instance_q16</a></strong> <br>Instance structure for Q16 parallel dwt.</td>
</tr>
<tr>
<td>struct</td>
<td><strong><a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__q8/">plp_dwt_instance_q8</a></strong> <br>Instance structure for Q8 parallel dwt.</td>
</tr>
</tbody>
</table>
<h2 id="types">Types</h2>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>enum</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#enum-plp-dwt-wavelet-type">plp_dwt_wavelet_type</a></strong> { PLP_DWT_WAVELET_OTHER, PLP_DWT_WAVELET_HAAR, PLP_DWT_WAVELET_DB1, PLP_DWT_WAVELET_DB2, PLP_DWT_WAVELET_DB3, PLP_DWT_WAVELET_DB4, PLP_DWT_WAVELET_DB5, PLP_DWT_WAVELET_DB6, PLP_DWT_WAVELET_DB7, PLP_DWT_WAVELET_DB8, PLP_DWT_WAVELET_DB9, PLP_DWT_WAVELET_DB10, PLP_DWT_WAVELET_DB11, PLP_DWT_WAVELET_DB12, PLP_DWT_WAVELET_DB13, PLP_DWT_WAVELET_DB14, PLP_DWT_WAVELET_DB15, PLP_DWT_WAVELET_DB16, PLP_DWT_WAVELET_DB17, PLP_DWT_WAVELET_DB18, PLP_DWT_WAVELET_DB19, PLP_DWT_WAVELET_DB20, PLP_DWT_WAVELET_SYM2, PLP_DWT_WAVELET_SYM3, PLP_DWT_WAVELET_SYM4, PLP_DWT_WAVELET_SYM5, PLP_DWT_WAVELET_SYM6, PLP_DWT_WAVELET_SYM7, PLP_DWT_WAVELET_SYM8, PLP_DWT_WAVELET_SYM9, PLP_DWT_WAVELET_SYM10, PLP_DWT_WAVELET_SYM11, PLP_DWT_WAVELET_SYM12, PLP_DWT_WAVELET_SYM13, PLP_DWT_WAVELET_SYM14, PLP_DWT_WAVELET_SYM15, PLP_DWT_WAVELET_SYM16, PLP_DWT_WAVELET_SYM17, PLP_DWT_WAVELET_SYM18, PLP_DWT_WAVELET_SYM19, PLP_DWT_WAVELET_SYM20, PLP_DWT_WAVELET_COIF1, PLP_DWT_WAVELET_COIF2, PLP_DWT_WAVELET_COIF3, PLP_DWT_WAVELET_COIF4, PLP_DWT_WAVELET_COIF5, PLP_DWT_WAVELET_COIF6, PLP_DWT_WAVELET_COIF7, PLP_DWT_WAVELET_COIF8, PLP_DWT_WAVELET_COIF9, PLP_DWT_WAVELET_COIF10, PLP_DWT_WAVELET_COIF11, PLP_DWT_WAVELET_COIF12, PLP_DWT_WAVELET_COIF13, PLP_DWT_WAVELET_COIF14, PLP_DWT_WAVELET_COIF15, PLP_DWT_WAVELET_COIF16, PLP_DWT_WAVELET_COIF17}</td>
</tr>
<tr>
<td>enum</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#enum-plp-dwt-extension-mode">plp_dwt_extension_mode</a></strong> { PLP_DWT_MODE_ZERO, PLP_DWT_MODE_CONSTANT, PLP_DWT_MODE_SYMMETRIC, PLP_DWT_MODE_REFLECT, PLP_DWT_MODE_PERIODIC, PLP_DWT_MODE_ANTISYMMETRIC, PLP_DWT_MODE_ANTIREFLECT}</td>
</tr>
<tr>
<td>typedef float</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#typedef-float32-t">float32_t</a></strong></td>
</tr>
</tbody>
</table>
<h2 id="functions">Functions</h2>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>uint32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt__common/#function-plp-dwt-max-level">plp_dwt_max_level</a></strong>(uint32_t sig_len, uint32_t wavelet_len)<br>Computes maximum available decomposition level for a signal length and wavelet length.</td>
</tr>
<tr>
<td>uint32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt__common/#function-plp-dwt-dec-len">plp_dwt_dec_len</a></strong>(uint32_t sig_len, uint32_t wavelet_len, uint32_t level)<br>Calculates decomposition output length given a level.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProd/#function-plp-dot-prod-i32-parallel">plp_dot_prod_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t nPE, int32_t *<strong>restrict</strong> pRes)<br>Glue code for parallel dot product of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProd/#function-plp-dot-prod-q32-parallel">plp_dot_prod_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, uint32_t nPE, int32_t *<strong>restrict</strong> pRes)<br>Glue code for parallel dot product of 32-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProd/#function-plp-dot-prod-f32-parallel">plp_dot_prod_f32_parallel</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t nPE, float32_t *<strong>restrict</strong> pRes)<br>Glue code for parallel dot product of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-i32p-xpulpv2">plp_dot_prod_i32p_xpulpv2</a></strong>(void * S)<br>Parallel dot product with interleaved access of 32-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-q32p-xpulpv2">plp_dot_prod_q32p_xpulpv2</a></strong>(void * S)<br>Parallel dot product with interleaved access of 32-bit fixed point vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-f32p-xpulpv2">plp_dot_prod_f32p_xpulpv2</a></strong>(void * S)<br>Parallel dot product with interleaved access of 32-bit float vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProd/#function-plp-dot-prod-i32">plp_dot_prod_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, int32_t *<strong>restrict</strong> pRes)<br>Glue code for dot product of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-i32s-rv32im">plp_dot_prod_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, int32_t *<strong>restrict</strong> pRes)<br>Scalar dot product of 32-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-i32s-xpulpv2">plp_dot_prod_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, int32_t *<strong>restrict</strong> pRes)<br>Scalar dot product of 32-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProd/#function-plp-dot-prod-q32">plp_dot_prod_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Glue code for dot product of 32-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-q32s-rv32im">plp_dot_prod_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Scalar dot product of 32-bit fixed point vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-q32s-xpulpv2">plp_dot_prod_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Scalar dot product of 32-bit fixed point vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProd/#function-plp-dot-prod-f32">plp_dot_prod_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, float32_t *<strong>restrict</strong> pRes)<br>Glue code for dot product of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-f32s-xpulpv2">plp_dot_prod_f32s_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, float32_t *<strong>restrict</strong> pRes)<br>Glue code for dot product of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-f32s-rv32im">plp_dot_prod_f32s_rv32im</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, float32_t *<strong>restrict</strong> pRes)<br>Glue code for dot product of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-dot-prod-i16">plp_dot_prod_i16</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, uint32_t blockSize, int32_t *<strong>restrict</strong> pRes)<br>Glue code for dot product of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-i16s-rv32im">plp_dot_prod_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, int32_t *<strong>restrict</strong> pRes)<br>Vectorized dot product of 16-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-i16s-xpulpv2">plp_dot_prod_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, int32_t *<strong>restrict</strong> pRes)<br>Vectorized dot product of 16-bit integer vectors kernel singlecore for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProd/#function-plp-dot-prod-q16">plp_dot_prod_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Glue code for dot product of 16-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-q16s-rv32im">plp_dot_prod_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Scalar dot product of 16-bit fixed point vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-q16s-xpulpv2">plp_dot_prod_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Vectorized dot product of 16-bit fixed point vectors singlecore kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProd/#function-plp-dot-prod-i8">plp_dot_prod_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, int32_t *<strong>restrict</strong> pRes)<br>Glue code for dot product of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-i8s-rv32im">plp_dot_prod_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, int32_t *<strong>restrict</strong> pRes)<br>Vectorized dot product of 8-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-i8s-xpulpv2">plp_dot_prod_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, int32_t *<strong>restrict</strong> pRes)<br>Vectorized dot product of 8-bit integer vectors singlecore kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProd/#function-plp-dot-prod-q8">plp_dot_prod_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Glue code for dot product of 8-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-q8s-rv32im">plp_dot_prod_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Scalar dot product of 8-bit fixed point vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicDotProdKernels/#function-plp-dot-prod-q8s-xpulpv2">plp_dot_prod_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Scalar dot product of 8-bit fixed point vectors singlecore kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAbs/#function-plp-abs-i32">plp_abs_i32</a></strong>(const int32_t * pSrc, int32_t * pDst, uint32_t blockSize)<br>Glue code for absolute value of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAbsKernels/#function-plp-abs-i32s-rv32im">plp_abs_i32s_rv32im</a></strong>(const int32_t * pSrc, int32_t * pDst, uint32_t blockSize)<br>Element-by-element absolute value of 32-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAbsKernels/#function-plp-abs-i32s-xpulpv2">plp_abs_i32s_xpulpv2</a></strong>(const int32_t * pSrc, int32_t * pDst, uint32_t blockSize)<br>Element-by-element absolute value of 32-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAbs/#function-plp-abs-i16">plp_abs_i16</a></strong>(const int16_t * pSrc, int16_t * pDst, uint32_t blockSize)<br>Glue code for absolute value of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAbsKernels/#function-plp-abs-i16s-rv32im">plp_abs_i16s_rv32im</a></strong>(const int16_t * pSrc, int16_t * pDst, uint32_t blockSize)<br>Element-by-element absolute value of 16-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAbsKernels/#function-plp-abs-i16s-xpulpv2">plp_abs_i16s_xpulpv2</a></strong>(const int16_t * pSrc, int16_t * pDst, uint32_t blockSize)<br>Element-by-element absolute value of 16-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAbs/#function-plp-abs-i8">plp_abs_i8</a></strong>(const int8_t * pSrc, int8_t * pDst, uint32_t blockSize)<br>Glue code for absolute value of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAbsKernels/#function-plp-abs-i8s-rv32im">plp_abs_i8s_rv32im</a></strong>(const int8_t * pSrc, int8_t * pDst, uint32_t blockSize)<br>Element-by-element absolute value of 8-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAbsKernels/#function-plp-abs-i8s-xpulpv2">plp_abs_i8s_xpulpv2</a></strong>(const int8_t * pSrc, int8_t * pDst, uint32_t blockSize)<br>Element-by-element absolute value of 8-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAdd/#function-plp-add-i32">plp_add_i32</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Glue code for element-by-element addition of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAddKernels/#function-plp-add-i32s-rv32im">plp_add_i32s_rv32im</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element addition of 32-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAddKernels/#function-plp-add-i32s-xpulpv2">plp_add_i32s_xpulpv2</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element addition of 32-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAdd/#function-plp-add-i16">plp_add_i16</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Glue code for element-by-element addition of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAddKernels/#function-plp-add-i16s-rv32im">plp_add_i16s_rv32im</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element addition of 16-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAddKernels/#function-plp-add-i16s-xpulpv2">plp_add_i16s_xpulpv2</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element addition of 16-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAdd/#function-plp-add-i8">plp_add_i8</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Glue code for element-by-element addition of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAddKernels/#function-plp-add-i8s-rv32im">plp_add_i8s_rv32im</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element addition of 8-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicAddKernels/#function-plp-add-i8s-xpulpv2">plp_add_i8s_xpulpv2</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element addition of 8-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMult/#function-plp-mult-i32">plp_mult_i32</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Glue code for element-by-element multiplication of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMultKernels/#function-plp-mult-i32s-rv32im">plp_mult_i32s_rv32im</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element multiplication of 32-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMultKernels/#function-plp-mult-i32s-xpulpv2">plp_mult_i32s_xpulpv2</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element multiplication of 32-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMult/#function-plp-mult-i16">plp_mult_i16</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Glue code for element-by-element multiplication of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMultKernels/#function-plp-mult-i16s-rv32im">plp_mult_i16s_rv32im</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element multiplication of 16-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMultKernels/#function-plp-mult-i16s-xpulpv2">plp_mult_i16s_xpulpv2</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element multiplication of 16-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMult/#function-plp-mult-i8">plp_mult_i8</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Glue code for element-by-element multiplication of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMultKernels/#function-plp-mult-i8s-rv32im">plp_mult_i8s_rv32im</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element multiplication of 8-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMultKernels/#function-plp-mult-i8s-xpulpv2">plp_mult_i8s_xpulpv2</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Element-by-element multiplication of 8-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMult/#function-plp-mult-f32">plp_mult_f32</a></strong>(const float32_t * pSrcA, const float32_t * pSrcB, float32_t * pDst, uint32_t blockSize)<br>Glue code for element-by-element multiplication of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMultKernels/#function-plp-mult-f32s-xpulpv2">plp_mult_f32s_xpulpv2</a></strong>(const float32_t * pSrcA, const float32_t * pSrcB, float32_t * pDst, uint32_t blockSize)<br>Element-by-element multiplication of 32-bit float vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMult/#function-plp-mult-f32-parallel">plp_mult_f32_parallel</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t nPE, float32_t *<strong>restrict</strong> pDst)<br>Glue code for parallel dot product of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMultKernels/#function-plp-mult-f32p-xpulpv2">plp_mult_f32p_xpulpv2</a></strong>(void * S)<br>Parallel multiplication with interleaved access of 32-bit float vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicLog/#function-plp-log-f32-parallel">plp_log_f32_parallel</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t nPE, float32_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel log of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicLogKernels/#function-plp-log-f32p-xpulpv2">plp_log_f32p_xpulpv2</a></strong>(void * S)<br>Parallel log with interleaved access of 32-bit float vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegate/#function-plp-negate-i32">plp_negate_i32</a></strong>(const int32_t * pSrc, int32_t * pDst, uint32_t blockSize)<br>Glue code of negate the elements of a vector for 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegateKernels/#function-plp-negate-i32s-rv32im">plp_negate_i32s_rv32im</a></strong>(const int32_t * pSrc, int32_t * pDst, uint32_t blockSize)<br>negate the elements of a vector for 32-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegateKernels/#function-plp-negate-i32s-xpulpv2">plp_negate_i32s_xpulpv2</a></strong>(const int32_t * pSrc, int32_t * pDst, uint32_t blockSize)<br>negate the elements of a vector for 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegate/#function-plp-negate-i16">plp_negate_i16</a></strong>(const int16_t * pSrc, int16_t * pDst, uint32_t blockSize)<br>Glue code of negate the elements of a vector for 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegateKernels/#function-plp-negate-i16s-rv32im">plp_negate_i16s_rv32im</a></strong>(const int16_t * pSrc, int16_t * pDst, uint32_t blockSize)<br>negate the elements of a vector for 16-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegateKernels/#function-plp-negate-i16s-xpulpv2">plp_negate_i16s_xpulpv2</a></strong>(const int16_t * pSrc, int16_t * pDst, uint32_t blockSize)<br>negate the elements of a vector for 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegate/#function-plp-negate-i8">plp_negate_i8</a></strong>(const int8_t * pSrc, int8_t * pDst, uint32_t blockSize)<br>Glue code of negate the elements of a vector for 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegateKernels/#function-plp-negate-i8s-rv32im">plp_negate_i8s_rv32im</a></strong>(const int8_t * pSrc, int8_t * pDst, uint32_t blockSize)<br>negate the elements of a vector for 8-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegateKernels/#function-plp-negate-i8s-xpulpv2">plp_negate_i8s_xpulpv2</a></strong>(const int8_t * pSrc, int8_t * pDst, uint32_t blockSize)<br>negate the elements of a vector for 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegate/#function-plp-negate-f32">plp_negate_f32</a></strong>(const float32_t * pSrc, float32_t * pDst, uint32_t blockSize)<br>Glue code of negate the elements of a vector for 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicNegateKernels/#function-plp-negate-f32s-xpulpv2">plp_negate_f32s_xpulpv2</a></strong>(const float32_t * pSrc, float32_t * pDst, uint32_t blockSize)<br>negate the elements of a vector for 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffset/#function-plp-offset-i32">plp_offset_i32</a></strong>(const int32_t * pSrc, int32_t offset, int32_t * pDst, uint32_t blockSize)<br>Glue code of add a constant offset to a vector for 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffsetKernels/#function-plp-offset-i32s-rv32im">plp_offset_i32s_rv32im</a></strong>(const int32_t * pSrc, int32_t offset, int32_t * pDst, uint32_t blockSize)<br>add a constant offset to a vector for 32-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffsetKernels/#function-plp-offset-i32s-xpulpv2">plp_offset_i32s_xpulpv2</a></strong>(const int32_t * pSrc, int32_t offset, int32_t * pDst, uint32_t blockSize)<br>add a constant offset to a vector for 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffset/#function-plp-offset-i16">plp_offset_i16</a></strong>(const int16_t * pSrc, int16_t offset, int16_t * pDst, uint32_t blockSize)<br>Glue code of add a constant offset to a vector for 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffsetKernels/#function-plp-offset-i16s-rv32im">plp_offset_i16s_rv32im</a></strong>(const int16_t * pSrc, int16_t offset, int16_t * pDst, uint32_t blockSize)<br>add a constant offset to a vector for 16-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffsetKernels/#function-plp-offset-i16s-xpulpv2">plp_offset_i16s_xpulpv2</a></strong>(const int16_t * pSrc, int16_t offset, int16_t * pDst, uint32_t blockSize)<br>add a constant offset to a vector for 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffset/#function-plp-offset-i8">plp_offset_i8</a></strong>(const int8_t * pSrc, int8_t offset, int8_t * pDst, uint32_t blockSize)<br>Glue code of add a constant offset to a vector for 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffsetKernels/#function-plp-offset-i8s-rv32im">plp_offset_i8s_rv32im</a></strong>(const int8_t * pSrc, int8_t offset, int8_t * pDst, uint32_t blockSize)<br>add a constant offset to a vector for 8-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffsetKernels/#function-plp-offset-i8s-xpulpv2">plp_offset_i8s_xpulpv2</a></strong>(const int8_t * pSrc, int8_t offset, int8_t * pDst, uint32_t blockSize)<br>add a constant offset to a vector for 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffset/#function-plp-offset-f32">plp_offset_f32</a></strong>(const float32_t * pSrc, float32_t offset, float32_t * pDst, uint32_t blockSize)<br>Glue code of add a constant offset to a vector for 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicOffsetKernels/#function-plp-offset-f32s-xpulpv2">plp_offset_f32s_xpulpv2</a></strong>(const float32_t * pSrc, float32_t offset, float32_t * pDst, uint32_t blockSize)<br>add a constant offset to a vector for 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSub/#function-plp-sub-i32">plp_sub_i32</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Glue code of vector substraction for 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSubKernels/#function-plp-sub-i32s-rv32im">plp_sub_i32s_rv32im</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>vector substraction for 32-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSubKernels/#function-plp-sub-i32s-xpulpv2">plp_sub_i32s_xpulpv2</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>vector substraction for 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSub/#function-plp-sub-i16">plp_sub_i16</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Glue code of vector substraction for 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSubKernels/#function-plp-sub-i16s-rv32im">plp_sub_i16s_rv32im</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>vector substraction for 16-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSubKernels/#function-plp-sub-i16s-xpulpv2">plp_sub_i16s_xpulpv2</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>vector substraction for 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSub/#function-plp-sub-i8">plp_sub_i8</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>Glue code of vector substraction for 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSubKernels/#function-plp-sub-i8s-rv32im">plp_sub_i8s_rv32im</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>vector substraction for 8-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSubKernels/#function-plp-sub-i8s-xpulpv2">plp_sub_i8s_xpulpv2</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize)<br>vector substraction for 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSub/#function-plp-sub-f32">plp_sub_f32</a></strong>(const float32_t * pSrcA, const float32_t * pSrcB, float32_t * pDst, uint32_t blockSize)<br>Glue code of vector substraction for 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicSubKernels/#function-plp-sub-f32s-xpulpv2">plp_sub_f32s_xpulpv2</a></strong>(const float32_t * pSrcA, const float32_t * pSrcB, float32_t * pDst, uint32_t blockSize)<br>vector substraction for 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScale/#function-plp-scale-i32">plp_scale_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t scaleFactor, int32_t shift, int32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Glue code of multiply a vector by a scalar for 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScaleKernels/#function-plp-scale-i32s-rv32im">plp_scale_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t scaleFactor, int32_t shift, int32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>multiply a vector by a scalar for 32-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScaleKernels/#function-plp-scale-i32s-xpulpv2">plp_scale_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t scaleFactor, int32_t shift, int32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>multiply a vector by a scalar for 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScale/#function-plp-scale-i16">plp_scale_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t scaleFactor, int32_t shift, int16_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Glue code of multiply a vector by a scalar for 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScaleKernels/#function-plp-scale-i16s-rv32im">plp_scale_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t scaleFactor, int32_t shift, int16_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>multiply a vector by a scalar for 16-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScaleKernels/#function-plp-scale-i16s-xpulpv2">plp_scale_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t scaleFactor, int32_t shift, int16_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>multiply a vector by a scalar for 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScale/#function-plp-scale-i8">plp_scale_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t scaleFactor, int32_t shift, int8_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Glue code of multiply a vector by a scalar for 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScaleKernels/#function-plp-scale-i8s-rv32im">plp_scale_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t scaleFactor, int32_t shift, int8_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>multiply a vector by a scalar for 8-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScaleKernels/#function-plp-scale-i8s-xpulpv2">plp_scale_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t scaleFactor, int32_t shift, int8_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>multiply a vector by a scalar for 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScale/#function-plp-scale-f32">plp_scale_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, float32_t scaleFactor, float32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Glue code of multiply a vector by a scalar for 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicScaleKernels/#function-plp-scale-f32s-xpulpv2">plp_scale_f32s_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, float32_t scaleFactor, float32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>multiply a vector by a scalar for 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Fill/#function-plp-fill-i32">plp_fill_i32</a></strong>(int32_t value, int32_t *<strong>restrict</strong> pDst, uint32_t blockSize)<br>Glue code for filling a constant value into a 32-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__FillKernels/#function-plp-fill-i32s-rv32im">plp_fill_i32s_rv32im</a></strong>(int32_t value, int32_t *<strong>restrict</strong> pDst, uint32_t blockSize)<br>Fills a constant value into a 32-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__FillKernels/#function-plp-fill-i32s-xpulpv2">plp_fill_i32s_xpulpv2</a></strong>(int32_t value, int32_t *<strong>restrict</strong> pDst, uint32_t blockSize)<br>Fills a constant value into a 32-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Copy/#function-plp-copy-i32">plp_copy_i32</a></strong>(int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Glue code for copying the elements of a 32-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CopyKernels/#function-plp-copy-i32s-rv32im">plp_copy_i32s_rv32im</a></strong>(int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Copies the elements of a 32-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CopyKernels/#function-plp-copy-i32s-xpulpv2">plp_copy_i32s_xpulpv2</a></strong>(int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Copies the elements of a 32-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Copy/#function-plp-copy-f32">plp_copy_f32</a></strong>(float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Glue code for copying the elements of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CopyKernels/#function-plp-copy-f32s-xpulpv2">plp_copy_f32s_xpulpv2</a></strong>(float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Copies the elements of a 32-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CopyKernels/#function-plp-copy-f32s-rv32im">plp_copy_f32s_rv32im</a></strong>(float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst, uint32_t blockSize)<br>Copies the elements of a 32-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__mean/#function-plp-mean-f32">plp_mean_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Glue code for mean value of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__meanKernels/#function-plp-mean-f32s-xpulpv2">plp_mean_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Glue code for mean value of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__mean/#function-plp-mean-i32">plp_mean_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for mean value of a 32-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__meanKernels/#function-plp-mean-i32s-rv32im">plp_mean_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Mean value of a 32-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__meanKernels/#function-plp-mean-i32s-xpulpv2">plp_mean_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Mean value of a 32-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__mean/#function-plp-mean-i16">plp_mean_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int16_t </em><strong>restrict</strong> pRes)<br>Glue code for mean value of a 16-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__meanKernels/#function-plp-mean-i16s-rv32im">plp_mean_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int16_t </em><strong>restrict</strong> pRes)<br>Mean value of a 16-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__meanKernels/#function-plp-mean-i16s-xpulpv2">plp_mean_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int16_t </em><strong>restrict</strong> pRes)<br>Mean value of a 16-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__mean/#function-plp-mean-i8">plp_mean_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int8_t </em><strong>restrict</strong> pRes)<br>Glue code for mean value of a 8-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__meanKernels/#function-plp-mean-i8s-rv32im">plp_mean_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int8_t </em><strong>restrict</strong> pRes)<br>Mean value of a 8-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__meanKernels/#function-plp-mean-i8s-xpulpv2">plp_mean_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int8_t </em><strong>restrict</strong> pRes)<br>Mean value of a 8-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__max/#function-plp-max-f32">plp_max_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Glue code for max value of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__maxKernels/#function-plp-max-f32s-xpulpv2">plp_max_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Kernel for max value of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__max/#function-plp-max-i32">plp_max_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for max value of a 32-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__maxKernels/#function-plp-max-i32s-rv32im">plp_max_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Max value of a 32-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__maxKernels/#function-plp-max-i32s-xpulpv2">plp_max_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Max value of a 32-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__max/#function-plp-max-i16">plp_max_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int16_t </em><strong>restrict</strong> pRes)<br>Glue code for max value of a 16-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__maxKernels/#function-plp-max-i16s-rv32im">plp_max_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int16_t </em><strong>restrict</strong> pRes)<br>Max value of a 16-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__maxKernels/#function-plp-max-i16s-xpulpv2">plp_max_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int16_t </em><strong>restrict</strong> pRes)<br>Max value of a 16-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__max/#function-plp-max-i8">plp_max_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int8_t </em><strong>restrict</strong> pRes)<br>Glue code for max value of a 8-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__maxKernels/#function-plp-max-i8s-rv32im">plp_max_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int8_t </em><strong>restrict</strong> pRes)<br>Max value of a 8-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__maxKernels/#function-plp-max-i8s-xpulpv2">plp_max_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int8_t </em><strong>restrict</strong> pRes)<br>Max value of a 8-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__min/#function-plp-min-f32">plp_min_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Glue code for min value of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__minKernels/#function-plp-min-f32s-xpulpv2">plp_min_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Kernel for min value of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__min/#function-plp-min-i32">plp_min_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for min value of a 32-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__minKernels/#function-plp-min-i32s-rv32im">plp_min_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Min value of a 32-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__minKernels/#function-plp-min-i32s-xpulpv2">plp_min_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Min value of a 32-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__min/#function-plp-min-i16">plp_min_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int16_t </em><strong>restrict</strong> pRes)<br>Glue code for min value of a 16-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__minKernels/#function-plp-min-i16s-rv32im">plp_min_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int16_t </em><strong>restrict</strong> pRes)<br>Min value of a 16-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__minKernels/#function-plp-min-i16s-xpulpv2">plp_min_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int16_t </em><strong>restrict</strong> pRes)<br>Min value of a 16-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__min/#function-plp-min-i8">plp_min_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int8_t </em><strong>restrict</strong> pRes)<br>Glue code for min value of a 8-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__minKernels/#function-plp-min-i8s-rv32im">plp_min_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int8_t </em><strong>restrict</strong> pRes)<br>Min value of a 8-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__minKernels/#function-plp-min-i8s-xpulpv2">plp_min_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int8_t </em><strong>restrict</strong> pRes)<br>Min value of a 8-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-power-f32-parallel">plp_power_f32_parallel</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t nPE, float32_t </em><strong>restrict</strong> pRes)<br>Glue code for parallel power of 32-bit floating point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-f32p-xpulpv2">plp_power_f32p_xpulpv2</a></strong>(void * S)<br>Parallel sum of squares of a 32-bit float vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-power-f32">plp_power_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Glue code for Sum of squares of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-f32s-xpulpv2">plp_power_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Kernel for Sum of squares of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-f32s-rv32im">plp_power_f32s_rv32im</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Sum of squares of a 32-bit float vector for RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-power-i32">plp_power_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for Sum of squares of a 32-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-i32s-rv32im">plp_power_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 32-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-i32s-xpulpv2">plp_power_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 32-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-power-i16">plp_power_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for Sum of squares of a 16-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-i16s-rv32im">plp_power_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 16-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-i16s-xpulpv2">plp_power_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 16-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-power-i8">plp_power_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for Sum of squares of a 8-bit integer vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-i8s-rv32im">plp_power_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 8-bit integer vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-i8s-xpulpv2">plp_power_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 8-bit integer vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-power-q32-parallel">plp_power_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, uint32_t nPE, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for parallel power of 32-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-q32p-xpulpv2">plp_power_q32p_xpulpv2</a></strong>(void * S)<br>Parallel sum of squares of a 32-bit fixed-point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-power-q32">plp_power_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for Sum of squares of a 32-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-q32s-rv32im">plp_power_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 32-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-q32s-xpulpv2">plp_power_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 32-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-power-q16">plp_power_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for Sum of squares of a 16-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-q16s-rv32im">plp_power_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 16-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-q16s-xpulpv2">plp_power_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 16-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-power-q8">plp_power_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for Sum of squares of a 8-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-q8s-rv32im">plp_power_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 8-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__powerKernels/#function-plp-power-q8s-xpulpv2">plp_power_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Sum of squares of a 8-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__var/#function-plp-var-f32">plp_var_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Glue code for Statisical variance of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__varKernels/#function-plp-var-f32s-xpulpv2">plp_var_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Kernel for Statisical variance of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__var/#function-plp-var-q32">plp_var_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for Statisical variance of a 32-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__varKernels/#function-plp-var-q32s-rv32im">plp_var_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Statisical variance of a 32-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__varKernels/#function-plp-var-q32s-xpulpv2">plp_var_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Statisical variance of a 32-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__var/#function-plp-var-q16">plp_var_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Glue code for Statisical variance of a 16-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__varKernels/#function-plp-var-q16s-rv32im">plp_var_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Statisical variance of a 16-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__varKernels/#function-plp-var-q16s-xpulpv2">plp_var_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Statisical variance of a 16-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__var/#function-plp-var-q8">plp_var_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int8_t </em><strong>restrict</strong> pRes)<br>Glue code for Statisical variance of a 8-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__varKernels/#function-plp-var-q8s-rv32im">plp_var_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int8_t </em><strong>restrict</strong> pRes)<br>Statisical variance of a 8-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__varKernels/#function-plp-var-q8s-xpulpv2">plp_var_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int8_t </em><strong>restrict</strong> pRes)<br>Statisical variance of a 8-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__std/#function-plp-std-f32">plp_std_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Glue code for Statisical standard deviation of a 32-bit floating point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__stdKernels/#function-plp-std-f32s-xpulpv2">plp_std_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Kernel for Statisical standard deviation of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__std/#function-plp-std-q32">plp_std_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for Statisical standard deviation of a 32-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__stdKernels/#function-plp-std-q32s-rv32im">plp_std_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 32-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__stdKernels/#function-plp-std-q32s-xpulpv2">plp_std_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 32-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__std/#function-plp-std-q16">plp_std_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Glue code for Statisical standard deviation of a 16-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__stdKernels/#function-plp-std-q16s-rv32im">plp_std_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 16-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__stdKernels/#function-plp-std-q16s-xpulpv2">plp_std_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 16-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__std/#function-plp-std-q8">plp_std_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int8_t </em><strong>restrict</strong> pRes)<br>Glue code for Statisical standard deviation of a 8-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__stdKernels/#function-plp-std-q8s-rv32im">plp_std_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int8_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 8-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__stdKernels/#function-plp-std-q8s-xpulpv2">plp_std_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int8_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 8-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-rms-f32">plp_rms_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Glue code for Statisical standard deviation of a 32-bit floating point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__RMSkernels/#function-plp-rms-f32s-xpulpv2">plp_rms_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t blockSize, float </em><strong>restrict</strong> pRes)<br>Kernel for Statisical standard deviation of a 32-bit float vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-rms-q32">plp_rms_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for Statisical standard deviation of a 32-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__RMSkernels/#function-plp-rms-q32s-rv32im">plp_rms_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 32-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__RMSkernels/#function-plp-rms-q32s-xpulpv2">plp_rms_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 32-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-rms-q16">plp_rms_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Glue code for Statisical standard deviation of a 16-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__RMSkernels/#function-plp-rms-q16s-rv32im">plp_rms_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 16-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__RMSkernels/#function-plp-rms-q16s-xpulpv2">plp_rms_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 16-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__power/#function-plp-rms-q8">plp_rms_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int8_t </em><strong>restrict</strong> pRes)<br>Glue code for Statisical standard deviation of a 8-bit fixed point vector.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__RMSkernels/#function-plp-rms-q8s-rv32im">plp_rms_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int8_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 8-bit fixed point vector for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__RMSkernels/#function-plp-rms-q8s-xpulpv2">plp_rms_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t blockSize, uint32_t fracBits, int8_t </em><strong>restrict</strong> pRes)<br>Statisical standard deviation of a 8-bit fixed point vector for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__sqrt/#function-plp-sqrt-q32">plp_sqrt_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, const uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Glue code for square root of a 32-bit fixed point number.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__sqrtKernels/#function-plp-sqrt-q32s-rv32im">plp_sqrt_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, const uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Square root of a 32-bit fixed point number for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__sqrtKernels/#function-plp-sqrt-q32s-xpulpv2">plp_sqrt_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, const uint32_t fracBits, int32_t </em><strong>restrict</strong> pRes)<br>Square root of a 32-bit fixed point number for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__sqrt/#function-plp-sqrt-q16">plp_sqrt_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, const uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Glue code for square root of a 16-bit fixed point number.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__sqrtKernels/#function-plp-sqrt-q16s-rv32im">plp_sqrt_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, const uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Square root of a 16-bit fixed point number for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__sqrtKernels/#function-plp-sqrt-q16s-xpulpv2">plp_sqrt_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, const uint32_t fracBits, int16_t </em><strong>restrict</strong> pRes)<br>Square root of a 16-bit fixed point number for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__sqrt/#function-plp-sqrt-f32">plp_sqrt_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, float </em><strong>restrict</strong> pRes)<br>Glue code for square root of a 32-bit floating point number.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__sqrtKernels/#function-plp-sqrt-f32s-rv32im">plp_sqrt_f32s_rv32im</a></strong>(const float <em><strong>restrict</strong> pSrc, float </em><strong>restrict</strong> pRes)<br>Square root of a 32-bit floating point number for RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__sqrtKernels/#function-plp-sqrt-f32s-xpulpv2">plp_sqrt_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, float </em><strong>restrict</strong> pRes)<br>Kernel for square root of a 32-bit floating point number.</td>
</tr>
<tr>
<td>int32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cos-q32">plp_cos_q32</a></strong>(int32_t x)<br>Glue code for q32 cosine function.</td>
</tr>
<tr>
<td>int32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cos-q32s-rv32im">plp_cos_q32s_rv32im</a></strong>(int32_t x)<br>q32 cosine function for RV32IM</td>
</tr>
<tr>
<td>int32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cos-q32s-xpulpv2">plp_cos_q32s_xpulpv2</a></strong>(int32_t x)<br>q32 cosine function for XPULPV2</td>
</tr>
<tr>
<td>int16_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cos-q16">plp_cos_q16</a></strong>(int16_t x)<br>Glue code for q16 cosine function.</td>
</tr>
<tr>
<td>int16_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cos-q16s-rv32im">plp_cos_q16s_rv32im</a></strong>(int16_t x)<br>q16 cosine function for RV32IM</td>
</tr>
<tr>
<td>int16_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cos-q16s-xpulpv2">plp_cos_q16s_xpulpv2</a></strong>(int16_t x)<br>q16 cosine function for XPULPV2</td>
</tr>
<tr>
<td>float32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cos-f32">plp_cos_f32</a></strong>(float32_t x)<br>Glue code for f32 cosine function.</td>
</tr>
<tr>
<td>float32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cos-f32s-xpulpv2">plp_cos_f32s_xpulpv2</a></strong>(float32_t x)<br>F32 cosine function for XPULPV2.</td>
</tr>
<tr>
<td>int32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-sin-q32">plp_sin_q32</a></strong>(int32_t x)<br>Glue code for q32 sine function.</td>
</tr>
<tr>
<td>int32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-sin-q32s-rv32im">plp_sin_q32s_rv32im</a></strong>(int32_t x)<br>q32 sine function for RV32IM</td>
</tr>
<tr>
<td>int32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-sin-q32s-xpulpv2">plp_sin_q32s_xpulpv2</a></strong>(int32_t x)<br>q32 sine function for XPULPV2</td>
</tr>
<tr>
<td>int16_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-sin-q16">plp_sin_q16</a></strong>(int16_t x)<br>Glue code for q16 sine function.</td>
</tr>
<tr>
<td>int16_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-sin-q16s-rv32im">plp_sin_q16s_rv32im</a></strong>(int16_t x)<br>q16 sine function for RV32IM</td>
</tr>
<tr>
<td>int16_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-sin-q16s-xpulpv2">plp_sin_q16s_xpulpv2</a></strong>(int16_t x)<br>q16 sine function for XPULPV2</td>
</tr>
<tr>
<td>float32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-sin-f32">plp_sin_f32</a></strong>(float32_t x)<br>Glue code for f32 sine function.</td>
</tr>
<tr>
<td>float32_t</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-sin-f32s-xpulpv2">plp_sin_f32s_xpulpv2</a></strong>(float32_t x)<br>F32 sine function for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-i32">plp_correlate_i32</a></strong>(const int32_t * pSrcA, const uint32_t srcALen, const int32_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for correlation of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-i32s-rv32im">plp_correlate_i32s_rv32im</a></strong>(const int32_t * pSrcA, const uint32_t srcALen, const int32_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Correlation of 32-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-i32s-xpulpv2">plp_correlate_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const uint32_t srcALen, const int32_t </em><strong>restrict</strong> pSrcB, const uint32_t srcBLen, int32_t *<strong>restrict</strong> pRes)<br>Correlation of 32-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-i16">plp_correlate_i16</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for correlation of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-i16s-xpulpv2">plp_correlate_i16s_xpulpv2</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Correlation of 16-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-i16s-rv32im">plp_correlate_i16s_rv32im</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Correlation of 16-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-i8">plp_correlate_i8</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for correlation of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-valid-i8">plp_correlate_valid_i8</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for correlation (valid) of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-i8s-xpulpv2">plp_correlate_i8s_xpulpv2</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Correlation of 8-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-i8s-rv32im">plp_correlate_i8s_rv32im</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Correlation of 8-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-q32">plp_correlate_q32</a></strong>(const int32_t * pSrcA, const uint32_t srcALen, const int32_t * pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t * pRes)<br>Glue code for correlation of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-q32s-rv32im">plp_correlate_q32s_rv32im</a></strong>(const int32_t * pSrcA, const uint32_t srcALen, const int32_t * pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t * pRes)<br>Correlation of 32-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-q32s-xpulpv2">plp_correlate_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const uint32_t srcALen, const int32_t </em><strong>restrict</strong> pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>Correlation of 32-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-q16">plp_correlate_q16</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t * pRes)<br>Glue code for correlation of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-q16s-xpulpv2">plp_correlate_q16s_xpulpv2</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t * pRes)<br>Correlation of 16-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-q16s-rv32im">plp_correlate_q16s_rv32im</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t * pRes)<br>Correlation of 16-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-q8">plp_correlate_q8</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t * pRes)<br>Glue code for correlation of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-correlate-valid-q8">plp_correlate_valid_q8</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t * pRes)<br>Glue code for correlation (valid) of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-q8s-xpulpv2">plp_correlate_q8s_xpulpv2</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t * pRes)<br>Correlation of 8-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicCorrelationKernels/#function-plp-correlate-q8s-rv32im">plp_correlate_q8s_rv32im</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, const uint32_t fracBits, int32_t * pRes)<br>Correlation of 8-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-conv-i32">plp_conv_i32</a></strong>(const int32_t * pSrcA, const uint32_t srcALen, const int32_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for convolution of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-valid-i32">plp_conv_valid_i32</a></strong>(const int32_t * pSrcA, const uint32_t srcALen, const int32_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for convolution (valid) of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-i32s-rv32im">plp_conv_i32s_rv32im</a></strong>(const int32_t * pSrcA, const uint32_t srcALen, const int32_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Convolution of 32-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-conv-i32s-xpulpv2">plp_conv_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const uint32_t srcALen, const int32_t </em><strong>restrict</strong> pSrcB, const uint32_t srcBLen, int32_t *<strong>restrict</strong> pRes)<br>Convolution of 32-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-conv-valid-i32s-xpulpv2">plp_conv_valid_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const uint32_t srcALen, const int32_t </em><strong>restrict</strong> pSrcB, const uint32_t srcBLen, int32_t *<strong>restrict</strong> pRes)<br>Convolution (valid) of 32-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-i16">plp_conv_i16</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for convolution of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-valid-i16">plp_conv_valid_i16</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for convolution (valid) of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-valid-rep-i16">plp_conv_valid_rep_i16</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for convolution (valid with replication) of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-i16s-xpulpv2">plp_conv_i16s_xpulpv2</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Convolution of 16-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-valid-i16s-xpulpv2">plp_conv_valid_i16s_xpulpv2</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Convolution (valid) of 16-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-valid-rep-i16s-xpulpv2">plp_conv_valid_rep_i16s_xpulpv2</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const uint32_t srcAMem, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Convolution (valid with data replication) of 16-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-i16s-rv32im">plp_conv_i16s_rv32im</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Convolution of 16-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-i8">plp_conv_i8</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for convolution of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-valid-i8">plp_conv_valid_i8</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for convolution (valid) of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-valid-rep-i8">plp_conv_valid_rep_i8</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Glue code for convolution (valid with data replication) of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-i8s-xpulpv2">plp_conv_i8s_xpulpv2</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Convolution of 8-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-valid-i8s-xpulpv2">plp_conv_valid_i8s_xpulpv2</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Convolution (valid) of 8-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-valid-rep-i8s-xpulpv2">plp_conv_valid_rep_i8s_xpulpv2</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const uint32_t srcAMem, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Convolution (valid with data replication) of 8-bit integer vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-i8s-rv32im">plp_conv_i8s_rv32im</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, int32_t * pRes)<br>Convolution of 8-bit integer vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-i32-parallel">plp_conv_i32_parallel</a></strong>(const int32_t * pSrcA, const uint32_t srcALen, const int32_t * pSrcB, const uint32_t srcBLen, const uint8_t nPE, int32_t * pRes)<br>Glue code for parallel convolution of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-i32p-xpulpv2">plp_conv_i32p_xpulpv2</a></strong>(void * task_args)<br>Setup code for parallel convolution of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-i16-parallel">plp_conv_i16_parallel</a></strong>(const int16_t * pSrcA, const uint32_t srcALen, const int16_t * pSrcB, const uint32_t srcBLen, const uint8_t nPE, int32_t * pRes)<br>Glue code for parallel convolution of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-i16p-xpulpv2">plp_conv_i16p_xpulpv2</a></strong>(void * task_args)<br>Setup code for parallel convolution of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolution/#function-plp-conv-i8-parallel">plp_conv_i8_parallel</a></strong>(const int8_t * pSrcA, const uint32_t srcALen, const int8_t * pSrcB, const uint32_t srcBLen, const uint8_t nPE, int32_t * pRes)<br>Glue code for parallel convolution of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-i8p-xpulpv2">plp_conv_i8p_xpulpv2</a></strong>(void * task_args)<br>Setup code for parallel convolution of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-parallel-ola">plp_conv_parallel_OLA</a></strong>(uint32_t nPE, uint32_t srcALen, uint32_t srcBLen, int32_t * resultsBuffer)<br>Helper function for parallelized overlap-adding of partial convolution results.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicConvolutionKernels/#function-plp-conv-parallel-ola-kernel">plp_conv_parallel_OLA_kernel</a></strong>(void * task_args)<br>Helper function for parallelized overlap-adding of partial convolution results.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-i32">plp_mat_mult_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix matrix multiplication of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-i32s-rv32im">plp_mat_mult_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-i32s-xpulpv2">plp_mat_mult_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-i16">plp_mat_mult_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix matrix multiplication of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-i16s-rv32im">plp_mat_mult_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-i16s-xpulpv2">plp_mat_mult_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-i8">plp_mat_mult_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix matrix multiplication of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-i8s-rv32im">plp_mat_mult_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-i8s-xpulpv2">plp_mat_mult_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-i32-parallel">plp_mat_mult_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix matrix multiplication of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-i32p-xpulpv2">plp_mat_mult_i32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-i16-parallel">plp_mat_mult_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix matrix multiplication of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-i16p-xpulpv2">plp_mat_mult_i16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 16-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-i8-parallel">plp_mat_mult_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix matrix multiplication of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-f32">plp_mat_mult_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, float *<strong>restrict</strong> pDstC)<br>Glue code for matrix matrix multiplication of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-f32s-xpulpv2">plp_mat_mult_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, float *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-f32-parallel">plp_mat_mult_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, float *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix matrix multiplication of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-f32p-xpulpv2">plp_mat_mult_f32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-i8p-xpulpv2">plp_mat_mult_i8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 8-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-q32">plp_mat_mult_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix matrix multiplication of a 32-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-q32-parallel">plp_mat_mult_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix matrix multiplication of a 32-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-q32s-rv32im">plp_mat_mult_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 32-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-q32s-xpulpv2">plp_mat_mult_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-q32p-xpulpv2">plp_mat_mult_q32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-q16">plp_mat_mult_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix matrix multiplication of a 16-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-q16-parallel">plp_mat_mult_q16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int16_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix matrix multiplication of a 16-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-q16s-rv32im">plp_mat_mult_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 16-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-q16s-xpulpv2">plp_mat_mult_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-q16p-xpulpv2">plp_mat_mult_q16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-q8">plp_mat_mult_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix matrix multiplication of a 8-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMult/#function-plp-mat-mult-q8-parallel">plp_mat_mult_q8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int8_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix matrix multiplication of a 8-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-q8s-rv32im">plp_mat_mult_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 8-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-q8s-xpulpv2">plp_mat_mult_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultKernels/#function-plp-mat-mult-q8p-xpulpv2">plp_mat_mult_q8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-i32">plp_mat_mult_cmplx_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix matrix multiplication for complex 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-i32s-rv32im">plp_mat_mult_cmplx_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 32-bit integers on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-i32s-xpulpv2">plp_mat_mult_cmplx_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 32-bit integers on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-i32-parallel">plp_mat_mult_cmplx_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix matrix multiplication for complex 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-i32p-xpulpv2">plp_mat_mult_cmplx_i32p_xpulpv2</a></strong>(void * args)<br>parallel matrix matrix multiplication for complex 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-i16">plp_mat_mult_cmplx_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix matrix multiplication for complex 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-i16s-rv32im">plp_mat_mult_cmplx_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 16-bit integers on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-i16s-xpulpv2">plp_mat_mult_cmplx_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 16-bit integers on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-i16-parallel">plp_mat_mult_cmplx_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix matrix multiplication for complex 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-i16p-xpulpv2">plp_mat_mult_cmplx_i16p_xpulpv2</a></strong>(void * args)<br>parallel matrix matrix multiplication for complex 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-i8">plp_mat_mult_cmplx_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix matrix multiplication for complex 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-i8s-rv32im">plp_mat_mult_cmplx_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 8-bit integers on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-i8s-xpulpv2">plp_mat_mult_cmplx_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 8-bit integers on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-i8-parallel">plp_mat_mult_cmplx_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix matrix multiplication for complex 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-i8p-xpulpv2">plp_mat_mult_cmplx_i8p_xpulpv2</a></strong>(void * args)<br>parallel matrix matrix multiplication for complex 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-f32">plp_mat_mult_cmplx_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, float *<strong>restrict</strong> pDstC)<br>Glue code of matrix matrix multiplication for complex 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-f32s-xpulpv2">plp_mat_mult_cmplx_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, float *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 32-bit floats on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-f32-parallel">plp_mat_mult_cmplx_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, float *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix matrix multiplication for complex 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-f32p-xpulpv2">plp_mat_mult_cmplx_f32p_xpulpv2</a></strong>(void * args)<br>parallel matrix matrix multiplication for complex 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-q32">plp_mat_mult_cmplx_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix matrix multiplication for complex 32-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-q32s-rv32im">plp_mat_mult_cmplx_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 32-bit fix-point on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-q32s-xpulpv2">plp_mat_mult_cmplx_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 32-bit fix-point on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-q32-parallel">plp_mat_mult_cmplx_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix matrix multiplication for complex 32-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-q32p-xpulpv2">plp_mat_mult_cmplx_q32p_xpulpv2</a></strong>(void * args)<br>parallel matrix matrix multiplication for complex 32-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-q16">plp_mat_mult_cmplx_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix matrix multiplication for complex 16-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-q16s-rv32im">plp_mat_mult_cmplx_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 16-bit fix-point on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-q16s-xpulpv2">plp_mat_mult_cmplx_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 16-bit fix-point on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-q16-parallel">plp_mat_mult_cmplx_q16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int16_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix matrix multiplication for complex 16-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-q16p-xpulpv2">plp_mat_mult_cmplx_q16p_xpulpv2</a></strong>(void * args)<br>parallel matrix matrix multiplication for complex 16-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-q8">plp_mat_mult_cmplx_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix matrix multiplication for complex 8-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-q8s-rv32im">plp_mat_mult_cmplx_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 8-bit fix-point on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-q8s-xpulpv2">plp_mat_mult_cmplx_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Matrix matrix multiplication for complex 8-bit fix-point on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplx/#function-plp-mat-mult-cmplx-q8-parallel">plp_mat_mult_cmplx_q8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int8_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix matrix multiplication for complex 8-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxKernels/#function-plp-mat-mult-cmplx-q8p-xpulpv2">plp_mat_mult_cmplx_q8p_xpulpv2</a></strong>(void * args)<br>parallel matrix matrix multiplication for complex 8-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-i32">plp_mat_mult_trans_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix transposed matrix multiplication of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-i32s-rv32im">plp_mat_mult_trans_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-i32s-xpulpv2">plp_mat_mult_trans_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix transposed matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-i16">plp_mat_mult_trans_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix transposed matrix multiplication of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-i16s-rv32im">plp_mat_mult_trans_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix transposed matrix multiplication of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-i16s-xpulpv2">plp_mat_mult_trans_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-i8">plp_mat_mult_trans_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix transposed matrix multiplication of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-i8s-rv32im">plp_mat_mult_trans_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix transposed matrix multiplication of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-i8s-xpulpv2">plp_mat_mult_trans_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-i32-parallel">plp_mat_mult_trans_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix matrix multiplication of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-i32p-xpulpv2">plp_mat_mult_trans_i32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-i16-parallel">plp_mat_mult_trans_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix transposed matrix multiplication of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-i16p-xpulpv2">plp_mat_mult_trans_i16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-i8-parallel">plp_mat_mult_trans_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix transposed matrix multiplication of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-i8p-xpulpv2">plp_mat_mult_trans_i8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-q32">plp_mat_mult_trans_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix transposed matrix multiplication of a 32-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-q32-parallel">plp_mat_mult_trans_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix transposed matrix multiplication of a 32-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-q32s-rv32im">plp_mat_mult_trans_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>matrix transposed matrix multiplication of a 32-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-q32s-xpulpv2">plp_mat_mult_trans_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>matrix transposed matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-q32p-xpulpv2">plp_mat_mult_trans_q32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transposed matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-q16">plp_mat_mult_trans_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix transposed matrix multiplication of a 16-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-q16-parallel">plp_mat_mult_trans_q16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int16_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix transposed matrix multiplication of a 16-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-q16s-rv32im">plp_mat_mult_trans_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>matrix transposed matrix multiplication of a 16-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-q16s-xpulpv2">plp_mat_mult_trans_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>matrix transposed matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-q16p-xpulpv2">plp_mat_mult_trans_q16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transposed matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-q8">plp_mat_mult_trans_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Glue code for matrix transposed matrix multiplication of a 8-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-q8-parallel">plp_mat_mult_trans_q8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int8_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix transposed matrix multiplication of a 8-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-q8s-rv32im">plp_mat_mult_trans_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>matrix transposed matrix multiplication of a 8-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-q8s-xpulpv2">plp_mat_mult_trans_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>matrix transposed matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-q8p-xpulpv2">plp_mat_mult_trans_q8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transposed matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-f32">plp_mat_mult_trans_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, float *<strong>restrict</strong> pDstC)<br>Glue code for matrix transposed matrix multiplication of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-f32s-xpulpv2">plp_mat_mult_trans_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, float *<strong>restrict</strong> pDstC)<br>matrix transposed matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTrans/#function-plp-mat-mult-trans-f32-parallel">plp_mat_mult_trans_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, float *<strong>restrict</strong> pDstC)<br>Glue code for parallel matrix transposed matrix multiplication of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransKernels/#function-plp-mat-mult-trans-f32p-xpulpv2">plp_mat_mult_trans_f32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transposed matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-i32">plp_mat_mult_trans_cmplx_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix transpose matrix multiplication for complex 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-i32s-rv32im">plp_mat_mult_trans_cmplx_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 32-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-i32s-xpulpv2">plp_mat_mult_trans_cmplx_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-i32-parallel">plp_mat_mult_trans_cmplx_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix transpose matrix multiplication for complex 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-i32p-xpulpv2">plp_mat_mult_trans_cmplx_i32p_xpulpv2</a></strong>(void * args)<br>parallel matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-i16">plp_mat_mult_trans_cmplx_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix transpose matrix multiplication for complex 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-i16s-rv32im">plp_mat_mult_trans_cmplx_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 16-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-i16s-xpulpv2">plp_mat_mult_trans_cmplx_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-i16-parallel">plp_mat_mult_trans_cmplx_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix transpose matrix multiplication for complex 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-i16p-xpulpv2">plp_mat_mult_trans_cmplx_i16p_xpulpv2</a></strong>(void * args)<br>parallel matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-i8">plp_mat_mult_trans_cmplx_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix transpose matrix multiplication for complex 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-i8s-rv32im">plp_mat_mult_trans_cmplx_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 8-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-i8s-xpulpv2">plp_mat_mult_trans_cmplx_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, int32_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-i8-parallel">plp_mat_mult_trans_cmplx_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix transpose matrix multiplication for complex 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-i8p-xpulpv2">plp_mat_mult_trans_cmplx_i8p_xpulpv2</a></strong>(void * args)<br>parallel matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-f32">plp_mat_mult_trans_cmplx_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, float *<strong>restrict</strong> pDstC)<br>Glue code of matrix transpose matrix multiplication for complex 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-f32s-xpulpv2">plp_mat_mult_trans_cmplx_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, float *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-f32-parallel">plp_mat_mult_trans_cmplx_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t nPE, float *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix transpose matrix multiplication for complex 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-f32p-xpulpv2">plp_mat_mult_trans_cmplx_f32p_xpulpv2</a></strong>(void * args)<br>parallel matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-q32">plp_mat_mult_trans_cmplx_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix transpose matrix multiplication for complex 32-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-q32s-rv32im">plp_mat_mult_trans_cmplx_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 32-bit fix-point on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-q32s-xpulpv2">plp_mat_mult_trans_cmplx_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-q32-parallel">plp_mat_mult_trans_cmplx_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix transpose matrix multiplication for complex 32-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-q32p-xpulpv2">plp_mat_mult_trans_cmplx_q32p_xpulpv2</a></strong>(void * args)<br>parallel matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-q16">plp_mat_mult_trans_cmplx_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix transpose matrix multiplication for complex 16-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-q16s-rv32im">plp_mat_mult_trans_cmplx_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 16-bit fix-point on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-q16s-xpulpv2">plp_mat_mult_trans_cmplx_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-q16-parallel">plp_mat_mult_trans_cmplx_q16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int16_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix transpose matrix multiplication for complex 16-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-q16p-xpulpv2">plp_mat_mult_trans_cmplx_q16p_xpulpv2</a></strong>(void * args)<br>parallel matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-q8">plp_mat_mult_trans_cmplx_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Glue code of matrix transpose matrix multiplication for complex 8-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-q8s-rv32im">plp_mat_mult_trans_cmplx_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 8-bit fix-point on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-q8s-xpulpv2">plp_mat_mult_trans_cmplx_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplx/#function-plp-mat-mult-trans-cmplx-q8-parallel">plp_mat_mult_trans_cmplx_q8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t shift, uint32_t nPE, int8_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel matrix transpose matrix multiplication for complex 8-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxKernels/#function-plp-mat-mult-trans-cmplx-q8p-xpulpv2">plp_mat_mult_trans_cmplx_q8p_xpulpv2</a></strong>(void * args)<br>parallel matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-f32">plp_cmplx_mag_f32</a></strong>(const float32_t * pSrc, float32_t * pRes, uint32_t numSamples)<br>Glue code for complex magnitude calculation in float32.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-f32s-xpulpv2">plp_cmplx_mag_f32s_xpulpv2</a></strong>(const float32_t * pSrc, float32_t * pRes, uint32_t numSamples)<br>complex magnitude for float32 on XPULPV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-q32">plp_cmplx_mag_q32</a></strong>(const int32_t * pSrc, const uint32_t fracBits, int32_t * pRes, uint32_t numSamples)<br>Glue code for complex magnitude calculation for 32 bit fixpoint.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-q32s-rv32im">plp_cmplx_mag_q32s_rv32im</a></strong>(const int32_t * pSrc, const uint32_t fracBits, int32_t * pRes, uint32_t numSamples)<br>complex magnitude for q32 on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-q32s-xpulpv2">plp_cmplx_mag_q32s_xpulpv2</a></strong>(const int32_t * pSrc, const uint32_t fracBits, int32_t * pRes, uint32_t numSamples)<br>complex magnitude for q32 on XPULPV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-q8">plp_cmplx_mag_q8</a></strong>(const int8_t * pSrc, const uint32_t fracBits, int8_t * pRes, uint32_t numSamples)<br>Glue code for complex magnitude calculation for 8 bit fixpoint.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-q8s-rv32im">plp_cmplx_mag_q8s_rv32im</a></strong>(const int8_t * pSrc, const uint32_t fracBits, int8_t * pRes, uint32_t numSamples)<br>complex magnitude for q8 on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-q8s-xpulpv2">plp_cmplx_mag_q8s_xpulpv2</a></strong>(const int8_t * pSrc, const uint32_t fracBits, int8_t * pRes, uint32_t numSamples)<br>complex magnitude for q8 on XPULPV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-i16">plp_cmplx_mag_i16</a></strong>(const int16_t * pSrc, int16_t * pRes, uint32_t numSamples)<br>Glue code for complex magnitude calculation in 16-bit integer.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-i16s-rv32im">plp_cmplx_mag_i16s_rv32im</a></strong>(const int16_t * pSrc, int16_t * pRes, uint32_t numSamples)<br>complex magnitude for i16 on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-i16s-xpulpv2">plp_cmplx_mag_i16s_xpulpv2</a></strong>(const int16_t * pSrc, int16_t * pRes, uint32_t numSamples)<br>complex magnitude for i16 on XPULPV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-i32">plp_cmplx_mag_i32</a></strong>(const int32_t * pSrc, int32_t * pRes, uint32_t numSamples)<br>Glue code for complex magnitude calculation in 32-bit integer.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-i32s-rv32im">plp_cmplx_mag_i32s_rv32im</a></strong>(const int32_t * pSrc, int32_t * pRes, uint32_t numSamples)<br>complex magnitude for i32 on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-i32s-xpulpv2">plp_cmplx_mag_i32s_xpulpv2</a></strong>(const int32_t * pSrc, int32_t * pRes, uint32_t numSamples)<br>complex magnitude for i32 on XPULPV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-i8">plp_cmplx_mag_i8</a></strong>(const int8_t * pSrc, int8_t * pRes, uint32_t numSamples)<br>Glue code for complex magnitude calculation in 8-bit integer.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-i8s-rv32im">plp_cmplx_mag_i8s_rv32im</a></strong>(const int8_t * pSrc, int8_t * pRes, uint32_t numSamples)<br>complex magnitude for i8 on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-i8s-xpulpv2">plp_cmplx_mag_i8s_xpulpv2</a></strong>(const int8_t * pSrc, int8_t * pRes, uint32_t numSamples)<br>complex magnitude for i8 on XPULPV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-q16">plp_cmplx_mag_q16</a></strong>(const int16_t * pSrc, const uint32_t fracBits, int16_t * pRes, uint32_t numSamples)<br>Glue code for complex magnitude calculation in 16-bit quantized integer.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-q16s-rv32im">plp_cmplx_mag_q16s_rv32im</a></strong>(const int16_t * pSrc, const uint32_t fracBits, int16_t * pRes, uint32_t numSamples)<br>complex magnitude for q16 on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag/#function-plp-cmplx-mag-q16s-xpulpv2">plp_cmplx_mag_q16s_xpulpv2</a></strong>(const int16_t * pSrc, const uint32_t fracBits, int16_t * pRes, uint32_t numSamples)<br>complex magnitude for q16 on XPULPV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-bitreversal-16s-rv32im">plp_bitreversal_16s_rv32im</a></strong>(uint16_t * pSrc, const uint16_t bitRevLen, const uint16_t * pBitRevTab)<br>In-place 16 bit reversal function for RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-bitreversal-16s-xpulpv2">plp_bitreversal_16s_xpulpv2</a></strong>(uint16_t * pSrc, const uint16_t bitRevLen, const uint16_t * pBitRevTab)<br>In-place 16 bit reversal function for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-bitreversal-16p-xpulpv2">plp_bitreversal_16p_xpulpv2</a></strong>(uint16_t * pSrc, const uint16_t bitRevLen, const uint16_t * pBitRevTab, uint32_t nPE)<br>In-place 16 bit reversal function.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q16">plp_cfft_q16</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q16/">plp_cfft_instance_q16</a> * S, int16_t * p1, uint8_t ifftFlag, uint8_t bitReverseFlag, uint32_t deciPoint)<br>Glue code for quantized 16 bit complex fast fourier transform.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q16-parallel">plp_cfft_q16_parallel</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q16/">plp_cfft_instance_q16</a> * S, int16_t * p1, uint8_t ifftFlag, uint8_t bitReverseFlag, uint32_t deciPoint, uint32_t nPE)<br>Glue code for quantized 16 bit complex fast fourier transform.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q16s-rv32im">plp_cfft_q16s_rv32im</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q16/">plp_cfft_instance_q16</a> * S, int16_t * p1, uint8_t ifftFlag, uint8_t bitReverseFlag, uint32_t deciPoint)<br>Quantized 16 bit complex fast fourier transform for RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q16s-xpulpv2">plp_cfft_q16s_xpulpv2</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q16/">plp_cfft_instance_q16</a> * S, int16_t * p1, uint8_t ifftFlag, uint8_t bitReverseFlag, uint32_t deciPoint)<br>Quantized 16 bit complex fast fourier transform for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q16p-xpulpv2">plp_cfft_q16p_xpulpv2</a></strong>(void * args)<br>Parallel quantized 16 bit complex fast fourier transform for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-bitreversal-32s-rv32im">plp_bitreversal_32s_rv32im</a></strong>(uint32_t * pSrc, const uint16_t bitRevLen, const uint16_t * pBitRevTab)<br>In-place 32 bit reversal function for RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-bitreversal-32s-xpulpv2">plp_bitreversal_32s_xpulpv2</a></strong>(uint32_t * pSrc, const uint16_t bitRevLen, const uint16_t * pBitRevTab)<br>In-place 32 bit reversal function for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-bitreversal-32p-xpulpv2">plp_bitreversal_32p_xpulpv2</a></strong>(uint32_t * pSrc, const uint16_t bitRevLen, const uint16_t * pBitRevTab, uint32_t nPE)<br>In-place 32 bit reversal function for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q32">plp_cfft_q32</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q32/">plp_cfft_instance_q32</a> * S, int32_t * p1, uint8_t ifftFlag, uint8_t bitReverseFlag, uint32_t fracBits)<br>Glue code for quantized 32-bit complex fast fourier transform.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q32-parallel">plp_cfft_q32_parallel</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q32/">plp_cfft_instance_q32</a> * S, int32_t * p1, uint8_t ifftFlag, uint8_t bitReverseFlag, uint32_t fracBits, uint32_t nPE)<br>Quantized 32-bit complex fast fourier transform for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q32s-rv32im">plp_cfft_q32s_rv32im</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q32/">plp_cfft_instance_q32</a> * S, int32_t * p1, uint8_t ifftFlag, uint8_t bitReverseFlag, uint32_t fracBits)<br>Quantized 32-bit complex fast fourier transform for RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q32s-xpulpv2">plp_cfft_q32s_xpulpv2</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q32/">plp_cfft_instance_q32</a> * S, int32_t * p1, uint8_t ifftFlag, uint8_t bitReverseFlag, uint32_t fracBits)<br>Quantized 32-bit complex fast fourier transform for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-q32p-xpulpv2">plp_cfft_q32p_xpulpv2</a></strong>(void * args)<br>Parallel quantized 32 bit complex fast fourier transform for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-rfft-f32">plp_rfft_f32</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a> * S, const float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst)<br>Floating-point FFT on real input data.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-rfft-f32-parallel">plp_rfft_f32_parallel</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a> * S, const float32_t <em><strong>restrict</strong> pSrc, const uint32_t nPE, float32_t </em><strong>restrict</strong> pDst)<br>Floating-point FFT on real input data (parallel version).</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realFFTKernels/#function-plp-rfft-f32s-xpulpv2">plp_rfft_f32s_xpulpv2</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a> * S, const float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst)<br>Floating-point FFT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realFFTKernels/#function-plp-rfft-f32p-xpulpv2">plp_rfft_f32p_xpulpv2</a></strong>(void * arg)<br>Floating-point FFT on real input data for XPULPV2 extension (parallel version).</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-rfftfast-f32">plp_rfftfast_f32</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__fast__instance__f32/">plp_fft_fast_instance_f32</a> * S, const float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst)<br>Floating-point FFT on real input data.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-rfftfast-f32-parallel">plp_rfftfast_f32_parallel</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__fast__instance__f32/">plp_fft_fast_instance_f32</a> * S, float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst, const uint32_t nPE)<br>Floating-point parallel FFT on real input data.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-rfftfast-f32s-xpulpv2">plp_rfftfast_f32s_xpulpv2</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__fast__instance__f32/">plp_fft_fast_instance_f32</a> * S, float32_t * pSrc, float32_t * pDst)<br>Floating-point FFT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-rfftfast-f32p-xpulpv2">plp_rfftfast_f32p_xpulpv2</a></strong>(void * arg)<br>Floating-point parallel FFT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-f32">plp_cfft_f32</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__f32/">plp_cfft_instance_f32</a> * S, float32_t * pSrc, uint8_t ifftFlag, uint8_t bitReverseFlag)<br>Floating-point FFT on complex input data.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-cfft-f32-parallel">plp_cfft_f32_parallel</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__f32/">plp_cfft_instance_f32</a> * S, const float32_t * pSrc, uint8_t ifftFlag, uint8_t bitReverseFlag, const uint32_t nPE)<br>Floating-point FFT on complex input data (parallel version).</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__complexFFTKernels/#function-plp-cfft-f32s-xpulpv2">plp_cfft_f32s_xpulpv2</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__f32/">plp_cfft_instance_f32</a> * S, const float32_t * pSrc, uint8_t ifftFlag, uint8_t bitReverseFlag)<br>Floating-point FFT on complex input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__complexFFTKernels/#function-plp-cfft-f32p-xpulpv2">plp_cfft_f32p_xpulpv2</a></strong>(void * arg)<br>Floating-point FFT on complex input data for XPULPV2 extension (parallel version).</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-dct2-f32">plp_dct2_f32</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a> * S, const <a href="/pulp-dsp/refmanual/Classes/structComplex__type__f32/">Complex_type_f32</a> * pShift, const uint8_t orthoNorm, const float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pBuf, float32_t *<strong>restrict</strong> pDst)<br>Floating-point DCT on real input data. Implementation of John Makhoul's "A Fast Cosine Transform in One                      and Two Dimensions" 1980 IEEE paper.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__fft/#function-plp-dct2-f32-parallel">plp_dct2_f32_parallel</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a> * S, const <a href="/pulp-dsp/refmanual/Classes/structComplex__type__f32/">Complex_type_f32</a> * pShift, const uint8_t orthoNorm, const float32_t <em><strong>restrict</strong> pSrc, const uint32_t nPE, float32_t </em><strong>restrict</strong> pBuf, float32_t *<strong>restrict</strong> pDst)<br>Floating-point DCT on real input data. Implementation of John Makhoul's "A Fast Cosine Transform in One                      and Two Dimensions" 1980 IEEE paper.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__feature/#function-plp-mfcc-f32">plp_mfcc_f32</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a> * SFFT, const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a> * SDCT, const <a href="/pulp-dsp/refmanual/Classes/structComplex__type__f32/">Complex_type_f32</a> * pShift, const <a href="/pulp-dsp/refmanual/Classes/structplp__triangular__filter__f32/">plp_triangular_filter_f32</a> * filterBank, const float32_t * window, const uint8_t * orthoNorm, const float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst)<br>MFCC on real input data.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__feature/#function-plp-mfcc-f32-parallel">plp_mfcc_f32_parallel</a></strong>(const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a> * SFFT, const <a href="/pulp-dsp/refmanual/Classes/structplp__fft__instance__f32/">plp_fft_instance_f32</a> * SDCT, const <a href="/pulp-dsp/refmanual/Classes/structComplex__type__f32/">Complex_type_f32</a> * pShift, const <a href="/pulp-dsp/refmanual/Classes/structplp__triangular__filter__f32/">plp_triangular_filter_f32</a> * filterBank, const float32_t * window, const uint8_t * orthoNorm, const float32_t <em><strong>restrict</strong> pSrc, const uint32_t nPE, float32_t </em><strong>restrict</strong> pDst)<br>MFCC on real input data.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-f32">plp_dwt_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__f32/">plp_dwt_wavelet_f32</a> wavelet, plp_dwt_extension_mode mode, float32_t </em><strong>restrict</strong> pDstA, float32_t *<strong>restrict</strong> pDstD)<br>Glue code for matrix addition of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-q32">plp_dwt_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q32/">plp_dwt_wavelet_q32</a> wavelet, plp_dwt_extension_mode mode, int32_t </em><strong>restrict</strong> pDstA, int32_t *<strong>restrict</strong> pDstD)<br>32bit Fixed-point DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-q16">plp_dwt_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q16/">plp_dwt_wavelet_q16</a> wavelet, plp_dwt_extension_mode mode, int16_t </em><strong>restrict</strong> pDstA, int16_t *<strong>restrict</strong> pDstD)<br>16bit Fixed-point DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-q8">plp_dwt_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q8/">plp_dwt_wavelet_q8</a> wavelet, plp_dwt_extension_mode mode, int8_t </em><strong>restrict</strong> pDstA, int8_t *<strong>restrict</strong> pDstD)<br>8bit Fixed-point DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-dec-f32">plp_dwt_dec_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__f32/">plp_dwt_wavelet_f32</a> wavelet, plp_dwt_extension_mode mode, uint32_t level, float32_t </em><strong>restrict</strong> pTmp, float32_t *<strong>restrict</strong> pDst)<br>Floating-point n-level DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-dec-f32-parallel">plp_dwt_dec_f32_parallel</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__f32/">plp_dwt_wavelet_f32</a> wavelet, plp_dwt_extension_mode mode, uint32_t level, uint32_t nPE, float32_t </em><strong>restrict</strong> pTemp, float32_t *<strong>restrict</strong> pDst)<br>Floating-point parallel n-level DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realDWTKernels/#function-plp-dwt-f32s-xpulpv2">plp_dwt_f32s_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__f32/">plp_dwt_wavelet_f32</a> wavelet, plp_dwt_extension_mode mode, float32_t </em><strong>restrict</strong> pDstA, float32_t *<strong>restrict</strong> pDstD)<br>Floating-point DWT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realDWTKernels/#function-plp-dwt-haar-f32s-xpulpv2">plp_dwt_haar_f32s_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, uint32_t length, plp_dwt_extension_mode mode, float32_t </em><strong>restrict</strong> pDstA, float32_t *<strong>restrict</strong> pDstD)<br>Floating-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q32DWTKernels/#function-plp-dwt-q32s-xpulpv2">plp_dwt_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q32/">plp_dwt_wavelet_q32</a> wavelet, plp_dwt_extension_mode mode, int32_t </em><strong>restrict</strong> pDstA, int32_t *<strong>restrict</strong> pDstD)<br>32bit Fixed-point DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-dwt-haar-q32s-xpulpv2">plp_dwt_haar_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t length, plp_dwt_extension_mode mode, int32_t </em><strong>restrict</strong> pDstA, int32_t *<strong>restrict</strong> pDstD)<br>32bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q16DWTKernels/#function-plp-dwt-q16s-xpulpv2">plp_dwt_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q16/">plp_dwt_wavelet_q16</a> wavelet, plp_dwt_extension_mode mode, int16_t </em><strong>restrict</strong> pDstA, int16_t *<strong>restrict</strong> pDstD)<br>16bit Fixed-point DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q16DWTKernels/#function-plp-dwt-haar-q16s-xpulpv2">plp_dwt_haar_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t length, plp_dwt_extension_mode mode, int16_t </em><strong>restrict</strong> pDstA, int16_t *<strong>restrict</strong> pDstD)<br>16bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q8DWTKernels/#function-plp-dwt-q8s-xpulpv2">plp_dwt_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q8/">plp_dwt_wavelet_q8</a> wavelet, plp_dwt_extension_mode mode, int8_t </em><strong>restrict</strong> pDstA, int8_t *<strong>restrict</strong> pDstD)<br>8bit Fixed-point DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q8DWTKernels/#function-plp-dwt-haar-q8s-xpulpv2">plp_dwt_haar_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t length, plp_dwt_extension_mode mode, int8_t </em><strong>restrict</strong> pDstA, int8_t *<strong>restrict</strong> pDstD)<br>8bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-f32-parallel">plp_dwt_f32_parallel</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__f32/">plp_dwt_wavelet_f32</a> wavelet, plp_dwt_extension_mode mode, uint32_t nPE, float32_t </em><strong>restrict</strong> pDstA, float32_t *<strong>restrict</strong> pDstD)<br>Parallel Floating-point DWT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-q8-parallel">plp_dwt_q8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q8/">plp_dwt_wavelet_q8</a> wavelet, plp_dwt_extension_mode mode, uint32_t nPE, int8_t </em><strong>restrict</strong> pDstA, int8_t *<strong>restrict</strong> pDstD)<br>8bit Parallel Fixed-point DWT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-q16-parallel">plp_dwt_q16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q16/">plp_dwt_wavelet_q16</a> wavelet, plp_dwt_extension_mode mode, uint32_t nPE, int16_t </em><strong>restrict</strong> pDstA, int16_t *<strong>restrict</strong> pDstD)<br>16bit Parallel Fixed-point DWT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__dwt/#function-plp-dwt-q32-parallel">plp_dwt_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q32/">plp_dwt_wavelet_q32</a> wavelet, plp_dwt_extension_mode mode, uint32_t nPE, int32_t </em><strong>restrict</strong> pDstA, int32_t *<strong>restrict</strong> pDstD)<br>32bit Parallel Fixed-point DWT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realDWTKernels/#function-plp-dwt-f32p-xpulpv2">plp_dwt_f32p_xpulpv2</a></strong>(void * args)<br>Floating-point DWT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realDWTKernels/#function-plp-dwt-haar-f32p-xpulpv2">plp_dwt_haar_f32p_xpulpv2</a></strong>(void * args)<br>Floating-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q8DWTKernels/#function-plp-dwt-q8p-xpulpv2">plp_dwt_q8p_xpulpv2</a></strong>(void * args)<br>Q7 fixed-point DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q8DWTKernels/#function-plp-dwt-haar-q8p-xpulpv2">plp_dwt_haar_q8p_xpulpv2</a></strong>(void * args)<br>q7 fixed-point DWT kernel optimized for Haar Wavelet for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q16DWTKernels/#function-plp-dwt-q16p-xpulpv2">plp_dwt_q16p_xpulpv2</a></strong>(void * args)<br>Q15 fixed-point DWT for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q16DWTKernels/#function-plp-dwt-haar-q16p-xpulpv2">plp_dwt_haar_q16p_xpulpv2</a></strong>(void * args)<br>q15 fixed-point DWT kernel optimized for Haar Wavelet for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q32DWTKernels/#function-plp-dwt-q32p-xpulpv2">plp_dwt_q32p_xpulpv2</a></strong>(void * arg)<br>Q31 fixed-point DWT on real input data for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__q32DWTKernels/#function-plp-dwt-haar-q32p-xpulpv2">plp_dwt_haar_q32p_xpulpv2</a></strong>(void * args)<br>Q31 Fixed-point DWT kernel optimized for Haar Wavelet for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realDWTKernels/#function-plp-dwt-q32s-rv32im">plp_dwt_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q32/">plp_dwt_wavelet_q32</a> wavelet, plp_dwt_extension_mode mode, int32_t </em><strong>restrict</strong> pDstA, int32_t *<strong>restrict</strong> pDstD)<br>32bit Fixed-point DWT.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-dwt-haar-q32s-rv32im">plp_dwt_haar_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t length, plp_dwt_extension_mode mode, int32_t </em><strong>restrict</strong> pDstA, int32_t *<strong>restrict</strong> pDstD)<br>32bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realDWTKernels/#function-plp-dwt-q16s-rv32im">plp_dwt_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q16/">plp_dwt_wavelet_q16</a> wavelet, plp_dwt_extension_mode mode, int16_t </em><strong>restrict</strong> pDstA, int16_t *<strong>restrict</strong> pDstD)<br>16bit Fixed-point DWT.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realDWTKernels/#function-plp-dwt-haar-q16s-rv32im">plp_dwt_haar_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t length, plp_dwt_extension_mode mode, int16_t </em><strong>restrict</strong> pDstA, int16_t *<strong>restrict</strong> pDstD)<br>16bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realDWTKernels/#function-plp-dwt-q8s-rv32im">plp_dwt_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t length, const <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__wavelet__q8/">plp_dwt_wavelet_q8</a> wavelet, plp_dwt_extension_mode mode, int8_t </em><strong>restrict</strong> pDstA, int8_t *<strong>restrict</strong> pDstD)<br>8bit Fixed-point DWT.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__realDWTKernels/#function-plp-dwt-haar-q8s-rv32im">plp_dwt_haar_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t length, plp_dwt_extension_mode mode, int8_t </em><strong>restrict</strong> pDstA, int8_t *<strong>restrict</strong> pDstD)<br>8bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAdd/#function-plp-mat-add-i32">plp_mat_add_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int32_t *<strong>restrict</strong> pDst)<br>Glue code for matrix addition of 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-i32s-rv32im">plp_mat_add_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int32_t *<strong>restrict</strong> pDst)<br>matrix addition of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-i32s-xpulpv2">plp_mat_add_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int32_t *<strong>restrict</strong> pDst)<br>matrix addition of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAdd/#function-plp-mat-add-i32-parallel">plp_mat_add_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t nPE, int32_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix addition of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-i32p-xpulpv2">plp_mat_add_i32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix addition of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAdd/#function-plp-mat-add-i16">plp_mat_add_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int16_t *<strong>restrict</strong> pDst)<br>Glue code for matrix addition of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-i16s-rv32im">plp_mat_add_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int16_t *<strong>restrict</strong> pDst)<br>matrix addition of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-i16s-xpulpv2">plp_mat_add_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int16_t *<strong>restrict</strong> pDst)<br>matrix addition of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAdd/#function-plp-mat-add-i16-parallel">plp_mat_add_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t nPE, int16_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix addition of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-i16p-xpulpv2">plp_mat_add_i16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix addition of 16-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAdd/#function-plp-mat-add-i8">plp_mat_add_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int8_t *<strong>restrict</strong> pDst)<br>Glue code for matrix addition of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-i8s-rv32im">plp_mat_add_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int8_t *<strong>restrict</strong> pDst)<br>matrix addition of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-i8s-xpulpv2">plp_mat_add_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int8_t *<strong>restrict</strong> pDst)<br>matrix addition of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAdd/#function-plp-mat-add-i8-parallel">plp_mat_add_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t nPE, int8_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix addition of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-i8p-xpulpv2">plp_mat_add_i8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix addition of 8-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAdd/#function-plp-mat-add-f32">plp_mat_add_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, float *<strong>restrict</strong> pDst)<br>Glue code for matrix addition of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-f32s-xpulpv2">plp_mat_add_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, float *<strong>restrict</strong> pDst)<br>matrix addition of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAdd/#function-plp-mat-add-f32-parallel">plp_mat_add_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t nPE, float *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix addition of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddKernels/#function-plp-mat-add-f32p-xpulpv2">plp_mat_add_f32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix addition of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSub/#function-plp-mat-sub-i32">plp_mat_sub_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int32_t *<strong>restrict</strong> pDst)<br>Glue code for matrix subtraction of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-i32s-rv32im">plp_mat_sub_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int32_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-i32s-xpulpv2">plp_mat_sub_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int32_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSub/#function-plp-mat-sub-i32-parallel">plp_mat_sub_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t nPE, int32_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix subtraction of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-i32p-xpulpv2">plp_mat_sub_i32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix subtraction of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSub/#function-plp-mat-sub-i16">plp_mat_sub_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int16_t *<strong>restrict</strong> pDst)<br>Glue code for matrix subtraction of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-i16s-rv32im">plp_mat_sub_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int16_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-i16s-xpulpv2">plp_mat_sub_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int16_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSub/#function-plp-mat-sub-i16-parallel">plp_mat_sub_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t nPE, int16_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix subtraction of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-i16p-xpulpv2">plp_mat_sub_i16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix subtraction of 16-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSub/#function-plp-mat-sub-i8">plp_mat_sub_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int8_t *<strong>restrict</strong> pDst)<br>Glue code for matrix subtraction of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-i8s-rv32im">plp_mat_sub_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int8_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-i8s-xpulpv2">plp_mat_sub_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, int8_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSub/#function-plp-mat-sub-i8-parallel">plp_mat_sub_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t nPE, int8_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix subtraction of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-i8p-xpulpv2">plp_mat_sub_i8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix subtraction of 8-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSub/#function-plp-mat-sub-f32">plp_mat_sub_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, float *<strong>restrict</strong> pDst)<br>Glue code for matrix subtraction of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-f32s-xpulpv2">plp_mat_sub_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, float *<strong>restrict</strong> pDst)<br>matrix subtraction of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSub/#function-plp-mat-sub-f32-parallel">plp_mat_sub_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t nPE, float *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix subtraction of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubKernels/#function-plp-mat-sub-f32p-xpulpv2">plp_mat_sub_f32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix subtraction of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScale/#function-plp-mat-scale-i32">plp_mat_scale_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int32_t scaleFactor, int32_t shift, int32_t </em><strong>restrict</strong> pDst)<br>Glue code for matrix scale of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-i32s-rv32im">plp_mat_scale_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int32_t scaleFactor, int32_t shift, int32_t </em><strong>restrict</strong> pDst)<br>matrix scale of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-i32s-xpulpv2">plp_mat_scale_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int32_t scaleFactor, int32_t shift, int32_t </em><strong>restrict</strong> pDst)<br>matrix scale of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScale/#function-plp-mat-scale-i32-parallel">plp_mat_scale_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int32_t scaleFactor, int32_t shift, uint32_t nPE, int32_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel matrix scale of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-i32p-xpulpv2">plp_mat_scale_i32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix scale of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScale/#function-plp-mat-scale-i16">plp_mat_scale_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int16_t scaleFactor, int32_t shift, int16_t </em><strong>restrict</strong> pDst)<br>Glue code for matrix scale of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-i16s-rv32im">plp_mat_scale_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int16_t scaleFactor, int32_t shift, int16_t </em><strong>restrict</strong> pDst)<br>matrix scale of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-i16s-xpulpv2">plp_mat_scale_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int16_t scaleFactor, int32_t shift, int16_t </em><strong>restrict</strong> pDst)<br>matrix scale of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScale/#function-plp-mat-scale-i16-parallel">plp_mat_scale_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int16_t scaleFactor, int32_t shift, uint32_t nPE, int16_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel matrix scale of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-i16p-xpulpv2">plp_mat_scale_i16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix scale of 16-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScale/#function-plp-mat-scale-i8">plp_mat_scale_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int8_t scaleFactor, int32_t shift, int8_t </em><strong>restrict</strong> pDst)<br>Glue code for matrix scale of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-i8s-rv32im">plp_mat_scale_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int8_t scaleFactor, int32_t shift, int8_t </em><strong>restrict</strong> pDst)<br>matrix scale of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-i8s-xpulpv2">plp_mat_scale_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int8_t scaleFactor, int32_t shift, int8_t </em><strong>restrict</strong> pDst)<br>matrix scale of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScale/#function-plp-mat-scale-i8-parallel">plp_mat_scale_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int8_t scaleFactor, int32_t shift, uint32_t nPE, int8_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel matrix scale of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-i8p-xpulpv2">plp_mat_scale_i8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix scale of 8-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScale/#function-plp-mat-scale-f32">plp_mat_scale_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, float scaleFactor, float </em><strong>restrict</strong> pDst)<br>Glue code for matrix scale of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-f32s-xpulpv2">plp_mat_scale_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, float scaleFactor, float </em><strong>restrict</strong> pDst)<br>matrix scale of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScale/#function-plp-mat-scale-f32-parallel">plp_mat_scale_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, float scaleFactor, uint32_t nPE, float </em><strong>restrict</strong> pDst)<br>Glue code for parallel matrix scale of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleKernels/#function-plp-mat-scale-f32p-xpulpv2">plp_mat_scale_f32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix scale of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTrans/#function-plp-mat-trans-i32">plp_mat_trans_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int32_t </em><strong>restrict</strong> pDst)<br>Glue code for matrix transpose of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTransKernels/#function-plp-mat-trans-i32s-rv32im">plp_mat_trans_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int32_t </em><strong>restrict</strong> pDst)<br>matrix transpose of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTransKernels/#function-plp-mat-trans-i32s-xpulpv2">plp_mat_trans_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int32_t </em><strong>restrict</strong> pDst)<br>matrix transpose of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTrans/#function-plp-mat-trans-i32-parallel">plp_mat_trans_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t nPE, int32_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel matrix transpose of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTransKernels/#function-plp-mat-trans-i32p-xpulpv2">plp_mat_trans_i32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transpose of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTrans/#function-plp-mat-trans-i16">plp_mat_trans_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int16_t </em><strong>restrict</strong> pDst)<br>Glue code for matrix transpose of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTransKernels/#function-plp-mat-trans-i16s-rv32im">plp_mat_trans_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int16_t </em><strong>restrict</strong> pDst)<br>matrix transpose of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTransKernels/#function-plp-mat-trans-i16s-xpulpv2">plp_mat_trans_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int16_t </em><strong>restrict</strong> pDst)<br>matrix transpose of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTrans/#function-plp-mat-trans-i16-parallel">plp_mat_trans_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t nPE, int16_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel matrix transpose of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTransKernels/#function-plp-mat-trans-i16p-xpulpv2">plp_mat_trans_i16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transpose of 16-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTrans/#function-plp-mat-trans-i8">plp_mat_trans_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int8_t </em><strong>restrict</strong> pDst)<br>Glue code for matrix transpose of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTransKernels/#function-plp-mat-trans-i8s-rv32im">plp_mat_trans_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int8_t </em><strong>restrict</strong> pDst)<br>matrix transpose of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTransKernels/#function-plp-mat-trans-i8s-xpulpv2">plp_mat_trans_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, int8_t </em><strong>restrict</strong> pDst)<br>matrix transpose of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTrans/#function-plp-mat-trans-i8-parallel">plp_mat_trans_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t nPE, int8_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel matrix transpose of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTransKernels/#function-plp-mat-trans-i8p-xpulpv2">plp_mat_trans_i8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix transpose of 8-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTrans/#function-plp-mat-trans-f32">plp_mat_trans_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, float </em><strong>restrict</strong> pDst)<br>Glue code for matrix transpose of a 32-bit float*ing-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatTrans/#function-plp-mat-trans-f32-parallel">plp_mat_trans_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t nPE, float </em><strong>restrict</strong> pDst)<br>Glue code for parallel matrix transpose of a 32-bit float*ing-point matrices.</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatInv/#function-plp-mat-inv-f32">plp_mat_inv_f32</a></strong>(float <em><strong>restrict</strong> pSrc, float </em><strong>restrict</strong> pDst, uint32_t N)<br>Glue code for matrix inverse of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatInvKernels/#function-plp-mat-inv-f32s-xpulpv2">plp_mat_inv_f32s_xpulpv2</a></strong>(float <em><strong>restrict</strong> pSrc, float </em><strong>restrict</strong> pDst, uint32_t N)<br>matrix inverse of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatInv/#function-plp-mat-inv-f32-parallel">plp_mat_inv_f32_parallel</a></strong>(float <em><strong>restrict</strong> pSrc, float </em><strong>restrict</strong> pDst, uint32_t N, uint32_t nPE)<br>Glue code for parallel matrix inverse of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>int</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatInvKernels/#function-plp-mat-inv-f32p-xpulpv2">plp_mat_inv_f32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix inverse of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-i32">plp_mat_fill_I_i32</a></strong>(uint32_t N, int32_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 32-bit integer identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-i32s-rv32im">plp_mat_fill_I_i32s_rv32im</a></strong>(uint32_t N, int32_t *<strong>restrict</strong> pDst)<br>Create a 32-bit integer identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-i32s-xpulpv2">plp_mat_fill_I_i32s_xpulpv2</a></strong>(uint32_t N, int32_t *<strong>restrict</strong> pDst)<br>Create a 32-bit integer identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-i32-parallel">plp_mat_fill_I_i32_parallel</a></strong>(uint32_t N, uint32_t nPE, int32_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 32-bit integer identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-i32p-xpulpv2">plp_mat_fill_I_i32p_xpulpv2</a></strong>(void * args)<br>Create a 32-bit integer identity matrix in parallel on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-i16">plp_mat_fill_I_i16</a></strong>(uint32_t N, int16_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 16-bit integer identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-i16s-rv32im">plp_mat_fill_I_i16s_rv32im</a></strong>(uint32_t N, int16_t *<strong>restrict</strong> pDst)<br>Create a 16-bit integer identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-i16s-xpulpv2">plp_mat_fill_I_i16s_xpulpv2</a></strong>(uint32_t N, int16_t *<strong>restrict</strong> pDst)<br>Create a 16-bit integer identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-i16-parallel">plp_mat_fill_I_i16_parallel</a></strong>(uint32_t N, uint32_t nPE, int16_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 16-bit integer identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-i16p-xpulpv2">plp_mat_fill_I_i16p_xpulpv2</a></strong>(void * args)<br>Create a 16-bit integer identity matrix in parallel on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-i8">plp_mat_fill_I_i8</a></strong>(uint32_t N, int8_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 8-bit integer identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-i8s-rv32im">plp_mat_fill_I_i8s_rv32im</a></strong>(uint32_t N, int8_t *<strong>restrict</strong> pDst)<br>Create a 8-bit integer identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-i8s-xpulpv2">plp_mat_fill_I_i8s_xpulpv2</a></strong>(uint32_t N, int8_t *<strong>restrict</strong> pDst)<br>Create a 8-bit integer identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-i8-parallel">plp_mat_fill_I_i8_parallel</a></strong>(uint32_t N, uint32_t nPE, int8_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 8-bit integer identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-i8p-xpulpv2">plp_mat_fill_I_i8p_xpulpv2</a></strong>(void * args)<br>Create a 8-bit integer identity matrix in parallel on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-f32">plp_mat_fill_I_f32</a></strong>(uint32_t N, float *<strong>restrict</strong> pDst)<br>Glue code for creating a 32-bit float identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-f32s-xpulpv2">plp_mat_fill_I_f32s_xpulpv2</a></strong>(uint32_t N, float *<strong>restrict</strong> pDst)<br>Create a 32-bit float identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-f32-parallel">plp_mat_fill_I_f32_parallel</a></strong>(uint32_t N, uint32_t nPE, float *<strong>restrict</strong> pDst)<br>Glue code for creating a 32-bit float identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-f32p-xpulpv2">plp_mat_fill_I_f32p_xpulpv2</a></strong>(void * args)<br>Create a 32-bit float identity matrix in parallel on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-q32">plp_mat_fill_I_q32</a></strong>(uint32_t N, int32_t fracBits, int32_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 32-bit fix-point identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-q32s-rv32im">plp_mat_fill_I_q32s_rv32im</a></strong>(uint32_t N, int32_t fracBits, int32_t *<strong>restrict</strong> pDst)<br>Create a 32-bit fix-point identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-q32s-xpulpv2">plp_mat_fill_I_q32s_xpulpv2</a></strong>(uint32_t N, int32_t fracBits, int32_t *<strong>restrict</strong> pDst)<br>Create a 32-bit fix-point identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-q32-parallel">plp_mat_fill_I_q32_parallel</a></strong>(uint32_t N, int32_t fracBits, uint32_t nPE, int32_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 32-bit fix-point identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-q32p-xpulpv2">plp_mat_fill_I_q32p_xpulpv2</a></strong>(void * args)<br>Create a 32-bit fix-point identity matrix in parallel on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-q16">plp_mat_fill_I_q16</a></strong>(uint32_t N, int32_t fracBits, int16_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 16-bit fix-point identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-q16s-rv32im">plp_mat_fill_I_q16s_rv32im</a></strong>(uint32_t N, int32_t fracBits, int16_t *<strong>restrict</strong> pDst)<br>Create a 16-bit fix-point identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-q16s-xpulpv2">plp_mat_fill_I_q16s_xpulpv2</a></strong>(uint32_t N, int32_t fracBits, int16_t *<strong>restrict</strong> pDst)<br>Create a 16-bit fix-point identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-q16-parallel">plp_mat_fill_I_q16_parallel</a></strong>(uint32_t N, int32_t fracBits, uint32_t nPE, int16_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 16-bit fix-point identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-q16p-xpulpv2">plp_mat_fill_I_q16p_xpulpv2</a></strong>(void * args)<br>Create a 16-bit fix-point identity matrix in parallel on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-q8">plp_mat_fill_I_q8</a></strong>(uint32_t N, int32_t fracBits, int8_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 8-bit fix-point identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-q8s-rv32im">plp_mat_fill_I_q8s_rv32im</a></strong>(uint32_t N, int32_t fracBits, int8_t *<strong>restrict</strong> pDst)<br>Create a 8-bit fix-point identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-q8s-xpulpv2">plp_mat_fill_I_q8s_xpulpv2</a></strong>(uint32_t N, int32_t fracBits, int8_t *<strong>restrict</strong> pDst)<br>Create a 8-bit fix-point identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillI/#function-plp-mat-fill-i-q8-parallel">plp_mat_fill_I_q8_parallel</a></strong>(uint32_t N, int32_t fracBits, uint32_t nPE, int8_t *<strong>restrict</strong> pDst)<br>Glue code for creating a 8-bit fix-point identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIKernels/#function-plp-mat-fill-i-q8p-xpulpv2">plp_mat_fill_I_q8p_xpulpv2</a></strong>(void * args)<br>Create a 8-bit fix-point identity matrix in parallel on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-i32">plp_mat_mult_stride_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix matrix multiplication of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-i32s-rv32im">plp_mat_mult_stride_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-i32s-xpulpv2">plp_mat_mult_stride_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-i16">plp_mat_mult_stride_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix matrix multiplication of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-i16s-rv32im">plp_mat_mult_stride_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-i16s-xpulpv2">plp_mat_mult_stride_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-i8">plp_mat_mult_stride_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix matrix multiplication of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-i8s-rv32im">plp_mat_mult_stride_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-i8s-xpulpv2">plp_mat_mult_stride_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-i32-parallel">plp_mat_mult_stride_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix matrix multiplication of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-i32p-xpulpv2">plp_mat_mult_stride_i32p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-i16-parallel">plp_mat_mult_stride_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix matrix multiplication of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-i16p-xpulpv2">plp_mat_mult_stride_i16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 16-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-i8-parallel">plp_mat_mult_stride_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix matrix multiplication of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-f32">plp_mat_mult_stride_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, float *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix matrix multiplication of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-f32s-xpulpv2">plp_mat_mult_stride_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, float *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-f32-parallel">plp_mat_mult_stride_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, float *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix matrix multiplication of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-f32p-xpulpv2">plp_mat_mult_stride_f32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-i8p-xpulpv2">plp_mat_mult_stride_i8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 8-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-q32">plp_mat_mult_stride_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix matrix multiplication of a 32-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-q32-parallel">plp_mat_mult_stride_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix matrix multiplication of a 32-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-q32s-rv32im">plp_mat_mult_stride_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 32-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-q32s-xpulpv2">plp_mat_mult_stride_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-q32p-xpulpv2">plp_mat_mult_stride_q32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-q16">plp_mat_mult_stride_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix matrix multiplication of a 16-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-q16-parallel">plp_mat_mult_stride_q16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int16_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix matrix multiplication of a 16-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-q16s-rv32im">plp_mat_mult_stride_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 16-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-q16s-xpulpv2">plp_mat_mult_stride_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-q16p-xpulpv2">plp_mat_mult_stride_q16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-q8">plp_mat_mult_stride_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix matrix multiplication of a 8-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStride/#function-plp-mat-mult-stride-q8-parallel">plp_mat_mult_stride_q8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int8_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix matrix multiplication of a 8-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-q8s-rv32im">plp_mat_mult_stride_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 8-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-q8s-xpulpv2">plp_mat_mult_stride_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>strided matrix matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__BasicMatMultStrideKernels/#function-plp-mat-mult-stride-q8p-xpulpv2">plp_mat_mult_stride_q8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-i32">plp_mat_mult_trans_stride_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix transposed matrix multiplication of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-i32s-rv32im">plp_mat_mult_trans_stride_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-i32s-xpulpv2">plp_mat_mult_trans_stride_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-i16">plp_mat_mult_trans_stride_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix transposed matrix multiplication of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-i16s-rv32im">plp_mat_mult_trans_stride_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-i16s-xpulpv2">plp_mat_mult_trans_stride_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-i8">plp_mat_mult_trans_stride_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix transposed matrix multiplication of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-i8s-rv32im">plp_mat_mult_trans_stride_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-i8s-xpulpv2">plp_mat_mult_trans_stride_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-i32-parallel">plp_mat_mult_trans_stride_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix matrix multiplication of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-i32p-xpulpv2">plp_mat_mult_trans_stride_i32p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-i16-parallel">plp_mat_mult_trans_stride_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix transposed matrix multiplication of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-i16p-xpulpv2">plp_mat_mult_trans_stride_i16p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-i8-parallel">plp_mat_mult_trans_stride_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix transposed matrix multiplication of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-i8p-xpulpv2">plp_mat_mult_trans_stride_i8p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-q32">plp_mat_mult_trans_stride_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix transposed matrix multiplication of a 32-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-q32-parallel">plp_mat_mult_trans_stride_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix transposed matrix multiplication of a 32-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-q32s-rv32im">plp_mat_mult_trans_stride_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 32-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-q32s-xpulpv2">plp_mat_mult_trans_stride_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-q32p-xpulpv2">plp_mat_mult_trans_stride_q32p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix transposed matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-q16">plp_mat_mult_trans_stride_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix transposed matrix multiplication of a 16-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-q16-parallel">plp_mat_mult_trans_stride_q16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int16_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix transposed matrix multiplication of a 16-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-q16s-rv32im">plp_mat_mult_trans_stride_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 16-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-q16s-xpulpv2">plp_mat_mult_trans_stride_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-q16p-xpulpv2">plp_mat_mult_trans_stride_q16p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix transposed matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-q8">plp_mat_mult_trans_stride_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix transposed matrix multiplication of a 8-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-q8-parallel">plp_mat_mult_trans_stride_q8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int8_t *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix transposed matrix multiplication of a 8-bit fix-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-q8s-rv32im">plp_mat_mult_trans_stride_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 8-bit fix-point matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-q8s-xpulpv2">plp_mat_mult_trans_stride_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-q8p-xpulpv2">plp_mat_mult_trans_stride_q8p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix transposed matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-f32">plp_mat_mult_trans_stride_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, float *<strong>restrict</strong> pDstC)<br>Glue code for strided matrix transposed matrix multiplication of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-f32s-xpulpv2">plp_mat_mult_trans_stride_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, float *<strong>restrict</strong> pDstC)<br>strided matrix transposed matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStride/#function-plp-mat-mult-trans-stride-f32-parallel">plp_mat_mult_trans_stride_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, float *<strong>restrict</strong> pDstC)<br>Glue code for parallel strided matrix transposed matrix multiplication of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransStrideKernels/#function-plp-mat-mult-trans-stride-f32p-xpulpv2">plp_mat_mult_trans_stride_f32p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix transposed matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-i32">plp_mat_mult_cmplx_stride_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix matrix multiplication for complex 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-i32s-rv32im">plp_mat_mult_cmplx_stride_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 32-bit integers on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-i32s-xpulpv2">plp_mat_mult_cmplx_stride_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 32-bit integers on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-i32-parallel">plp_mat_mult_cmplx_stride_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix matrix multiplication for complex 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-i32p-xpulpv2">plp_mat_mult_cmplx_stride_i32p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix matrix multiplication for complex 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-i16">plp_mat_mult_cmplx_stride_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix matrix multiplication for complex 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-i16s-rv32im">plp_mat_mult_cmplx_stride_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 16-bit integers on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-i16s-xpulpv2">plp_mat_mult_cmplx_stride_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 16-bit integers on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-i16-parallel">plp_mat_mult_cmplx_stride_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix matrix multiplication for complex 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-i16p-xpulpv2">plp_mat_mult_cmplx_stride_i16p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix matrix multiplication for complex 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-i8">plp_mat_mult_cmplx_stride_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix matrix multiplication for complex 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-i8s-rv32im">plp_mat_mult_cmplx_stride_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 8-bit integers on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-i8s-xpulpv2">plp_mat_mult_cmplx_stride_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 8-bit integers on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-i8-parallel">plp_mat_mult_cmplx_stride_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix matrix multiplication for complex 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-i8p-xpulpv2">plp_mat_mult_cmplx_stride_i8p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix matrix multiplication for complex 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-f32">plp_mat_mult_cmplx_stride_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, float *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix matrix multiplication for complex 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-f32s-xpulpv2">plp_mat_mult_cmplx_stride_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, float *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 32-bit floats on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-f32-parallel">plp_mat_mult_cmplx_stride_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, float *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix matrix multiplication for complex 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-f32p-xpulpv2">plp_mat_mult_cmplx_stride_f32p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix matrix multiplication for complex 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-q32">plp_mat_mult_cmplx_stride_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix matrix multiplication for complex 32-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-q32s-rv32im">plp_mat_mult_cmplx_stride_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 32-bit fix-point on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-q32s-xpulpv2">plp_mat_mult_cmplx_stride_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 32-bit fix-point on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-q32-parallel">plp_mat_mult_cmplx_stride_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix matrix multiplication for complex 32-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-q32p-xpulpv2">plp_mat_mult_cmplx_stride_q32p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix matrix multiplication for complex 32-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-q16">plp_mat_mult_cmplx_stride_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix matrix multiplication for complex 16-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-q16s-rv32im">plp_mat_mult_cmplx_stride_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 16-bit fix-point on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-q16s-xpulpv2">plp_mat_mult_cmplx_stride_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 16-bit fix-point on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-q16-parallel">plp_mat_mult_cmplx_stride_q16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int16_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix matrix multiplication for complex 16-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-q16p-xpulpv2">plp_mat_mult_cmplx_stride_q16p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix matrix multiplication for complex 16-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-q8">plp_mat_mult_cmplx_stride_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix matrix multiplication for complex 8-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-q8s-rv32im">plp_mat_mult_cmplx_stride_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 8-bit fix-point on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-q8s-xpulpv2">plp_mat_mult_cmplx_stride_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Strided strided matrix matrix multiplication for complex 8-bit fix-point on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStride/#function-plp-mat-mult-cmplx-stride-q8-parallel">plp_mat_mult_cmplx_stride_q8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int8_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix matrix multiplication for complex 8-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultCmplxStrideKernels/#function-plp-mat-mult-cmplx-stride-q8p-xpulpv2">plp_mat_mult_cmplx_stride_q8p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix matrix multiplication for complex 8-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-i32">plp_mat_mult_trans_cmplx_stride_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix transpose matrix multiplication for complex 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-i32s-rv32im">plp_mat_mult_trans_cmplx_stride_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 32-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-i32s-xpulpv2">plp_mat_mult_trans_cmplx_stride_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-i32-parallel">plp_mat_mult_trans_cmplx_stride_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix transpose matrix multiplication for complex 32-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-i32p-xpulpv2">plp_mat_mult_trans_cmplx_stride_i32p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-i16">plp_mat_mult_trans_cmplx_stride_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix transpose matrix multiplication for complex 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-i16s-rv32im">plp_mat_mult_trans_cmplx_stride_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 16-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-i16s-xpulpv2">plp_mat_mult_trans_cmplx_stride_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-i16-parallel">plp_mat_mult_trans_cmplx_stride_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix transpose matrix multiplication for complex 16-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-i16p-xpulpv2">plp_mat_mult_trans_cmplx_stride_i16p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-i8">plp_mat_mult_trans_cmplx_stride_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix transpose matrix multiplication for complex 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-i8s-rv32im">plp_mat_mult_trans_cmplx_stride_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 8-bit integers on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-i8s-xpulpv2">plp_mat_mult_trans_cmplx_stride_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-i8-parallel">plp_mat_mult_trans_cmplx_stride_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix transpose matrix multiplication for complex 8-bit integers.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-i8p-xpulpv2">plp_mat_mult_trans_cmplx_stride_i8p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-f32">plp_mat_mult_trans_cmplx_stride_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, float *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix transpose matrix multiplication for complex 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-f32s-xpulpv2">plp_mat_mult_trans_cmplx_stride_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, float *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-f32-parallel">plp_mat_mult_trans_cmplx_stride_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t nPE, float *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix transpose matrix multiplication for complex 32-bit floats.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-f32p-xpulpv2">plp_mat_mult_trans_cmplx_stride_f32p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-q32">plp_mat_mult_trans_cmplx_stride_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix transpose matrix multiplication for complex 32-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-q32s-rv32im">plp_mat_mult_trans_cmplx_stride_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 32-bit fix-point on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-q32s-xpulpv2">plp_mat_mult_trans_cmplx_stride_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int32_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-q32-parallel">plp_mat_mult_trans_cmplx_stride_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int32_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix transpose matrix multiplication for complex 32-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-q32p-xpulpv2">plp_mat_mult_trans_cmplx_stride_q32p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-q16">plp_mat_mult_trans_cmplx_stride_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix transpose matrix multiplication for complex 16-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-q16s-rv32im">plp_mat_mult_trans_cmplx_stride_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 16-bit fix-point on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-q16s-xpulpv2">plp_mat_mult_trans_cmplx_stride_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int16_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-q16-parallel">plp_mat_mult_trans_cmplx_stride_q16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int16_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix transpose matrix multiplication for complex 16-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-q16p-xpulpv2">plp_mat_mult_trans_cmplx_stride_q16p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-q8">plp_mat_mult_trans_cmplx_stride_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>Glue code of strided matrix transpose matrix multiplication for complex 8-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-q8s-rv32im">plp_mat_mult_trans_cmplx_stride_q8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 8-bit fix-point on RV32IM</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-q8s-xpulpv2">plp_mat_mult_trans_cmplx_stride_q8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, int8_t *<strong>restrict</strong> pDstC)<br>strided matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStride/#function-plp-mat-mult-trans-cmplx-stride-q8-parallel">plp_mat_mult_trans_cmplx_stride_q8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t O, uint32_t strideA, uint32_t strideB, uint32_t strideC, uint32_t shift, uint32_t nPE, int8_t *<strong>restrict</strong> pDstC)<br>Glue code of parallel strided matrix transpose matrix multiplication for complex 8-bit fix-point.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatMultTransCmplxStrideKernels/#function-plp-mat-mult-trans-cmplx-stride-q8p-xpulpv2">plp_mat_mult_trans_cmplx_stride_q8p_xpulpv2</a></strong>(void * args)<br>parallel strided matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStride/#function-plp-mat-add-stride-i32">plp_mat_add_stride_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int32_t *<strong>restrict</strong> pDst)<br>Glue code for matrix addition of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-i32s-rv32im">plp_mat_add_stride_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int32_t *<strong>restrict</strong> pDst)<br>matrix addition of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-i32s-xpulpv2">plp_mat_add_stride_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int32_t *<strong>restrict</strong> pDst)<br>matrix addition of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStride/#function-plp-mat-add-stride-i32-parallel">plp_mat_add_stride_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, uint32_t nPE, int32_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix addition of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-i32p-xpulpv2">plp_mat_add_stride_i32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix addition of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStride/#function-plp-mat-add-stride-i16">plp_mat_add_stride_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int16_t *<strong>restrict</strong> pDst)<br>Glue code for matrix addition of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-i16s-rv32im">plp_mat_add_stride_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int16_t *<strong>restrict</strong> pDst)<br>matrix addition of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-i16s-xpulpv2">plp_mat_add_stride_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int16_t *<strong>restrict</strong> pDst)<br>matrix addition of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStride/#function-plp-mat-add-stride-i16-parallel">plp_mat_add_stride_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, uint32_t nPE, int16_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix addition of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-i16p-xpulpv2">plp_mat_add_stride_i16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix addition of 16-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStride/#function-plp-mat-add-stride-i8">plp_mat_add_stride_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int8_t *<strong>restrict</strong> pDst)<br>Glue code for matrix addition of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-i8s-rv32im">plp_mat_add_stride_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int8_t *<strong>restrict</strong> pDst)<br>matrix addition of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-i8s-xpulpv2">plp_mat_add_stride_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int8_t *<strong>restrict</strong> pDst)<br>matrix addition of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStride/#function-plp-mat-add-stride-i8-parallel">plp_mat_add_stride_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, uint32_t nPE, int8_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix addition of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-i8p-xpulpv2">plp_mat_add_stride_i8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix addition of 8-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStride/#function-plp-mat-add-stride-f32">plp_mat_add_stride_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, float *<strong>restrict</strong> pDst)<br>Glue code for matrix addition of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-f32s-xpulpv2">plp_mat_add_stride_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, float *<strong>restrict</strong> pDst)<br>matrix addition of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStride/#function-plp-mat-add-stride-f32-parallel">plp_mat_add_stride_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, uint32_t nPE, float *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix addition of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatAddStrideKernels/#function-plp-mat-add-stride-f32p-xpulpv2">plp_mat_add_stride_f32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix addition of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStride/#function-plp-mat-sub-stride-i32">plp_mat_sub_stride_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int32_t *<strong>restrict</strong> pDst)<br>Glue code for matrix subtraction of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-i32s-rv32im">plp_mat_sub_stride_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int32_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-i32s-xpulpv2">plp_mat_sub_stride_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int32_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStride/#function-plp-mat-sub-stride-i32-parallel">plp_mat_sub_stride_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, uint32_t nPE, int32_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix subtraction of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-i32p-xpulpv2">plp_mat_sub_stride_i32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix subtraction of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStride/#function-plp-mat-sub-stride-i16">plp_mat_sub_stride_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int16_t *<strong>restrict</strong> pDst)<br>Glue code for matrix subtraction of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-i16s-rv32im">plp_mat_sub_stride_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int16_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-i16s-xpulpv2">plp_mat_sub_stride_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int16_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStride/#function-plp-mat-sub-stride-i16-parallel">plp_mat_sub_stride_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, uint32_t nPE, int16_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix subtraction of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-i16p-xpulpv2">plp_mat_sub_stride_i16p_xpulpv2</a></strong>(void * args)<br>Parallel matrix subtraction of 16-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStride/#function-plp-mat-sub-stride-i8">plp_mat_sub_stride_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int8_t *<strong>restrict</strong> pDst)<br>Glue code for matrix subtraction of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-i8s-rv32im">plp_mat_sub_stride_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int8_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-i8s-xpulpv2">plp_mat_sub_stride_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, int8_t *<strong>restrict</strong> pDst)<br>matrix subtraction of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStride/#function-plp-mat-sub-stride-i8-parallel">plp_mat_sub_stride_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, uint32_t nPE, int8_t *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix subtraction of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-i8p-xpulpv2">plp_mat_sub_stride_i8p_xpulpv2</a></strong>(void * args)<br>Parallel matrix subtraction of 8-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStride/#function-plp-mat-sub-stride-f32">plp_mat_sub_stride_f32</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, float *<strong>restrict</strong> pDst)<br>Glue code for matrix subtraction of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-f32s-xpulpv2">plp_mat_sub_stride_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, float *<strong>restrict</strong> pDst)<br>matrix subtraction of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStride/#function-plp-mat-sub-stride-f32-parallel">plp_mat_sub_stride_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrcA, const float </em><strong>restrict</strong> pSrcB, uint32_t M, uint32_t N, uint32_t strideA, uint32_t strideB, uint32_t strideY, uint32_t nPE, float *<strong>restrict</strong> pDst)<br>Glue code for parallel matrix subtraction of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatSubStrideKernels/#function-plp-mat-sub-stride-f32p-xpulpv2">plp_mat_sub_stride_f32p_xpulpv2</a></strong>(void * args)<br>Parallel matrix subtraction of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStride/#function-plp-mat-scale-stride-i32">plp_mat_scale_stride_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int32_t scaleFactor, int32_t shift, int32_t </em><strong>restrict</strong> pDst)<br>Glue code for strided matrix scale of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-i32s-rv32im">plp_mat_scale_stride_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int32_t scaleFactor, int32_t shift, int32_t </em><strong>restrict</strong> pDst)<br>strided matrix scale of a 32-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-i32s-xpulpv2">plp_mat_scale_stride_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int32_t scaleFactor, int32_t shift, int32_t </em><strong>restrict</strong> pDst)<br>strided matrix scale of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStride/#function-plp-mat-scale-stride-i32-parallel">plp_mat_scale_stride_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int32_t scaleFactor, int32_t shift, uint32_t nPE, int32_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel strided matrix scale of a 32-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-i32p-xpulpv2">plp_mat_scale_stride_i32p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix scale of a 32-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStride/#function-plp-mat-scale-stride-i16">plp_mat_scale_stride_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int16_t scaleFactor, int32_t shift, int16_t </em><strong>restrict</strong> pDst)<br>Glue code for strided matrix scale of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-i16s-rv32im">plp_mat_scale_stride_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int16_t scaleFactor, int32_t shift, int16_t </em><strong>restrict</strong> pDst)<br>strided matrix scale of a 16-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-i16s-xpulpv2">plp_mat_scale_stride_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int16_t scaleFactor, int32_t shift, int16_t </em><strong>restrict</strong> pDst)<br>strided matrix scale of a 16-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStride/#function-plp-mat-scale-stride-i16-parallel">plp_mat_scale_stride_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int16_t scaleFactor, int32_t shift, uint32_t nPE, int16_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel strided matrix scale of a 16-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-i16p-xpulpv2">plp_mat_scale_stride_i16p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix scale of 16-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStride/#function-plp-mat-scale-stride-i8">plp_mat_scale_stride_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int8_t scaleFactor, int32_t shift, int8_t </em><strong>restrict</strong> pDst)<br>Glue code for strided matrix scale of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-i8s-rv32im">plp_mat_scale_stride_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int8_t scaleFactor, int32_t shift, int8_t </em><strong>restrict</strong> pDst)<br>strided matrix scale of a 8-bit integer matrices for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-i8s-xpulpv2">plp_mat_scale_stride_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int8_t scaleFactor, int32_t shift, int8_t </em><strong>restrict</strong> pDst)<br>strided matrix scale of a 8-bit integer matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStride/#function-plp-mat-scale-stride-i8-parallel">plp_mat_scale_stride_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int8_t scaleFactor, int32_t shift, uint32_t nPE, int8_t </em><strong>restrict</strong> pDst)<br>Glue code for parallel strided matrix scale of a 8-bit integer matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-i8p-xpulpv2">plp_mat_scale_stride_i8p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix scale of 8-bit integer matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStride/#function-plp-mat-scale-stride-f32">plp_mat_scale_stride_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, float scaleFactor, float </em><strong>restrict</strong> pDst)<br>Glue code for strided matrix scale of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-f32s-xpulpv2">plp_mat_scale_stride_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, float scaleFactor, float </em><strong>restrict</strong> pDst)<br>strided matrix scale of a 32-bit floating-point matrices for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStride/#function-plp-mat-scale-stride-f32-parallel">plp_mat_scale_stride_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, float scaleFactor, uint32_t nPE, float </em><strong>restrict</strong> pDst)<br>Glue code for parallel strided matrix scale of a 32-bit floating-point matrices.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatScaleStrideKernels/#function-plp-mat-scale-stride-f32p-xpulpv2">plp_mat_scale_stride_f32p_xpulpv2</a></strong>(void * args)<br>Parallel strided matrix scale of 32-bit floating-point matrices kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-i32">plp_mat_fill_I_stride_i32</a></strong>(uint32_t N, uint32_t stride, int32_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 32-bit integers identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-i32s-rv32im">plp_mat_fill_I_stride_i32s_rv32im</a></strong>(uint32_t N, uint32_t stride, int32_t *<strong>restrict</strong> pDst)<br>Create a strided 32-bit integers identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-i32s-xpulpv2">plp_mat_fill_I_stride_i32s_xpulpv2</a></strong>(uint32_t N, uint32_t stride, int32_t *<strong>restrict</strong> pDst)<br>Create a strided 32-bit integers identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-i32-parallel">plp_mat_fill_I_stride_i32_parallel</a></strong>(uint32_t N, uint32_t stride, uint32_t nPE, int32_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 32-bit integers identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-i32p-xpulpv2">plp_mat_fill_I_stride_i32p_xpulpv2</a></strong>(void * args)<br>Create a strided 32-bit integers identity matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-i16">plp_mat_fill_I_stride_i16</a></strong>(uint32_t N, uint32_t stride, int16_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 16-bit integers identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-i16s-rv32im">plp_mat_fill_I_stride_i16s_rv32im</a></strong>(uint32_t N, uint32_t stride, int16_t *<strong>restrict</strong> pDst)<br>Create a strided 16-bit integers identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-i16s-xpulpv2">plp_mat_fill_I_stride_i16s_xpulpv2</a></strong>(uint32_t N, uint32_t stride, int16_t *<strong>restrict</strong> pDst)<br>Create a strided 16-bit integers identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-i16-parallel">plp_mat_fill_I_stride_i16_parallel</a></strong>(uint32_t N, uint32_t stride, uint32_t nPE, int16_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 16-bit integers identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-i16p-xpulpv2">plp_mat_fill_I_stride_i16p_xpulpv2</a></strong>(void * args)<br>Create a strided 16-bit integers identity matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-i8">plp_mat_fill_I_stride_i8</a></strong>(uint32_t N, uint32_t stride, int8_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 8-bit integers identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-i8s-rv32im">plp_mat_fill_I_stride_i8s_rv32im</a></strong>(uint32_t N, uint32_t stride, int8_t *<strong>restrict</strong> pDst)<br>Create a strided 8-bit integers identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-i8s-xpulpv2">plp_mat_fill_I_stride_i8s_xpulpv2</a></strong>(uint32_t N, uint32_t stride, int8_t *<strong>restrict</strong> pDst)<br>Create a strided 8-bit integers identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-i8-parallel">plp_mat_fill_I_stride_i8_parallel</a></strong>(uint32_t N, uint32_t stride, uint32_t nPE, int8_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 8-bit integers identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-i8p-xpulpv2">plp_mat_fill_I_stride_i8p_xpulpv2</a></strong>(void * args)<br>Create a strided 8-bit integers identity matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-f32">plp_mat_fill_I_stride_f32</a></strong>(uint32_t N, uint32_t stride, float *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 32-bit floats identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-f32s-xpulpv2">plp_mat_fill_I_stride_f32s_xpulpv2</a></strong>(uint32_t N, uint32_t stride, float *<strong>restrict</strong> pDst)<br>Create a strided 32-bit floats identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-f32-parallel">plp_mat_fill_I_stride_f32_parallel</a></strong>(uint32_t N, uint32_t stride, uint32_t nPE, float *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 32-bit floats identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-f32p-xpulpv2">plp_mat_fill_I_stride_f32p_xpulpv2</a></strong>(void * args)<br>Create a strided 32-bit floats identity matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-q32">plp_mat_fill_I_stride_q32</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, int32_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 32-bit fix-point identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-q32s-rv32im">plp_mat_fill_I_stride_q32s_rv32im</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, int32_t *<strong>restrict</strong> pDst)<br>Create a strided 32-bit fix-point identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-q32s-xpulpv2">plp_mat_fill_I_stride_q32s_xpulpv2</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, int32_t *<strong>restrict</strong> pDst)<br>Create a strided 32-bit fix-point identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-q32-parallel">plp_mat_fill_I_stride_q32_parallel</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, uint32_t nPE, int32_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 32-bit fix-point identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-q32p-xpulpv2">plp_mat_fill_I_stride_q32p_xpulpv2</a></strong>(void * args)<br>Create a strided 32-bit fix-point identity matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-q16">plp_mat_fill_I_stride_q16</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, int16_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 16-bit fix-point identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-q16s-rv32im">plp_mat_fill_I_stride_q16s_rv32im</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, int16_t *<strong>restrict</strong> pDst)<br>Create a strided 16-bit fix-point identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-q16s-xpulpv2">plp_mat_fill_I_stride_q16s_xpulpv2</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, int16_t *<strong>restrict</strong> pDst)<br>Create a strided 16-bit fix-point identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-q16-parallel">plp_mat_fill_I_stride_q16_parallel</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, uint32_t nPE, int16_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 16-bit fix-point identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-q16p-xpulpv2">plp_mat_fill_I_stride_q16p_xpulpv2</a></strong>(void * args)<br>Create a strided 16-bit fix-point identity matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-q8">plp_mat_fill_I_stride_q8</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, int8_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 8-bit fix-point identity matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-q8s-rv32im">plp_mat_fill_I_stride_q8s_rv32im</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, int8_t *<strong>restrict</strong> pDst)<br>Create a strided 8-bit fix-point identity matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-q8s-xpulpv2">plp_mat_fill_I_stride_q8s_xpulpv2</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, int8_t *<strong>restrict</strong> pDst)<br>Create a strided 8-bit fix-point identity matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStride/#function-plp-mat-fill-i-stride-q8-parallel">plp_mat_fill_I_stride_q8_parallel</a></strong>(uint32_t N, uint32_t stride, int32_t fracBits, uint32_t nPE, int8_t *<strong>restrict</strong> pDst)<br>Glue code for creating a strided 8-bit fix-point identity matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillIStrideKernels/#function-plp-mat-fill-i-stride-q8p-xpulpv2">plp_mat_fill_I_stride_q8p_xpulpv2</a></strong>(void * args)<br>Create a strided 8-bit fix-point identity matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStride/#function-plp-mat-fill-stride-i32">plp_mat_fill_stride_i32</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int32_t value, int32_t *<strong>restrict</strong> pDst)<br>Glue code for filling an MxN strided 32-bit integers matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-i32s-rv32im">plp_mat_fill_stride_i32s_rv32im</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int32_t value, int32_t *<strong>restrict</strong> pDst)<br>Fill an MxN strided 32-bit integers matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-i32s-xpulpv2">plp_mat_fill_stride_i32s_xpulpv2</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int32_t value, int32_t *<strong>restrict</strong> pDst)<br>Fill an MxN strided 32-bit integers matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStride/#function-plp-mat-fill-stride-i32-parallel">plp_mat_fill_stride_i32_parallel</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int32_t value, uint32_t nPE, int32_t *<strong>restrict</strong> pDst)<br>Glue code for filling an MxN strided 32-bit integers matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-i32p-xpulpv2">plp_mat_fill_stride_i32p_xpulpv2</a></strong>(void * args)<br>Fill an MxN strided 32-bit integers matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStride/#function-plp-mat-fill-stride-i16">plp_mat_fill_stride_i16</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int16_t value, int16_t *<strong>restrict</strong> pDst)<br>Glue code for filling an MxN strided 16-bit integers matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-i16s-rv32im">plp_mat_fill_stride_i16s_rv32im</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int16_t value, int16_t *<strong>restrict</strong> pDst)<br>Fill an MxN strided 16-bit integers matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-i16s-xpulpv2">plp_mat_fill_stride_i16s_xpulpv2</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int16_t value, int16_t *<strong>restrict</strong> pDst)<br>Fill an MxN strided 16-bit integers matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStride/#function-plp-mat-fill-stride-i16-parallel">plp_mat_fill_stride_i16_parallel</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int16_t value, uint32_t nPE, int16_t *<strong>restrict</strong> pDst)<br>Glue code for filling an MxN strided 16-bit integers matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-i16p-xpulpv2">plp_mat_fill_stride_i16p_xpulpv2</a></strong>(void * args)<br>Fill an MxN strided 16-bit integers matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStride/#function-plp-mat-fill-stride-i8">plp_mat_fill_stride_i8</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int8_t value, int8_t *<strong>restrict</strong> pDst)<br>Glue code for filling an MxN strided 8-bit integers matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-i8s-rv32im">plp_mat_fill_stride_i8s_rv32im</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int8_t value, int8_t *<strong>restrict</strong> pDst)<br>Fill an MxN strided 8-bit integers matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-i8s-xpulpv2">plp_mat_fill_stride_i8s_xpulpv2</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int8_t value, int8_t *<strong>restrict</strong> pDst)<br>Fill an MxN strided 8-bit integers matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStride/#function-plp-mat-fill-stride-i8-parallel">plp_mat_fill_stride_i8_parallel</a></strong>(uint32_t M, uint32_t N, uint32_t stride, int8_t value, uint32_t nPE, int8_t *<strong>restrict</strong> pDst)<br>Glue code for filling an MxN strided 8-bit integers matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-i8p-xpulpv2">plp_mat_fill_stride_i8p_xpulpv2</a></strong>(void * args)<br>Fill an MxN strided 8-bit integers matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStride/#function-plp-mat-fill-stride-f32">plp_mat_fill_stride_f32</a></strong>(uint32_t M, uint32_t N, uint32_t stride, float value, float *<strong>restrict</strong> pDst)<br>Glue code for filling an MxN strided 32-bit floats matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-f32s-xpulpv2">plp_mat_fill_stride_f32s_xpulpv2</a></strong>(uint32_t M, uint32_t N, uint32_t stride, float value, float *<strong>restrict</strong> pDst)<br>Fill an MxN strided 32-bit floats matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStride/#function-plp-mat-fill-stride-f32-parallel">plp_mat_fill_stride_f32_parallel</a></strong>(uint32_t M, uint32_t N, uint32_t stride, float value, uint32_t nPE, float *<strong>restrict</strong> pDst)<br>Glue code for filling an MxN strided 32-bit floats matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatFillStrideKernels/#function-plp-mat-fill-stride-f32p-xpulpv2">plp_mat_fill_stride_f32p_xpulpv2</a></strong>(void * args)<br>Fill an MxN strided 32-bit floats matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStride/#function-plp-mat-copy-stride-i32">plp_mat_copy_stride_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int32_t </em><strong>restrict</strong> pDst)<br>Glue code to copy an MxN strided 32-bit integers matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-i32s-rv32im">plp_mat_copy_stride_i32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int32_t </em><strong>restrict</strong> pDst)<br>Copy an MxN strided 32-bit integers matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-i32s-xpulpv2">plp_mat_copy_stride_i32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int32_t </em><strong>restrict</strong> pDst)<br>Copy an MxN strided 32-bit integers matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStride/#function-plp-mat-copy-stride-i32-parallel">plp_mat_copy_stride_i32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, uint32_t nPE, int32_t </em><strong>restrict</strong> pDst)<br>Glue code to copy an MxN strided 32-bit integers matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-i32p-xpulpv2">plp_mat_copy_stride_i32p_xpulpv2</a></strong>(void * args)<br>Copy an MxN strided 32-bit integers matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStride/#function-plp-mat-copy-stride-i16">plp_mat_copy_stride_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int16_t </em><strong>restrict</strong> pDst)<br>Glue code to copy an MxN strided 16-bit integers matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-i16s-rv32im">plp_mat_copy_stride_i16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int16_t </em><strong>restrict</strong> pDst)<br>Copy an MxN strided 16-bit integers matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-i16s-xpulpv2">plp_mat_copy_stride_i16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int16_t </em><strong>restrict</strong> pDst)<br>Copy an MxN strided 16-bit integers matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStride/#function-plp-mat-copy-stride-i16-parallel">plp_mat_copy_stride_i16_parallel</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, uint32_t nPE, int16_t </em><strong>restrict</strong> pDst)<br>Glue code to copy an MxN strided 16-bit integers matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-i16p-xpulpv2">plp_mat_copy_stride_i16p_xpulpv2</a></strong>(void * args)<br>Copy an MxN strided 16-bit integers matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStride/#function-plp-mat-copy-stride-i8">plp_mat_copy_stride_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int8_t </em><strong>restrict</strong> pDst)<br>Glue code to copy an MxN strided 8-bit integers matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-i8s-rv32im">plp_mat_copy_stride_i8s_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int8_t </em><strong>restrict</strong> pDst)<br>Copy an MxN strided 8-bit integers matrix on RV32IM.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-i8s-xpulpv2">plp_mat_copy_stride_i8s_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, int8_t </em><strong>restrict</strong> pDst)<br>Copy an MxN strided 8-bit integers matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStride/#function-plp-mat-copy-stride-i8-parallel">plp_mat_copy_stride_i8_parallel</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, uint32_t nPE, int8_t </em><strong>restrict</strong> pDst)<br>Glue code to copy an MxN strided 8-bit integers matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-i8p-xpulpv2">plp_mat_copy_stride_i8p_xpulpv2</a></strong>(void * args)<br>Copy an MxN strided 8-bit integers matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStride/#function-plp-mat-copy-stride-f32">plp_mat_copy_stride_f32</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, float </em><strong>restrict</strong> pDst)<br>Glue code to copy an MxN strided 32-bit floats matrix.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-f32s-xpulpv2">plp_mat_copy_stride_f32s_xpulpv2</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, float </em><strong>restrict</strong> pDst)<br>Copy an MxN strided 32-bit floats matrix on XpulpV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStride/#function-plp-mat-copy-stride-f32-parallel">plp_mat_copy_stride_f32_parallel</a></strong>(const float <em><strong>restrict</strong> pSrc, uint32_t M, uint32_t N, uint32_t strideSrc, uint32_t strideDst, uint32_t nPE, float </em><strong>restrict</strong> pDst)<br>Glue code to copy an MxN strided 32-bit floats matrix in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__MatCopyStrideKernels/#function-plp-mat-copy-stride-f32p-xpulpv2">plp_mat_copy_stride_f32p_xpulpv2</a></strong>(void * args)<br>Copy an MxN strided 32-bit floats matrix on XpulpV2 in parallel.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-f32">plp_cmplx_conj_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex conjugate of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-f32-xpulpv2">plp_cmplx_conj_f32_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Floating-point complex conjugate.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-i32">plp_cmplx_conj_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex conjugate of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-i32-xpulpv2">plp_cmplx_conj_i32_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>32-bit integer complex conjugate.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-i32-rv32im">plp_cmplx_conj_i32_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>32-bit integer complex conjugate.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-i16">plp_cmplx_conj_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex conjugate of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-i16-xpulpv2">plp_cmplx_conj_i16_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>16-bit integer complex conjugate.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-i16-rv32im">plp_cmplx_conj_i16_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>16-bit integer complex conjugate.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-i8">plp_cmplx_conj_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex conjugate of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-i8-xpulpv2">plp_cmplx_conj_i8_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>8-bit integer complex conjugate.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__conj/#function-plp-cmplx-conj-i8-rv32im">plp_cmplx_conj_i8_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>8-bit integer complex conjugate.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cmplx-dot-prod-f32">plp_cmplx_dot_prod_f32</a></strong>(const float32_t * pSrcA, const float32_t * pSrcB, uint32_t numSamples, float32_t * realResult, float32_t * imagResult)<br>Glue code for complex dot product of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-f32-xpulpv2">plp_cmplx_dot_prod_f32_xpulpv2</a></strong>(const float32_t * pSrcA, const float32_t * pSrcB, uint32_t numSamples, float32_t * realResult, float32_t * imagResult)<br>Floating-point complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cmplx-dot-prod-i32">plp_cmplx_dot_prod_i32</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, uint32_t numSamples, int32_t * realResult, int32_t * imagResult)<br>Glue code for complex dot product of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-i32-xpulpv2">plp_cmplx_dot_prod_i32_xpulpv2</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, uint32_t numSamples, int32_t * realResult, int32_t * imagResult)<br>32-bit integer complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-i32-rv32im">plp_cmplx_dot_prod_i32_rv32im</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, uint32_t numSamples, int32_t * realResult, int32_t * imagResult)<br>32-bit integer complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cmplx-dot-prod-i16">plp_cmplx_dot_prod_i16</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, uint32_t numSamples, int16_t * realResult, int16_t * imagResult)<br>Glue code for complex dot product of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-i16-xpulpv2">plp_cmplx_dot_prod_i16_xpulpv2</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, uint32_t numSamples, int16_t * realResult, int16_t * imagResult)<br>16-bit integer complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-i16-rv32im">plp_cmplx_dot_prod_i16_rv32im</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, uint32_t numSamples, int16_t * realResult, int16_t * imagResult)<br>16-bit integer complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cmplx-dot-prod-i8">plp_cmplx_dot_prod_i8</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, uint32_t numSamples, int8_t * realResult, int8_t * imagResult)<br>Glue code for complex dot product of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-i8-xpulpv2">plp_cmplx_dot_prod_i8_xpulpv2</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, uint32_t numSamples, int8_t * realResult, int8_t * imagResult)<br>8-bit integer complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-i8-rv32im">plp_cmplx_dot_prod_i8_rv32im</a></strong>(const int8_t * pSrcA, const int8_t * pSrcB, uint32_t numSamples, int8_t * realResult, int8_t * imagResult)<br>8-bit integer complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cmplx-dot-prod-q32">plp_cmplx_dot_prod_q32</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, uint32_t numSamples, uint32_t deciPoint, int32_t * realResult, int32_t * imagResult)<br>Glue code for complex dot product of 32-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-q32-xpulpv2">plp_cmplx_dot_prod_q32_xpulpv2</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, uint32_t numSamples, uint32_t deciPoint, int32_t * realResult, int32_t * imagResult)<br>32-bit fixed-point complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-q32-rv32im">plp_cmplx_dot_prod_q32_rv32im</a></strong>(const int32_t * pSrcA, const int32_t * pSrcB, uint32_t numSamples, uint32_t deciPoint, int32_t * realResult, int32_t * imagResult)<br>32-bit integer complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#function-plp-cmplx-dot-prod-q16">plp_cmplx_dot_prod_q16</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, uint32_t numSamples, uint32_t deciPoint, int16_t * realResult, int16_t * imagResult)<br>Glue code for complex dot product of 16-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-q16-xpulpv2">plp_cmplx_dot_prod_q16_xpulpv2</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, uint32_t numSamples, uint32_t deciPoint, int16_t * realResult, int16_t * imagResult)<br>16-bit fixed-point complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__dot__prod/#function-plp-cmplx-dot-prod-q16-rv32im">plp_cmplx_dot_prod_q16_rv32im</a></strong>(const int16_t * pSrcA, const int16_t * pSrcB, uint32_t numSamples, uint32_t deciPoint, int16_t * realResult, int16_t * imagResult)<br>16-bit fixed-point complex dot product.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-f32">plp_cmplx_mult_real_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrcCmplx, const float32_t </em><strong>restrict</strong> pSrcReal, float32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex multiplied with real of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-f32-xpulpv2">plp_cmplx_mult_real_f32_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrcCmplx, const float32_t </em><strong>restrict</strong> pSrcReal, float32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Floating-point complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-i32">plp_cmplx_mult_real_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcCmplx, const int32_t </em><strong>restrict</strong> pSrcReal, int32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex multiplied with real of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-i32-xpulpv2">plp_cmplx_mult_real_i32_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcCmplx, const int32_t </em><strong>restrict</strong> pSrcReal, int32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>32-bit integer complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-i32-rv32im">plp_cmplx_mult_real_i32_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcCmplx, const int32_t </em><strong>restrict</strong> pSrcReal, int32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>32-bit integer complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-i16">plp_cmplx_mult_real_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcCmplx, const int16_t </em><strong>restrict</strong> pSrcReal, int16_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex multiplied with real of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-i16-xpulpv2">plp_cmplx_mult_real_i16_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcCmplx, const int16_t </em><strong>restrict</strong> pSrcReal, int16_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>16-bit integer complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-i16-rv32im">plp_cmplx_mult_real_i16_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcCmplx, const int16_t </em><strong>restrict</strong> pSrcReal, int16_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>16-bit integer complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-i8">plp_cmplx_mult_real_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcCmplx, const int8_t </em><strong>restrict</strong> pSrcReal, int8_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex multiplied with real of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-i8-xpulpv2">plp_cmplx_mult_real_i8_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcCmplx, const int8_t </em><strong>restrict</strong> pSrcReal, int8_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>8-bit integer complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-i8-rv32im">plp_cmplx_mult_real_i8_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcCmplx, const int8_t </em><strong>restrict</strong> pSrcReal, int8_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>8-bit integer complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-q32">plp_cmplx_mult_real_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcCmplx, const int32_t </em><strong>restrict</strong> pSrcReal, int32_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>Glue code for complex multiplied with real of 32-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-q32-xpulpv2">plp_cmplx_mult_real_q32_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcCmplx, const int32_t </em><strong>restrict</strong> pSrcReal, int32_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>32-bit fixed-point complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-q32-rv32im">plp_cmplx_mult_real_q32_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcCmplx, const int32_t </em><strong>restrict</strong> pSrcReal, int32_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>32-bit fixed-point complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-q16">plp_cmplx_mult_real_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcCmplx, const int16_t </em><strong>restrict</strong> pSrcReal, int16_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>Glue code for complex multiplied with real of 16-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-q16-xpulpv2">plp_cmplx_mult_real_q16_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcCmplx, const int16_t </em><strong>restrict</strong> pSrcReal, int16_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>16-bit fixed-point complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-q16-rv32im">plp_cmplx_mult_real_q16_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcCmplx, const int16_t </em><strong>restrict</strong> pSrcReal, int16_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>16-bit fixed-point complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-q8">plp_cmplx_mult_real_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcCmplx, const int8_t </em><strong>restrict</strong> pSrcReal, int8_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>Glue code for complex multiplied with real of 8-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-q8-xpulpv2">plp_cmplx_mult_real_q8_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcCmplx, const int8_t </em><strong>restrict</strong> pSrcReal, int8_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>8-bit fixed-point complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-real-q8-rv32im">plp_cmplx_mult_real_q8_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcCmplx, const int8_t </em><strong>restrict</strong> pSrcReal, int8_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>8-bit fixed-point complex multiplied with real.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-f32">plp_cmplx_mag_squared_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex squared magnitude of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-f32-xpulpv2">plp_cmplx_mag_squared_f32_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrc, float32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Floating-point complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-i16">plp_cmplx_mag_squared_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex squared magnitude of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-i16-rv32im">plp_cmplx_mag_squared_i16_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>16-bit integer complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-i16-xpulpv2">plp_cmplx_mag_squared_i16_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>16 bit Integer complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-i32">plp_cmplx_mag_squared_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex squared magnitude of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-i32-rv32im">plp_cmplx_mag_squared_i32_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>32-bit integer complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-i32-xpulpv2">plp_cmplx_mag_squared_i32_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>32-bit integer complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-i8-xpulpv2">plp_cmplx_mag_squared_i8_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>8 bit Integer complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-i8">plp_cmplx_mag_squared_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex squared magnitude of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-i8-rv32im">plp_cmplx_mag_squared_i8_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t </em><strong>restrict</strong> pDst, uint32_t numSamples)<br>8-bit integer complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-q32">plp_cmplx_mag_squared_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>Glue code for complex squared magnitude of 32-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-q32-rv32im">plp_cmplx_mag_squared_q32_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>32-bit fixed-point complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-q32-xpulpv2">plp_cmplx_mag_squared_q32_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrc, int32_t </em><strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>32 bit fixed-point complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-q16">plp_cmplx_mag_squared_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t </em><strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>Glue code for complex squared magnitude of 16-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-q16-rv32im">plp_cmplx_mag_squared_q16_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t </em><strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>16-bit fixed-point complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-q16-xpulpv2">plp_cmplx_mag_squared_q16_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrc, int16_t </em><strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>16 bit fixed-point complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-q8">plp_cmplx_mag_squared_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t </em><strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>Glue code for complex squared magnitude of 8-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-q8-rv32im">plp_cmplx_mag_squared_q8_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t </em><strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>8-bit fixed-point complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cmplx__mag__squared/#function-plp-cmplx-mag-squared-q8-xpulpv2">plp_cmplx_mag_squared_q8_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrc, int8_t </em><strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>8 bit fixed-point complex squared magnitude.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-f32">plp_cmplx_mult_cmplx_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, float32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex multiplied by complex of 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-f32-xpulpv2">plp_cmplx_mult_cmplx_f32_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, float32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Floating-point complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-cmplx-i32">plp_cmplx_mult_cmplx_i32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, int32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex multiplied by complex of 32-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-cmplx-i32-xpulpv2">plp_cmplx_mult_cmplx_i32_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, int32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>32-bit integer complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-cmplx-i32-rv32im">plp_cmplx_mult_cmplx_i32_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, int32_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>32-bit integer complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-i16">plp_cmplx_mult_cmplx_i16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, int16_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex multiplied by complex of 16-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-i16-xpulpv2">plp_cmplx_mult_cmplx_i16_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, int16_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>16-bit integer complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-i16-rv32im">plp_cmplx_mult_cmplx_i16_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, int16_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>16-bit integer complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-i8">plp_cmplx_mult_cmplx_i8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, int8_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>Glue code for complex multiplied by complex of 8-bit integer vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-cmplx-i8-xpulpv2">plp_cmplx_mult_cmplx_i8_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, int8_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>8-bit integer complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByRealMult/#function-plp-cmplx-mult-cmplx-i8-rv32im">plp_cmplx_mult_cmplx_i8_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, int8_t *<strong>restrict</strong> pDst, uint32_t numSamples)<br>8-bit integer complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-q32">plp_cmplx_mult_cmplx_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, int32_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>Glue code for complex multiplied by complex of 32-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-q32-xpulpv2">plp_cmplx_mult_cmplx_q32_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, int32_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>32-bit fixed-point complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-q32-rv32im">plp_cmplx_mult_cmplx_q32_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, int32_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>32-bit fixed-point complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-q16">plp_cmplx_mult_cmplx_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, int16_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>Glue code for complex multiplied by complex of 16-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-q16-xpulpv2">plp_cmplx_mult_cmplx_q16_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, int16_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>16-bit fixed-point complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-q16-rv32im">plp_cmplx_mult_cmplx_q16_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, int16_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>16-bit fixed-point complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-q8">plp_cmplx_mult_cmplx_q8</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, int8_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>Glue code for complex multiplied by complex of 8-bit fixed-point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-q8-xpulpv2">plp_cmplx_mult_cmplx_q8_xpulpv2</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, int8_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>8-bit fixed-point complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__CmplxByCmplxMult/#function-plp-cmplx-mult-cmplx-q8-rv32im">plp_cmplx_mult_cmplx_q8_rv32im</a></strong>(const int8_t <em><strong>restrict</strong> pSrcA, const int8_t </em><strong>restrict</strong> pSrcB, int8_t *<strong>restrict</strong> pDst, uint32_t deciPoint, uint32_t numSamples)<br>8-bit fixed-point complex multiplied by complex.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-q32-parallel">plp_euclidean_distance_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, uint32_t nPE, uint32_t *<strong>restrict</strong> pRes)<br>Glue code for parallel Euclidean distance of 32-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-f32-parallel">plp_euclidean_distance_f32_parallel</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t nPE, float32_t *<strong>restrict</strong> pRes)<br>Glue code for parallel Euclidean distance between 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-q32p-xpulpv2">plp_euclidean_distance_q32p_xpulpv2</a></strong>(void * S)<br>Parallel euclidean distance with interleaved access 32-bit fixed point vectors. vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-f32p-xpulpv2">plp_euclidean_distance_f32p_xpulpv2</a></strong>(void * S)<br>32-bit floating-point parallel Euclidean distance between two vectors</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-q32">plp_euclidean_distance_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>Glue code for euclidean distance of 32-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-q32s-xpulpv2">plp_euclidean_distance_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>Euclidean distance of 32-bit fixed point vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-q32s-rv32im">plp_euclidean_distance_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>Euclidean distance of 32-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-q16">plp_euclidean_distance_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint16_t blockSize, uint16_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>Glue code for euclidean distance of 16-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-q16s-xpulpv2">plp_euclidean_distance_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t deciPoint, int32_t *<strong>restrict</strong> pRes)<br>Euclidean distance of 16-bit fixed point vectors kernel for XPULPV2.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-q16s-rv32im">plp_euclidean_distance_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>Euclidean distance of 16-bit fixed point vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-f32">plp_euclidean_distance_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, float32_t *<strong>restrict</strong> pRes)<br>Glue code for Euclidean distance between 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-f32s-xpulpv2">plp_euclidean_distance_f32s_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, float32_t *<strong>restrict</strong> pRes)<br>32-bit floating point Euclidean distance between two vectors</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__Euclidean/#function-plp-euclidean-distance-f32s-rv32im">plp_euclidean_distance_f32s_rv32im</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, float32_t *<strong>restrict</strong> pRes)<br>32-bit floating point Euclidean distance between two vectors</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-q32-parallel">plp_cosine_distance_q32_parallel</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, uint32_t nPE, int32_t *<strong>restrict</strong> pRes)<br>Glue code for parallel cosine distance between 32-bit fixed-precision vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-f32-parallel">plp_cosine_distance_f32_parallel</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t nPE, float32_t *<strong>restrict</strong> pRes)<br>Glue code for parallel cosine distance between 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-f32p-xpulpv2">plp_cosine_distance_f32p_xpulpv2</a></strong>(void * S)<br>32-bit floating-point parallel cosine distance between two vectors (computes power in parallel)</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-f32">plp_cosine_distance_f32</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, float32_t *<strong>restrict</strong> pRes)<br>Glue code for cosine distance between 32-bit float vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-f32s-rv32im">plp_cosine_distance_f32s_rv32im</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, float32_t *<strong>restrict</strong> pRes)<br>32-bit floating point cosine distance between two vectors</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-f32s-xpulpv2">plp_cosine_distance_f32s_xpulpv2</a></strong>(const float32_t <em><strong>restrict</strong> pSrcA, const float32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, float32_t *<strong>restrict</strong> pRes)<br>32-bit floating point cosine distance between two vectors</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-q32">plp_cosine_distance_q32</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>Glue code for cosine distance of 32-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-q32s-rv32im">plp_cosine_distance_q32s_rv32im</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>cosine distance of 32-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-q32s-xpulpv2">plp_cosine_distance_q32s_xpulpv2</a></strong>(const int32_t <em><strong>restrict</strong> pSrcA, const int32_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>cosine distance of 32-bit fixed point vectors kernel for XPULPV2 extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-q16">plp_cosine_distance_q16</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint16_t blockSize, uint16_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>Glue code for cosine distance of 16-bit fixed point vectors.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-q16s-rv32im">plp_cosine_distance_q16s_rv32im</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>cosine distance of 16-bit fixed point vectors kernel for RV32IM extension.</td>
</tr>
<tr>
<td>void</td>
<td><strong><a href="/pulp-dsp/refmanual/Modules/group__cosine/#function-plp-cosine-distance-q16s-xpulpv2">plp_cosine_distance_q16s_xpulpv2</a></strong>(const int16_t <em><strong>restrict</strong> pSrcA, const int16_t </em><strong>restrict</strong> pSrcB, uint32_t blockSize, uint32_t fracBits, int32_t *<strong>restrict</strong> pRes)<br>cosine distance of 16-bit fixed point vectors kernel for XPULPV2.</td>
</tr>
</tbody>
</table>
<h2 id="defines">Defines</h2>
<table>
<thead>
<tr>
<th></th>
<th>Name</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-plp-math-ibex">PLP_MATH_IBEX</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-plp-math-loopunroll">PLP_MATH_LOOPUNROLL</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-plp-dwt-dec-len">PLP_DWT_DEC_LEN</a></strong>(SIG_LEN, WAVELET, LEVEL)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-plp-dwt-dec-temp-len">PLP_DWT_DEC_TEMP_LEN</a></strong>(SRC_LEN, WAVELET_LEN)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-plp-dwt-output-length">PLP_DWT_OUTPUT_LENGTH</a></strong>(SIG_LEN, WAVELET_LEN)</td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-fast-math-table-size">FAST_MATH_TABLE_SIZE</a></strong> <br>Glue code for square root of a 32-bit floating point number.</td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-fast-math-q32-shift">FAST_MATH_Q32_SHIFT</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-fast-math-q16-shift">FAST_MATH_Q16_SHIFT</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-controller-q32-shift">CONTROLLER_Q32_SHIFT</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-table-spacing-q32">TABLE_SPACING_Q32</a></strong></td>
</tr>
<tr>
<td></td>
<td><strong><a href="/pulp-dsp/refmanual/Files/plp__math_8h/#define-table-spacing-q16">TABLE_SPACING_Q16</a></strong></td>
</tr>
</tbody>
</table>
<h2 id="detailed-description">Detailed Description</h2>
<p>Public header file for PULP DSP Library. </p>
<p><strong>Version</strong>: V0 </p>
<p>==========================================================================</p>
<h1 id="date-16-may-2019">@date     16. May 2019</h1>
<h2 id="types-documentation">Types Documentation</h2>
<h3 id="enum-plp_dwt_wavelet_type">enum plp_dwt_wavelet_type</h3>
<table>
<thead>
<tr>
<th>Enumerator</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>PLP_DWT_WAVELET_OTHER</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_HAAR</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB17</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB18</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_DB20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM17</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM18</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM19</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_SYM20</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF13</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF14</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_WAVELET_COIF17</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="enum-plp_dwt_extension_mode">enum plp_dwt_extension_mode</h3>
<table>
<thead>
<tr>
<th>Enumerator</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>PLP_DWT_MODE_ZERO</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_MODE_CONSTANT</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_MODE_SYMMETRIC</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_MODE_REFLECT</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_MODE_PERIODIC</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_MODE_ANTISYMMETRIC</td>
<td></td>
<td></td>
</tr>
<tr>
<td>PLP_DWT_MODE_ANTIREFLECT</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="typedef-float32_t">typedef float32_t</h3>
<pre><code class="language-cpp">typedef float float32_t;
</code></pre>
<h2 id="functions-documentation">Functions Documentation</h2>
<h3 id="function-plp_dwt_max_level">function plp_dwt_max_level</h3>
<pre><code class="language-cpp">uint32_t plp_dwt_max_level(
    uint32_t sig_len,
    uint32_t wavelet_len
)
</code></pre>
<p>Computes maximum available decomposition level for a signal length and wavelet length. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>sig_len</strong> length of input signal </li>
<li><strong>wavelet_len</strong> wavelet length </li>
</ul>
<p><strong>Return</strong>: Maximal decomposition level </p>
<h3 id="function-plp_dwt_dec_len">function plp_dwt_dec_len</h3>
<pre><code class="language-cpp">uint32_t plp_dwt_dec_len(
    uint32_t sig_len,
    uint32_t wavelet_len,
    uint32_t level
)
</code></pre>
<p>Calculates decomposition output length given a level. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>sig_len</strong> length of input signal </li>
<li><strong>wavelet_len</strong> wavelet length </li>
<li><strong>level</strong> decomposition level (0 for maximal decomposition) </li>
</ul>
<p><strong>Return</strong>: Length of decomposition output buffer </p>
<h3 id="function-plp_dot_prod_i32_parallel">function plp_dot_prod_i32_parallel</h3>
<pre><code class="language-cpp">void plp_dot_prod_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t nPE,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for parallel dot product of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_q32_parallel">function plp_dot_prod_q32_parallel</h3>
<pre><code class="language-cpp">void plp_dot_prod_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    uint32_t nPE,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for parallel dot product of 32-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_f32_parallel">function plp_dot_prod_f32_parallel</h3>
<pre><code class="language-cpp">void plp_dot_prod_f32_parallel(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t nPE,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for parallel dot product of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_i32p_xpulpv2">function plp_dot_prod_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_i32p_xpulpv2(
    void * S
)
</code></pre>
<p>Parallel dot product with interleaved access of 32-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for integer parallel dot product </li>
<li><strong>S</strong> points to the instance structure for integer parallel dot product </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_q32p_xpulpv2">function plp_dot_prod_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_q32p_xpulpv2(
    void * S
)
</code></pre>
<p>Parallel dot product with interleaved access of 32-bit fixed point vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for fixed point parallel dot product </li>
<li><strong>S</strong> points to the instance structure for fixed point parallel dot product </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_f32p_xpulpv2">function plp_dot_prod_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_f32p_xpulpv2(
    void * S
)
</code></pre>
<p>Parallel dot product with interleaved access of 32-bit float vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for float parallel dot product </li>
<li><strong>S</strong> points to the instance structure for float parallel dot product </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_i32">function plp_dot_prod_i32</h3>
<pre><code class="language-cpp">void plp_dot_prod_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for dot product of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here</li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_dot_prod_i32s_rv32im">function plp_dot_prod_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_dot_prod_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Scalar dot product of 32-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here</li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_dot_prod_i32s_xpulpv2">function plp_dot_prod_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Scalar dot product of 32-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here</li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_dot_prod_q32">function plp_dot_prod_q32</h3>
<pre><code class="language-cpp">void plp_dot_prod_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for dot product of 32-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_q32s_rv32im">function plp_dot_prod_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_dot_prod_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Scalar dot product of 32-bit fixed point vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_q32s_xpulpv2">function plp_dot_prod_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Scalar dot product of 32-bit fixed point vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_f32">function plp_dot_prod_f32</h3>
<pre><code class="language-cpp">void plp_dot_prod_f32(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for dot product of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_f32s_xpulpv2">function plp_dot_prod_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_f32s_xpulpv2(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for dot product of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_f32s_rv32im">function plp_dot_prod_f32s_rv32im</h3>
<pre><code class="language-cpp">void plp_dot_prod_f32s_rv32im(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for dot product of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_dot_prod_i16">function plp_dot_prod_i16</h3>
<pre><code class="language-cpp">void plp_dot_prod_i16(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for dot product of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit]</li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>When the ISA supports, the 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_dot_prod_i16s_rv32im">function plp_dot_prod_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_dot_prod_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Vectorized dot product of 16-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>When the ISA supports, the 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2).
  * Exploiting SIMD instructions</p>
<p>When the ISA supports, the 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2). </p>
<hr />
<p>Vectorized dot product of 16-bit integer vectors kernel for RV32IM extension.</p>
<h3 id="function-plp_dot_prod_i16s_xpulpv2">function plp_dot_prod_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Vectorized dot product of 16-bit integer vectors kernel singlecore for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<p>Vectorized dot product of 16-bit integer vectors kernel singlecore for XPULPV2 extension.</p>
<h3 id="function-plp_dot_prod_q16">function plp_dot_prod_q16</h3>
<pre><code class="language-cpp">void plp_dot_prod_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for dot product of 16-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>When the ISA supports, the 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_dot_prod_q16s_rv32im">function plp_dot_prod_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_dot_prod_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Scalar dot product of 16-bit fixed point vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>When the ISA supports, the 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2).
  * Exploiting SIMD instructions</p>
<p>When the ISA supports, the 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2). </p>
<hr />
<h3 id="function-plp_dot_prod_q16s_xpulpv2">function plp_dot_prod_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Vectorized dot product of 16-bit fixed point vectors singlecore kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_dot_prod_i8">function plp_dot_prod_i8</h3>
<pre><code class="language-cpp">void plp_dot_prod_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for dot product of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>When the ISA supports, the 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>When the ISA supports, the 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_dot_prod_i8s_rv32im">function plp_dot_prod_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_dot_prod_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Vectorized dot product of 8-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [8] bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [8] bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>When the ISA supports, the 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2).
  * Exploiting SIMD instructions</p>
<p>When the ISA supports, the 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2). </p>
<hr />
<p>Vectorized dot product of 8-bit integer vectors kernel for RV32IM extension.</p>
<h3 id="function-plp_dot_prod_i8s_xpulpv2">function plp_dot_prod_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Vectorized dot product of 8-bit integer vectors singlecore kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_dot_prod_q8">function plp_dot_prod_q8</h3>
<pre><code class="language-cpp">void plp_dot_prod_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for dot product of 8-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>When the ISA supports, the 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>When the ISA supports, the 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_dot_prod_q8s_rv32im">function plp_dot_prod_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_dot_prod_q8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Scalar dot product of 8-bit fixed point vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>When the ISA supports, the 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2).
  * Exploiting SIMD instructions</p>
<p>When the ISA supports, the 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2). </p>
<hr />
<h3 id="function-plp_dot_prod_q8s_xpulpv2">function plp_dot_prod_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dot_prod_q8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Scalar dot product of 8-bit fixed point vectors singlecore kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [8 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [8 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four by four into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_abs_i32">function plp_abs_i32</h3>
<pre><code class="language-cpp">void plp_abs_i32(
    const int32_t * pSrc,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for absolute value of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_abs_i32s_rv32im">function plp_abs_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_abs_i32s_rv32im(
    const int32_t * pSrc,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element absolute value of 32-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_abs_i32s_xpulpv2">function plp_abs_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_abs_i32s_xpulpv2(
    const int32_t * pSrc,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element absolute value of 32-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_abs_i16">function plp_abs_i16</h3>
<pre><code class="language-cpp">void plp_abs_i16(
    const int16_t * pSrc,
    int16_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for absolute value of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_abs_i16s_rv32im">function plp_abs_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_abs_i16s_rv32im(
    const int16_t * pSrc,
    int16_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element absolute value of 16-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_abs_i16s_xpulpv2">function plp_abs_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_abs_i16s_xpulpv2(
    const int16_t * pSrc,
    int16_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element absolute value of 16-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_abs_i8">function plp_abs_i8</h3>
<pre><code class="language-cpp">void plp_abs_i8(
    const int8_t * pSrc,
    int8_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for absolute value of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_abs_i8s_rv32im">function plp_abs_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_abs_i8s_rv32im(
    const int8_t * pSrc,
    int8_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element absolute value of 8-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_abs_i8s_xpulpv2">function plp_abs_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_abs_i8s_xpulpv2(
    const int8_t * pSrc,
    int8_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element absolute value of 8-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_add_i32">function plp_add_i32</h3>
<pre><code class="language-cpp">void plp_add_i32(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for element-by-element addition of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_add_i32s_rv32im">function plp_add_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_add_i32s_rv32im(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element addition of 32-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_add_i32s_xpulpv2">function plp_add_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_add_i32s_xpulpv2(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element addition of 32-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_add_i16">function plp_add_i16</h3>
<pre><code class="language-cpp">void plp_add_i16(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for element-by-element addition of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_add_i16s_rv32im">function plp_add_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_add_i16s_rv32im(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element addition of 16-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_add_i16s_xpulpv2">function plp_add_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_add_i16s_xpulpv2(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element addition of 16-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_add_i8">function plp_add_i8</h3>
<pre><code class="language-cpp">void plp_add_i8(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for element-by-element addition of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_add_i8s_rv32im">function plp_add_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_add_i8s_rv32im(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element addition of 8-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_add_i8s_xpulpv2">function plp_add_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_add_i8s_xpulpv2(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element addition of 8-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_i32">function plp_mult_i32</h3>
<pre><code class="language-cpp">void plp_mult_i32(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for element-by-element multiplication of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_i32s_rv32im">function plp_mult_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mult_i32s_rv32im(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element multiplication of 32-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_i32s_xpulpv2">function plp_mult_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mult_i32s_xpulpv2(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element multiplication of 32-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_i16">function plp_mult_i16</h3>
<pre><code class="language-cpp">void plp_mult_i16(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for element-by-element multiplication of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_i16s_rv32im">function plp_mult_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mult_i16s_rv32im(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element multiplication of 16-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_i16s_xpulpv2">function plp_mult_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mult_i16s_xpulpv2(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element multiplication of 16-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_i8">function plp_mult_i8</h3>
<pre><code class="language-cpp">void plp_mult_i8(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for element-by-element multiplication of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_i8s_rv32im">function plp_mult_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mult_i8s_rv32im(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element multiplication of 8-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_i8s_xpulpv2">function plp_mult_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mult_i8s_xpulpv2(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element multiplication of 8-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_f32">function plp_mult_f32</h3>
<pre><code class="language-cpp">void plp_mult_f32(
    const float32_t * pSrcA,
    const float32_t * pSrcB,
    float32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for element-by-element multiplication of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mult_f32s_xpulpv2">function plp_mult_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mult_f32s_xpulpv2(
    const float32_t * pSrcA,
    const float32_t * pSrcB,
    float32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Element-by-element multiplication of 32-bit float vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Element-by-element multiplication of 32-bit float vectors kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mult_f32_parallel">function plp_mult_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mult_f32_parallel(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t nPE,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel dot product of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pDst</strong> points to output vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_mult_f32p_xpulpv2">function plp_mult_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mult_f32p_xpulpv2(
    void * S
)
</code></pre>
<p>Parallel multiplication with interleaved access of 32-bit float vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for float parallel multiplication </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_log_f32_parallel">function plp_log_f32_parallel</h3>
<pre><code class="language-cpp">void plp_log_f32_parallel(
    const float32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t nPE,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel log of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pDst</strong> points to output vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_log_f32p_xpulpv2">function plp_log_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_log_f32p_xpulpv2(
    void * S
)
</code></pre>
<p>Parallel log with interleaved access of 32-bit float vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for float parallel log </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_negate_i32">function plp_negate_i32</h3>
<pre><code class="language-cpp">void plp_negate_i32(
    const int32_t * pSrc,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of negate the elements of a vector for 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_negate_i32s_rv32im">function plp_negate_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_negate_i32s_rv32im(
    const int32_t * pSrc,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>negate the elements of a vector for 32-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_negate_i32s_xpulpv2">function plp_negate_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_negate_i32s_xpulpv2(
    const int32_t * pSrc,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>negate the elements of a vector for 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_negate_i16">function plp_negate_i16</h3>
<pre><code class="language-cpp">void plp_negate_i16(
    const int16_t * pSrc,
    int16_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of negate the elements of a vector for 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_negate_i16s_rv32im">function plp_negate_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_negate_i16s_rv32im(
    const int16_t * pSrc,
    int16_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>negate the elements of a vector for 16-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_negate_i16s_xpulpv2">function plp_negate_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_negate_i16s_xpulpv2(
    const int16_t * pSrc,
    int16_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>negate the elements of a vector for 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_negate_i8">function plp_negate_i8</h3>
<pre><code class="language-cpp">void plp_negate_i8(
    const int8_t * pSrc,
    int8_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of negate the elements of a vector for 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_negate_i8s_rv32im">function plp_negate_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_negate_i8s_rv32im(
    const int8_t * pSrc,
    int8_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>negate the elements of a vector for 8-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_negate_i8s_xpulpv2">function plp_negate_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_negate_i8s_xpulpv2(
    const int8_t * pSrc,
    int8_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>negate the elements of a vector for 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_negate_f32">function plp_negate_f32</h3>
<pre><code class="language-cpp">void plp_negate_f32(
    const float32_t * pSrc,
    float32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of negate the elements of a vector for 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_negate_f32s_xpulpv2">function plp_negate_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_negate_f32s_xpulpv2(
    const float32_t * pSrc,
    float32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>negate the elements of a vector for 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
<li><strong>pSrc</strong> points to input vector. </li>
<li><strong>pDst</strong> points to output vector. </li>
<li><strong>blockSize</strong> number of samples in each vector. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_offset_i32">function plp_offset_i32</h3>
<pre><code class="language-cpp">void plp_offset_i32(
    const int32_t * pSrc,
    int32_t offset,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of add a constant offset to a vector for 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_offset_i32s_rv32im">function plp_offset_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_offset_i32s_rv32im(
    const int32_t * pSrc,
    int32_t offset,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>add a constant offset to a vector for 32-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_offset_i32s_xpulpv2">function plp_offset_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_offset_i32s_xpulpv2(
    const int32_t * pSrc,
    int32_t offset,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>add a constant offset to a vector for 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_offset_i16">function plp_offset_i16</h3>
<pre><code class="language-cpp">void plp_offset_i16(
    const int16_t * pSrc,
    int16_t offset,
    int16_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of add a constant offset to a vector for 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_offset_i16s_rv32im">function plp_offset_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_offset_i16s_rv32im(
    const int16_t * pSrc,
    int16_t offset,
    int16_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>add a constant offset to a vector for 16-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_offset_i16s_xpulpv2">function plp_offset_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_offset_i16s_xpulpv2(
    const int16_t * pSrc,
    int16_t offset,
    int16_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>add a constant offset to a vector for 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_offset_i8">function plp_offset_i8</h3>
<pre><code class="language-cpp">void plp_offset_i8(
    const int8_t * pSrc,
    int8_t offset,
    int8_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of add a constant offset to a vector for 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_offset_i8s_rv32im">function plp_offset_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_offset_i8s_rv32im(
    const int8_t * pSrc,
    int8_t offset,
    int8_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>add a constant offset to a vector for 8-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_offset_i8s_xpulpv2">function plp_offset_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_offset_i8s_xpulpv2(
    const int8_t * pSrc,
    int8_t offset,
    int8_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>add a constant offset to a vector for 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_offset_f32">function plp_offset_f32</h3>
<pre><code class="language-cpp">void plp_offset_f32(
    const float32_t * pSrc,
    float32_t offset,
    float32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of add a constant offset to a vector for 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_offset_f32s_xpulpv2">function plp_offset_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_offset_f32s_xpulpv2(
    const float32_t * pSrc,
    float32_t offset,
    float32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>add a constant offset to a vector for 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>offset</strong> is the offset to be added </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sub_i32">function plp_sub_i32</h3>
<pre><code class="language-cpp">void plp_sub_i32(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of vector substraction for 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sub_i32s_rv32im">function plp_sub_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_sub_i32s_rv32im(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>vector substraction for 32-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sub_i32s_xpulpv2">function plp_sub_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_sub_i32s_xpulpv2(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>vector substraction for 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sub_i16">function plp_sub_i16</h3>
<pre><code class="language-cpp">void plp_sub_i16(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of vector substraction for 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sub_i16s_rv32im">function plp_sub_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_sub_i16s_rv32im(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>vector substraction for 16-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sub_i16s_xpulpv2">function plp_sub_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_sub_i16s_xpulpv2(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>vector substraction for 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_sub_i8">function plp_sub_i8</h3>
<pre><code class="language-cpp">void plp_sub_i8(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of vector substraction for 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sub_i8s_rv32im">function plp_sub_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_sub_i8s_rv32im(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>vector substraction for 8-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sub_i8s_xpulpv2">function plp_sub_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_sub_i8s_xpulpv2(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    int32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>vector substraction for 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_sub_f32">function plp_sub_f32</h3>
<pre><code class="language-cpp">void plp_sub_f32(
    const float32_t * pSrcA,
    const float32_t * pSrcB,
    float32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of vector substraction for 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sub_f32s_xpulpv2">function plp_sub_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_sub_f32s_xpulpv2(
    const float32_t * pSrcA,
    const float32_t * pSrcB,
    float32_t * pDst,
    uint32_t blockSize
)
</code></pre>
<p>vector substraction for 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_scale_i32">function plp_scale_i32</h3>
<pre><code class="language-cpp">void plp_scale_i32(
    const int32_t *__restrict__ pSrc,
    int32_t scaleFactor,
    int32_t shift,
    int32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of multiply a vector by a scalar for 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_scale_i32s_rv32im">function plp_scale_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_scale_i32s_rv32im(
    const int32_t *__restrict__ pSrc,
    int32_t scaleFactor,
    int32_t shift,
    int32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>multiply a vector by a scalar for 32-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_scale_i32s_xpulpv2">function plp_scale_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_scale_i32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    int32_t scaleFactor,
    int32_t shift,
    int32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>multiply a vector by a scalar for 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_scale_i16">function plp_scale_i16</h3>
<pre><code class="language-cpp">void plp_scale_i16(
    const int16_t *__restrict__ pSrc,
    int16_t scaleFactor,
    int32_t shift,
    int16_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of multiply a vector by a scalar for 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_scale_i16s_rv32im">function plp_scale_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_scale_i16s_rv32im(
    const int16_t *__restrict__ pSrc,
    int16_t scaleFactor,
    int32_t shift,
    int16_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>multiply a vector by a scalar for 16-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_scale_i16s_xpulpv2">function plp_scale_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_scale_i16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    int16_t scaleFactor,
    int32_t shift,
    int16_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>multiply a vector by a scalar for 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_scale_i8">function plp_scale_i8</h3>
<pre><code class="language-cpp">void plp_scale_i8(
    const int8_t *__restrict__ pSrc,
    int8_t scaleFactor,
    int32_t shift,
    int8_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of multiply a vector by a scalar for 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_scale_i8s_rv32im">function plp_scale_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_scale_i8s_rv32im(
    const int8_t *__restrict__ pSrc,
    int8_t scaleFactor,
    int32_t shift,
    int8_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>multiply a vector by a scalar for 8-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_scale_i8s_xpulpv2">function plp_scale_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_scale_i8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    int8_t scaleFactor,
    int32_t shift,
    int8_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>multiply a vector by a scalar for 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>shift</strong> number of bits to shift the result by </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_scale_f32">function plp_scale_f32</h3>
<pre><code class="language-cpp">void plp_scale_f32(
    const float32_t *__restrict__ pSrc,
    float32_t scaleFactor,
    float32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code of multiply a vector by a scalar for 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_scale_f32s_xpulpv2">function plp_scale_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_scale_f32s_xpulpv2(
    const float32_t *__restrict__ pSrc,
    float32_t scaleFactor,
    float32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>multiply a vector by a scalar for 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements before shifting </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>scaleFactor</strong> Factor to multiply all elements </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_fill_i32">function plp_fill_i32</h3>
<pre><code class="language-cpp">void plp_fill_i32(
    int32_t value,
    int32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for filling a constant value into a 32-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>value</strong> input value to be filled </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>value</strong> input value to be filled </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_fill_i32s_rv32im">function plp_fill_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_fill_i32s_rv32im(
    int32_t value,
    int32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Fills a constant value into a 32-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>value</strong> input value to be filled </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>value</strong> input value to be filled </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_fill_i32s_xpulpv2">function plp_fill_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_fill_i32s_xpulpv2(
    int32_t value,
    int32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Fills a constant value into a 32-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>value</strong> input value to be filled </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>value</strong> input value to be filled </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_copy_i32">function plp_copy_i32</h3>
<pre><code class="language-cpp">void plp_copy_i32(
    int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for copying the elements of a 32-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_copy_i32s_rv32im">function plp_copy_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_copy_i32s_rv32im(
    int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Copies the elements of a 32-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_copy_i32s_xpulpv2">function plp_copy_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_copy_i32s_xpulpv2(
    int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Copies the elements of a 32-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_copy_f32">function plp_copy_f32</h3>
<pre><code class="language-cpp">void plp_copy_f32(
    float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Glue code for copying the elements of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for copying the elements of a 32-bit float vector.</p>
<h3 id="function-plp_copy_f32s_xpulpv2">function plp_copy_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_copy_f32s_xpulpv2(
    float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Copies the elements of a 32-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_copy_f32s_rv32im">function plp_copy_f32s_rv32im</h3>
<pre><code class="language-cpp">void plp_copy_f32s_rv32im(
    float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst,
    uint32_t blockSize
)
</code></pre>
<p>Copies the elements of a 32-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_f32">function plp_mean_f32</h3>
<pre><code class="language-cpp">void plp_mean_f32(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Glue code for mean value of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_f32s_xpulpv2">function plp_mean_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mean_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Glue code for mean value of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for mean value of a 32-bit float vector.</p>
<h3 id="function-plp_mean_i32">function plp_mean_i32</h3>
<pre><code class="language-cpp">void plp_mean_i32(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for mean value of a 32-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_i32s_rv32im">function plp_mean_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mean_i32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Mean value of a 32-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_i32s_xpulpv2">function plp_mean_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mean_i32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Mean value of a 32-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_i16">function plp_mean_i16</h3>
<pre><code class="language-cpp">void plp_mean_i16(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for mean value of a 16-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_i16s_rv32im">function plp_mean_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mean_i16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Mean value of a 16-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_i16s_xpulpv2">function plp_mean_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mean_i16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Mean value of a 16-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_i8">function plp_mean_i8</h3>
<pre><code class="language-cpp">void plp_mean_i8(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for mean value of a 8-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_i8s_rv32im">function plp_mean_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mean_i8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Mean value of a 8-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mean_i8s_xpulpv2">function plp_mean_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mean_i8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Mean value of a 8-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> mean value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_f32">function plp_max_f32</h3>
<pre><code class="language-cpp">void plp_max_f32(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Glue code for max value of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_f32s_xpulpv2">function plp_max_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_max_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Kernel for max value of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Kernel for max value of a 32-bit float vector.</p>
<h3 id="function-plp_max_i32">function plp_max_i32</h3>
<pre><code class="language-cpp">void plp_max_i32(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for max value of a 32-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_i32s_rv32im">function plp_max_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_max_i32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Max value of a 32-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_i32s_xpulpv2">function plp_max_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_max_i32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Max value of a 32-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_i16">function plp_max_i16</h3>
<pre><code class="language-cpp">void plp_max_i16(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for max value of a 16-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_i16s_rv32im">function plp_max_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_max_i16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Max value of a 16-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_i16s_xpulpv2">function plp_max_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_max_i16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Max value of a 16-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_i8">function plp_max_i8</h3>
<pre><code class="language-cpp">void plp_max_i8(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for max value of a 8-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_i8s_rv32im">function plp_max_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_max_i8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Max value of a 8-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_max_i8s_xpulpv2">function plp_max_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_max_i8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Max value of a 8-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> max value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_f32">function plp_min_f32</h3>
<pre><code class="language-cpp">void plp_min_f32(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Glue code for min value of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_f32s_xpulpv2">function plp_min_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_min_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Kernel for min value of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Kernel for min value of a 32-bit float vector.</p>
<h3 id="function-plp_min_i32">function plp_min_i32</h3>
<pre><code class="language-cpp">void plp_min_i32(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for min value of a 32-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_i32s_rv32im">function plp_min_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_min_i32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Min value of a 32-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_i32s_xpulpv2">function plp_min_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_min_i32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Min value of a 32-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_i16">function plp_min_i16</h3>
<pre><code class="language-cpp">void plp_min_i16(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for min value of a 16-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_i16s_rv32im">function plp_min_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_min_i16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Min value of a 16-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_i16s_xpulpv2">function plp_min_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_min_i16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Min value of a 16-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_i8">function plp_min_i8</h3>
<pre><code class="language-cpp">void plp_min_i8(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for min value of a 8-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_i8s_rv32im">function plp_min_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_min_i8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Min value of a 8-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_min_i8s_xpulpv2">function plp_min_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_min_i8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Min value of a 8-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> min value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_f32_parallel">function plp_power_f32_parallel</h3>
<pre><code class="language-cpp">void plp_power_f32_parallel(
    const float32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t nPE,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for parallel power of 32-bit floating point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_power_f32p_xpulpv2">function plp_power_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_power_f32p_xpulpv2(
    void * S
)
</code></pre>
<p>Parallel sum of squares of a 32-bit float vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for floating-point parallel power </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_power_f32">function plp_power_f32</h3>
<pre><code class="language-cpp">void plp_power_f32(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Glue code for Sum of squares of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Sum of squares of a 32-bit float vector.</p>
<h3 id="function-plp_power_f32s_xpulpv2">function plp_power_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_power_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Kernel for Sum of squares of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Kernel for Sum of squares of a 32-bit float vector.</p>
<h3 id="function-plp_power_f32s_rv32im">function plp_power_f32s_rv32im</h3>
<pre><code class="language-cpp">void plp_power_f32s_rv32im(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 32-bit float vector for RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_power_i32">function plp_power_i32</h3>
<pre><code class="language-cpp">void plp_power_i32(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Sum of squares of a 32-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Sum of squares of a 32-bit integer vector.</p>
<h3 id="function-plp_power_i32s_rv32im">function plp_power_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_power_i32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 32-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_i32s_xpulpv2">function plp_power_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_power_i32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 32-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_i16">function plp_power_i16</h3>
<pre><code class="language-cpp">void plp_power_i16(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Sum of squares of a 16-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Sum of squares of a 16-bit integer vector.</p>
<h3 id="function-plp_power_i16s_rv32im">function plp_power_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_power_i16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 16-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_i16s_xpulpv2">function plp_power_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_power_i16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 16-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_i8">function plp_power_i8</h3>
<pre><code class="language-cpp">void plp_power_i8(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Sum of squares of a 8-bit integer vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Sum of squares of a 8-bit integer vector.</p>
<h3 id="function-plp_power_i8s_rv32im">function plp_power_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_power_i8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 8-bit integer vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_i8s_xpulpv2">function plp_power_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_power_i8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 8-bit integer vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Sum of squares value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_q32_parallel">function plp_power_q32_parallel</h3>
<pre><code class="language-cpp">void plp_power_q32_parallel(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    uint32_t nPE,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for parallel power of 32-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> number of fixed point fractional bits </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for parallel power of 32-bit fixed point vectors.</p>
<h3 id="function-plp_power_q32p_xpulpv2">function plp_power_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_power_q32p_xpulpv2(
    void * S
)
</code></pre>
<p>Parallel sum of squares of a 32-bit fixed-point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for fixed-point parallel power </li>
<li><strong>S</strong> points to the instance structure for floating-point parallel power </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Parallel sum of squares of a 32-bit fixed-point vector for XPULPV2 extension.</p>
<h3 id="function-plp_power_q32">function plp_power_q32</h3>
<pre><code class="language-cpp">void plp_power_q32(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Sum of squares of a 32-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Sum of squares of a 32-bit fixed point vector.</p>
<h3 id="function-plp_power_q32s_rv32im">function plp_power_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_power_q32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 32-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_q32s_xpulpv2">function plp_power_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_power_q32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 32-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_q16">function plp_power_q16</h3>
<pre><code class="language-cpp">void plp_power_q16(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Sum of squares of a 16-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Sum of squares of a 16-bit fixed point vector.</p>
<h3 id="function-plp_power_q16s_rv32im">function plp_power_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_power_q16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 16-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_q16s_xpulpv2">function plp_power_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_power_q16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 16-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_q8">function plp_power_q8</h3>
<pre><code class="language-cpp">void plp_power_q8(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Sum of squares of a 8-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Sum of squares of a 8-bit fixed point vector.</p>
<h3 id="function-plp_power_q8s_rv32im">function plp_power_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_power_q8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 8-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Sum of squares returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_power_q8s_xpulpv2">function plp_power_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_power_q8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Sum of squares of a 8-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Sum of squares value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> sum of squares returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_var_f32">function plp_var_f32</h3>
<pre><code class="language-cpp">void plp_var_f32(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical variance of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical variance returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical variance of a 32-bit float vector.</p>
<h3 id="function-plp_var_f32s_xpulpv2">function plp_var_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_var_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Kernel for Statisical variance of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical variance returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Kernel for Statisical variance of a 32-bit float vector.</p>
<h3 id="function-plp_var_q32">function plp_var_q32</h3>
<pre><code class="language-cpp">void plp_var_q32(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical variance of a 32-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical variance returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical variance of a 32-bit fixed point vector.</p>
<h3 id="function-plp_var_q32s_rv32im">function plp_var_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_var_q32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Statisical variance of a 32-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical variance value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Variance returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical variance of a 32-bit fixed point vector for RV32IM extension.</p>
<h3 id="function-plp_var_q32s_xpulpv2">function plp_var_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_var_q32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Statisical variance of a 32-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Statisical variance returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical variance of a 32-bit fixed point vector for XPULPV2 extension.</p>
<h3 id="function-plp_var_q16">function plp_var_q16</h3>
<pre><code class="language-cpp">void plp_var_q16(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical variance of a 16-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical variance returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical variance of a 16-bit fixed point vector.</p>
<h3 id="function-plp_var_q16s_rv32im">function plp_var_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_var_q16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Statisical variance of a 16-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical variance returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical variance of a 16-bit fixed point vector for RV32IM extension.</p>
<h3 id="function-plp_var_q16s_xpulpv2">function plp_var_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_var_q16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Statisical variance of a 16-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Statisical variance returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical variance of a 16-bit fixed point vector for XPULPV2 extension.</p>
<h3 id="function-plp_var_q8">function plp_var_q8</h3>
<pre><code class="language-cpp">void plp_var_q8(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical variance of a 8-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical variance returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical variance of a 8-bit fixed point vector.</p>
<h3 id="function-plp_var_q8s_rv32im">function plp_var_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_var_q8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Statisical variance of a 8-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical variance returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical variance of a 8-bit fixed point vector for RV32IM extension.</p>
<h3 id="function-plp_var_q8s_xpulpv2">function plp_var_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_var_q8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Statisical variance of a 8-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Statisical variance value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> variance returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical variance of a 8-bit fixed point vector for XPULPV2 extension.</p>
<h3 id="function-plp_std_f32">function plp_std_f32</h3>
<pre><code class="language-cpp">void plp_std_f32(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical standard deviation of a 32-bit floating point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical standard deviation of a 32-bit floating point vector.</p>
<h3 id="function-plp_std_f32s_xpulpv2">function plp_std_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_std_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Kernel for Statisical standard deviation of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard deviation returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Kernel for Statisical standard deviation of a 32-bit float vector.</p>
<h3 id="function-plp_std_q32">function plp_std_q32</h3>
<pre><code class="language-cpp">void plp_std_q32(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical standard deviation of a 32-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical standard deviation of a 32-bit fixed point vector.</p>
<h3 id="function-plp_std_q32s_rv32im">function plp_std_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_std_q32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 32-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard deviation returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 32-bit fixed point vector for RV32IM extension.</p>
<h3 id="function-plp_std_q32s_xpulpv2">function plp_std_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_std_q32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 32-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard deviation returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 32-bit fixed point vector for XPULPV2 extension.</p>
<h3 id="function-plp_std_q16">function plp_std_q16</h3>
<pre><code class="language-cpp">void plp_std_q16(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical standard deviation of a 16-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical standard deviation of a 16-bit fixed point vector.</p>
<h3 id="function-plp_std_q16s_rv32im">function plp_std_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_std_q16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 16-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard deviation returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 16-bit fixed point vector for RV32IM extension.</p>
<h3 id="function-plp_std_q16s_xpulpv2">function plp_std_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_std_q16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 16-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard deviation returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 16-bit fixed point vector for XPULPV2 extension.</p>
<h3 id="function-plp_std_q8">function plp_std_q8</h3>
<pre><code class="language-cpp">void plp_std_q8(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical standard deviation of a 8-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical standard deviation of a 8-bit fixed point vector.</p>
<h3 id="function-plp_std_q8s_rv32im">function plp_std_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_std_q8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 8-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard deviation returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 8-bit fixed point vector for RV32IM extension.</p>
<h3 id="function-plp_std_q8s_xpulpv2">function plp_std_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_std_q8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 8-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Statisical standard deviation value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> standard deviation returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 8-bit fixed point vector for XPULPV2 extension.</p>
<h3 id="function-plp_rms_f32">function plp_rms_f32</h3>
<pre><code class="language-cpp">void plp_rms_f32(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical standard deviation of a 32-bit floating point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical standard deviation of a 32-bit floating point vector.</p>
<h3 id="function-plp_rms_f32s_xpulpv2">function plp_rms_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_rms_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t blockSize,
    float *__restrict__ pRes
)
</code></pre>
<p>Kernel for Statisical standard deviation of a 32-bit float vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Kernel for Statisical standard deviation of a 32-bit float vector.</p>
<h3 id="function-plp_rms_q32">function plp_rms_q32</h3>
<pre><code class="language-cpp">void plp_rms_q32(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical standard deviation of a 32-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical standard deviation of a 32-bit fixed point vector.</p>
<h3 id="function-plp_rms_q32s_rv32im">function plp_rms_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_rms_q32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 32-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 32-bit fixed point vector for RV32IM extension.</p>
<h3 id="function-plp_rms_q32s_xpulpv2">function plp_rms_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_rms_q32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 32-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 32-bit fixed point vector for XPULPV2 extension.</p>
<h3 id="function-plp_rms_q16">function plp_rms_q16</h3>
<pre><code class="language-cpp">void plp_rms_q16(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical standard deviation of a 16-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical standard deviation of a 16-bit fixed point vector.</p>
<h3 id="function-plp_rms_q16s_rv32im">function plp_rms_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_rms_q16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 16-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 16-bit fixed point vector for RV32IM extension.</p>
<h3 id="function-plp_rms_q16s_xpulpv2">function plp_rms_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_rms_q16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 16-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 16-bit fixed point vector for XPULPV2 extension.</p>
<h3 id="function-plp_rms_q8">function plp_rms_q8</h3>
<pre><code class="language-cpp">void plp_rms_q8(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Statisical standard deviation of a 8-bit fixed point vector. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for Statisical standard deviation of a 8-bit fixed point vector.</p>
<h3 id="function-plp_rms_q8s_rv32im">function plp_rms_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_rms_q8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 8-bit fixed point vector for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pResult</strong> Statisical standard deviation returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 8-bit fixed point vector for RV32IM extension.</p>
<h3 id="function-plp_rms_q8s_xpulpv2">function plp_rms_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_rms_q8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t blockSize,
    uint32_t fracBits,
    int8_t *__restrict__ pRes
)
</code></pre>
<p>Statisical standard deviation of a 8-bit fixed point vector for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> Statisical standard deviation value returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>blockSize</strong> number of samples in input vector </li>
<li><strong>pRes</strong> RMS value returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Statisical standard deviation of a 8-bit fixed point vector for XPULPV2 extension.</p>
<h3 id="function-plp_sqrt_q32">function plp_sqrt_q32</h3>
<pre><code class="language-cpp">void plp_sqrt_q32(
    const int32_t *__restrict__ pSrc,
    const uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for square root of a 32-bit fixed point number. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>in</strong> 32-Bit input integer </li>
<li><strong>out</strong> Square root of the input </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sqrt_q32s_rv32im">function plp_sqrt_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_sqrt_q32s_rv32im(
    const int32_t *__restrict__ pSrc,
    const uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Square root of a 32-bit fixed point number for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>in</strong> 32-Bit input integer </li>
<li><strong>out</strong> Square root of the input </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Square root of a 32-bit fixed point number for XPULPV2 extension.</p>
<h3 id="function-plp_sqrt_q32s_xpulpv2">function plp_sqrt_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_sqrt_q32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    const uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Square root of a 32-bit fixed point number for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>in</strong> 32-Bit input integer </li>
<li><strong>out</strong> Square root of the input </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sqrt_q16">function plp_sqrt_q16</h3>
<pre><code class="language-cpp">void plp_sqrt_q16(
    const int16_t *__restrict__ pSrc,
    const uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for square root of a 16-bit fixed point number. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>in</strong> 16-Bit input integer </li>
<li><strong>out</strong> Square root of the input </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sqrt_q16s_rv32im">function plp_sqrt_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_sqrt_q16s_rv32im(
    const int16_t *__restrict__ pSrc,
    const uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Square root of a 16-bit fixed point number for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>in</strong> 16-Bit input integer </li>
<li><strong>out</strong> Square root of the input </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Square root of a 16-bit fixed point number for XPULPV2 extension.</p>
<h3 id="function-plp_sqrt_q16s_xpulpv2">function plp_sqrt_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_sqrt_q16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    const uint32_t fracBits,
    int16_t *__restrict__ pRes
)
</code></pre>
<p>Square root of a 16-bit fixed point number for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>in</strong> 16-Bit input integer </li>
<li><strong>out</strong> Square root of the input </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_sqrt_f32">function plp_sqrt_f32</h3>
<pre><code class="language-cpp">void plp_sqrt_f32(
    const float *__restrict__ pSrc,
    float *__restrict__ pRes
)
</code></pre>
<p>Glue code for square root of a 32-bit floating point number. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
<li><strong>pSrc</strong> points to the input vectoro </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_sqrt_f32s_rv32im">function plp_sqrt_f32s_rv32im</h3>
<pre><code class="language-cpp">void plp_sqrt_f32s_rv32im(
    const float *__restrict__ pSrc,
    float *__restrict__ pRes
)
</code></pre>
<p>Square root of a 32-bit floating point number for RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_sqrt_f32s_xpulpv2">function plp_sqrt_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_sqrt_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    float *__restrict__ pRes
)
</code></pre>
<p>Kernel for square root of a 32-bit floating point number. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Kernel for square root of a 32-bit floating point number.</p>
<h3 id="function-plp_cos_q32">function plp_cos_q32</h3>
<pre><code class="language-cpp">int32_t plp_cos_q32(
    int32_t x
)
</code></pre>
<p>Glue code for q32 cosine function. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>cos(x)</li>
<li>cos(x) </li>
</ul>
<h3 id="function-plp_cos_q32s_rv32im">function plp_cos_q32s_rv32im</h3>
<pre><code class="language-cpp">int32_t plp_cos_q32s_rv32im(
    int32_t x
)
</code></pre>
<p>q32 cosine function for RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>cos(x)</li>
<li>cos(x) </li>
</ul>
<h3 id="function-plp_cos_q32s_xpulpv2">function plp_cos_q32s_xpulpv2</h3>
<pre><code class="language-cpp">int32_t plp_cos_q32s_xpulpv2(
    int32_t x
)
</code></pre>
<p>q32 cosine function for XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>cos(x)</li>
<li>cos(x) </li>
</ul>
<h3 id="function-plp_cos_q16">function plp_cos_q16</h3>
<pre><code class="language-cpp">int16_t plp_cos_q16(
    int16_t x
)
</code></pre>
<p>Glue code for q16 cosine function. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>cos(x)</li>
<li>cos(x) </li>
</ul>
<h3 id="function-plp_cos_q16s_rv32im">function plp_cos_q16s_rv32im</h3>
<pre><code class="language-cpp">int16_t plp_cos_q16s_rv32im(
    int16_t x
)
</code></pre>
<p>q16 cosine function for RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>cos(x)</li>
<li>cos(x) </li>
</ul>
<h3 id="function-plp_cos_q16s_xpulpv2">function plp_cos_q16s_xpulpv2</h3>
<pre><code class="language-cpp">int16_t plp_cos_q16s_xpulpv2(
    int16_t x
)
</code></pre>
<p>q16 cosine function for XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>cos(x)</li>
<li>cos(x) </li>
</ul>
<h3 id="function-plp_cos_f32">function plp_cos_f32</h3>
<pre><code class="language-cpp">float32_t plp_cos_f32(
    float32_t x
)
</code></pre>
<p>Glue code for f32 cosine function. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> input value in radians</li>
<li><strong>x</strong> input value in radians</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>cos(x)</li>
<li>cos(x) </li>
</ul>
<h3 id="function-plp_cos_f32s_xpulpv2">function plp_cos_f32s_xpulpv2</h3>
<pre><code class="language-cpp">float32_t plp_cos_f32s_xpulpv2(
    float32_t x
)
</code></pre>
<p>F32 cosine function for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> input value in radians</li>
<li><strong>x</strong> input value in radians</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>cos(x)</li>
<li>cos(x) </li>
</ul>
<p>F32 cosine function for XPULPV2.</p>
<h3 id="function-plp_sin_q32">function plp_sin_q32</h3>
<pre><code class="language-cpp">int32_t plp_sin_q32(
    int32_t x
)
</code></pre>
<p>Glue code for q32 sine function. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>sin(x)</li>
<li>sin(x) </li>
</ul>
<h3 id="function-plp_sin_q32s_rv32im">function plp_sin_q32s_rv32im</h3>
<pre><code class="language-cpp">int32_t plp_sin_q32s_rv32im(
    int32_t x
)
</code></pre>
<p>q32 sine function for RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>sin(x)</li>
<li>sin(x) </li>
</ul>
<h3 id="function-plp_sin_q32s_xpulpv2">function plp_sin_q32s_xpulpv2</h3>
<pre><code class="language-cpp">int32_t plp_sin_q32s_xpulpv2(
    int32_t x
)
</code></pre>
<p>q32 sine function for XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.31 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>sin(x)</li>
<li>sin(x) </li>
</ul>
<h3 id="function-plp_sin_q16">function plp_sin_q16</h3>
<pre><code class="language-cpp">int16_t plp_sin_q16(
    int16_t x
)
</code></pre>
<p>Glue code for q16 sine function. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>sin(x)</li>
<li>sin(x) </li>
</ul>
<h3 id="function-plp_sin_q16s_rv32im">function plp_sin_q16s_rv32im</h3>
<pre><code class="language-cpp">int16_t plp_sin_q16s_rv32im(
    int16_t x
)
</code></pre>
<p>q16 sine function for RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>sin(x)</li>
<li>sin(x) </li>
</ul>
<h3 id="function-plp_sin_q16s_xpulpv2">function plp_sin_q16s_xpulpv2</h3>
<pre><code class="language-cpp">int16_t plp_sin_q16s_xpulpv2(
    int16_t x
)
</code></pre>
<p>q16 sine function for XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
<li><strong>x</strong> Scaled input value: Q1.15 value in range [0, +0.9999] and is mapped to [0, 2*PI)</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>sin(x)</li>
<li>sin(x) </li>
</ul>
<h3 id="function-plp_sin_f32">function plp_sin_f32</h3>
<pre><code class="language-cpp">float32_t plp_sin_f32(
    float32_t x
)
</code></pre>
<p>Glue code for f32 sine function. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> input value in radians</li>
<li><strong>x</strong> input value in radians</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>sin(x)</li>
<li>sin(x) </li>
</ul>
<h3 id="function-plp_sin_f32s_xpulpv2">function plp_sin_f32s_xpulpv2</h3>
<pre><code class="language-cpp">float32_t plp_sin_f32s_xpulpv2(
    float32_t x
)
</code></pre>
<p>F32 sine function for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>x</strong> input value in radians</li>
<li><strong>x</strong> input value in radians</li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>sin(x)</li>
<li>sin(x) </li>
</ul>
<h3 id="function-plp_correlate_i32">function plp_correlate_i32</h3>
<pre><code class="language-cpp">void plp_correlate_i32(
    const int32_t * pSrcA,
    const uint32_t srcALen,
    const int32_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for correlation of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_i32s_rv32im">function plp_correlate_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_correlate_i32s_rv32im(
    const int32_t * pSrcA,
    const uint32_t srcALen,
    const int32_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 32-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_correlate_i32s_xpulpv2">function plp_correlate_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_correlate_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const uint32_t srcALen,
    const int32_t *__restrict__ pSrcB,
    const uint32_t srcBLen,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Correlation of 32-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_i16">function plp_correlate_i16</h3>
<pre><code class="language-cpp">void plp_correlate_i16(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for correlation of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_i16s_xpulpv2">function plp_correlate_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_correlate_i16s_xpulpv2(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 16-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_correlate_i16s_rv32im">function plp_correlate_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_correlate_i16s_rv32im(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 16-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_correlate_i8">function plp_correlate_i8</h3>
<pre><code class="language-cpp">void plp_correlate_i8(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for correlation of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_valid_i8">function plp_correlate_valid_i8</h3>
<pre><code class="language-cpp">void plp_correlate_valid_i8(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for correlation (valid) of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_i8s_xpulpv2">function plp_correlate_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_correlate_i8s_xpulpv2(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 8-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_correlate_i8s_rv32im">function plp_correlate_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_correlate_i8s_rv32im(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 8-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_correlate_q32">function plp_correlate_q32</h3>
<pre><code class="language-cpp">void plp_correlate_q32(
    const int32_t * pSrcA,
    const uint32_t srcALen,
    const int32_t * pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t * pRes
)
</code></pre>
<p>Glue code for correlation of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_q32s_rv32im">function plp_correlate_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_correlate_q32s_rv32im(
    const int32_t * pSrcA,
    const uint32_t srcALen,
    const int32_t * pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 32-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Correlation of 32-bit integer vectors kernel for RV32IM extension.</p>
<h3 id="function-plp_correlate_q32s_xpulpv2">function plp_correlate_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_correlate_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const uint32_t srcALen,
    const int32_t *__restrict__ pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Correlation of 32-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_q16">function plp_correlate_q16</h3>
<pre><code class="language-cpp">void plp_correlate_q16(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t * pRes
)
</code></pre>
<p>Glue code for correlation of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_q16s_xpulpv2">function plp_correlate_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_correlate_q16s_xpulpv2(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 16-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Correlation of 16-bit integer vectors kernel for XPULPV2 extension.</p>
<h3 id="function-plp_correlate_q16s_rv32im">function plp_correlate_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_correlate_q16s_rv32im(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 16-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Correlation of 16-bit integer vectors kernel for RV32IM extension.</p>
<h3 id="function-plp_correlate_q8">function plp_correlate_q8</h3>
<pre><code class="language-cpp">void plp_correlate_q8(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t * pRes
)
</code></pre>
<p>Glue code for correlation of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_valid_q8">function plp_correlate_valid_q8</h3>
<pre><code class="language-cpp">void plp_correlate_valid_q8(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t * pRes
)
</code></pre>
<p>Glue code for correlation (valid) of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_correlate_q8s_xpulpv2">function plp_correlate_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_correlate_q8s_xpulpv2(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 8-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Correlation of 8-bit integer vectors kernel for XPULPV2 extension.</p>
<h3 id="function-plp_correlate_q8s_rv32im">function plp_correlate_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_correlate_q8s_rv32im(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    const uint32_t fracBits,
    int32_t * pRes
)
</code></pre>
<p>Correlation of 8-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> ocdutput result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Correlation of 8-bit integer vectors kernel for RV32IM extension.</p>
<h3 id="function-plp_conv_i32">function plp_conv_i32</h3>
<pre><code class="language-cpp">void plp_conv_i32(
    const int32_t * pSrcA,
    const uint32_t srcALen,
    const int32_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for convolution of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_conv_valid_i32">function plp_conv_valid_i32</h3>
<pre><code class="language-cpp">void plp_conv_valid_i32(
    const int32_t * pSrcA,
    const uint32_t srcALen,
    const int32_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for convolution (valid) of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> ength of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here, of size |srcALen - srcBLen| + 1 </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for convolution (valid) of 32-bit integer vectors.</p>
<h3 id="function-plp_conv_i32s_rv32im">function plp_conv_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_conv_i32s_rv32im(
    const int32_t * pSrcA,
    const uint32_t srcALen,
    const int32_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Convolution of 32-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_i32s_xpulpv2">function plp_conv_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const uint32_t srcALen,
    const int32_t *__restrict__ pSrcB,
    const uint32_t srcBLen,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Convolution of 32-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_conv_valid_i32s_xpulpv2">function plp_conv_valid_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_valid_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const uint32_t srcALen,
    const int32_t *__restrict__ pSrcB,
    const uint32_t srcBLen,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Convolution (valid) of 32-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<hr />
<h3 id="function-plp_conv_i16">function plp_conv_i16</h3>
<pre><code class="language-cpp">void plp_conv_i16(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for convolution of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_valid_i16">function plp_conv_valid_i16</h3>
<pre><code class="language-cpp">void plp_conv_valid_i16(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for convolution (valid) of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> ength of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here, of size |srcALen - srcBLen| + 1 </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for convolution (valid) of 16-bit integer vectors.</p>
<h3 id="function-plp_conv_valid_rep_i16">function plp_conv_valid_rep_i16</h3>
<pre><code class="language-cpp">void plp_conv_valid_rep_i16(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for convolution (valid with replication) of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector, must be on L2 </li>
<li><strong>srcALen</strong> ength of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector, must be on L2 </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here, of size |srcALen - srcBLen| + 1, preferably in L1 </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for convolution (valid with replication) of 16-bit integer vectors.</p>
<h3 id="function-plp_conv_i16s_xpulpv2">function plp_conv_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_i16s_xpulpv2(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Convolution of 16-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_valid_i16s_xpulpv2">function plp_conv_valid_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_valid_i16s_xpulpv2(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Convolution (valid) of 16-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Convolution (valid) of 16-bit integer vectors kernel for XPULPV2 extension.</p>
<h3 id="function-plp_conv_valid_rep_i16s_xpulpv2">function plp_conv_valid_rep_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_valid_rep_i16s_xpulpv2(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const uint32_t srcAMem,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Convolution (valid with data replication) of 16-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector of the replicated data </li>
<li><strong>srcALen</strong> Number of elements in (unreplicated) vector a </li>
<li><strong>srcAMem</strong> Number of elements between each replication </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector of the replicated data </li>
<li><strong>srcALen</strong> Number of elements in (unreplicated) vector a </li>
<li><strong>srcAMem</strong> Number of elements between each replication </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Convolution (valid with data replication) of 16-bit integer vectors kernel for XPULPV2 extension.</p>
<h3 id="function-plp_conv_i16s_rv32im">function plp_conv_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_conv_i16s_rv32im(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Convolution of 16-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_i8">function plp_conv_i8</h3>
<pre><code class="language-cpp">void plp_conv_i8(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for convolution of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_valid_i8">function plp_conv_valid_i8</h3>
<pre><code class="language-cpp">void plp_conv_valid_i8(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for convolution (valid) of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> ength of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here, of size |srcALen - srcBLen| + 1 </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for convolution (valid) of 8-bit integer vectors.</p>
<h3 id="function-plp_conv_valid_rep_i8">function plp_conv_valid_rep_i8</h3>
<pre><code class="language-cpp">void plp_conv_valid_rep_i8(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Glue code for convolution (valid with data replication) of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector (in L2) </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector (in L2) </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here (preferably in L1) </li>
<li><strong>pSrcA</strong> points to the first input vector, must be on L2 </li>
<li><strong>srcALen</strong> ength of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector, must be on L2 </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here, of size |srcALen - srcBLen| + 1, preferably in L1 </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for convolution (valid with data replication) of 8-bit integer vectors.</p>
<h3 id="function-plp_conv_i8s_xpulpv2">function plp_conv_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_i8s_xpulpv2(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Convolution of 8-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_valid_i8s_xpulpv2">function plp_conv_valid_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_valid_i8s_xpulpv2(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Convolution (valid) of 8-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Convolution (valid) of 8-bit integer vectors kernel for XPULPV2 extension.</p>
<h3 id="function-plp_conv_valid_rep_i8s_xpulpv2">function plp_conv_valid_rep_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_valid_rep_i8s_xpulpv2(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const uint32_t srcAMem,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Convolution (valid with data replication) of 8-bit integer vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector of the replicated data </li>
<li><strong>srcALen</strong> Number of elements in (unreplicated) vector a </li>
<li><strong>srcAMem</strong> Number of elements between each replication </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector of the replicated data </li>
<li><strong>srcALen</strong> Number of elements in (unreplicated) vector a </li>
<li><strong>srcAMem</strong> Number of elements between each replication </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Convolution (valid with data replication) of 8-bit integer vectors kernel for XPULPV2 extension.</p>
<h3 id="function-plp_conv_i8s_rv32im">function plp_conv_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_conv_i8s_rv32im(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    int32_t * pRes
)
</code></pre>
<p>Convolution of 8-bit integer vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_i32_parallel">function plp_conv_i32_parallel</h3>
<pre><code class="language-cpp">void plp_conv_i32_parallel(
    const int32_t * pSrcA,
    const uint32_t srcALen,
    const int32_t * pSrcB,
    const uint32_t srcBLen,
    const uint8_t nPE,
    int32_t * pRes
)
</code></pre>
<p>Glue code for parallel convolution of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>nPE</strong> Number of cores to compute on </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>nPE</strong> Number of cores to compute on </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_i32p_xpulpv2">function plp_conv_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_i32p_xpulpv2(
    void * task_args
)
</code></pre>
<p>Setup code for parallel convolution of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>task_args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__conv__instance__i32/">plp_conv_instance_i32</a> struct initialized by plp_conv_i32_parallel </li>
<li><strong>task_args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__conv__instance__i32/">plp_conv_instance_i32</a> struct initialized by plp_conv_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Setup code for parallel convolution of 32-bit integer vectors.</p>
<h3 id="function-plp_conv_i16_parallel">function plp_conv_i16_parallel</h3>
<pre><code class="language-cpp">void plp_conv_i16_parallel(
    const int16_t * pSrcA,
    const uint32_t srcALen,
    const int16_t * pSrcB,
    const uint32_t srcBLen,
    const uint8_t nPE,
    int32_t * pRes
)
</code></pre>
<p>Glue code for parallel convolution of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>nPE</strong> Number of cores to compute on </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>nPE</strong> Number of cores to compute on </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_i16p_xpulpv2">function plp_conv_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_i16p_xpulpv2(
    void * task_args
)
</code></pre>
<p>Setup code for parallel convolution of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>task_args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__conv__instance__i16/">plp_conv_instance_i16</a> struct initialized by plp_conv_i16_parallel </li>
<li><strong>task_args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__conv__instance__i16/">plp_conv_instance_i16</a> struct initialized by plp_conv_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Setup code for parallel convolution of 16-bit integer vectors.</p>
<h3 id="function-plp_conv_i8_parallel">function plp_conv_i8_parallel</h3>
<pre><code class="language-cpp">void plp_conv_i8_parallel(
    const int8_t * pSrcA,
    const uint32_t srcALen,
    const int8_t * pSrcB,
    const uint32_t srcBLen,
    const uint8_t nPE,
    int32_t * pRes
)
</code></pre>
<p>Glue code for parallel convolution of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>nPE</strong> Number of cores to compute on </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>srcALen</strong> Length of the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>srcBLen</strong> Length of the second input vector </li>
<li><strong>nPE</strong> Number of cores to compute on </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_i8p_xpulpv2">function plp_conv_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_conv_i8p_xpulpv2(
    void * task_args
)
</code></pre>
<p>Setup code for parallel convolution of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>task_args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__conv__instance__i8/">plp_conv_instance_i8</a> struct initialized by plp_conv_i8_parallel </li>
<li><strong>task_args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__conv__instance__i8/">plp_conv_instance_i8</a> struct initialized by plp_conv_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Setup code for parallel convolution of 8-bit integer vectors.</p>
<h3 id="function-plp_conv_parallel_ola">function plp_conv_parallel_OLA</h3>
<pre><code class="language-cpp">void plp_conv_parallel_OLA(
    uint32_t nPE,
    uint32_t srcALen,
    uint32_t srcBLen,
    int32_t * resultsBuffer
)
</code></pre>
<p>Helper function for parallelized overlap-adding of partial convolution results. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>nPE</strong> Number of processing cores </li>
<li><strong>srcALen</strong> Length of the first original input vector </li>
<li><strong>srcBLen</strong> Length of the second original input vector </li>
<li><strong>resultsBuffer</strong> resultsBuffer array from plp_conv_i[XX]_parallel </li>
<li><strong>nPE</strong> Number of processing cores </li>
<li><strong>srcALen</strong> Length of the first original input vector </li>
<li><strong>srcBLen</strong> Length of the second original input vector </li>
<li><strong>resultsBuffer</strong> resultsBuffer array from plp_conv_i[XX]_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_conv_parallel_ola_kernel">function plp_conv_parallel_OLA_kernel</h3>
<pre><code class="language-cpp">void plp_conv_parallel_OLA_kernel(
    void * task_args
)
</code></pre>
<p>Helper function for parallelized overlap-adding of partial convolution results. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>task_args</strong> Holds the <a href="/pulp-dsp/refmanual/Classes/structplp__conv__tree__add__instance/">plp_conv_tree_add_instance</a> that describes the vector parameters </li>
<li><strong>task_args</strong> Holds the <a href="/pulp-dsp/refmanual/Classes/structplp__conv__tree__add__instance/">plp_conv_tree_add_instance</a> that describes the vector parameters </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_i32">function plp_mat_mult_i32</h3>
<pre><code class="language-cpp">void plp_mat_mult_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix matrix multiplication of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix matrix multiplication of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_i32s_rv32im">function plp_mat_mult_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Matrix matrix multiplication of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_i32s_xpulpv2">function plp_mat_mult_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_i16">function plp_mat_mult_i16</h3>
<pre><code class="language-cpp">void plp_mat_mult_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix matrix multiplication of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix matrix multiplication of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_i16s_rv32im">function plp_mat_mult_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Matrix matrix multiplication of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_i16s_xpulpv2">function plp_mat_mult_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>Matrix matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_i8">function plp_mat_mult_i8</h3>
<pre><code class="language-cpp">void plp_mat_mult_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix matrix multiplication of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix matrix multiplication of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_i8s_rv32im">function plp_mat_mult_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Matrix matrix multiplication of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_i8s_xpulpv2">function plp_mat_mult_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
</ul>
<p><strong>Return</strong>: none</p>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_i32_parallel">function plp_mat_mult_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix matrix multiplication of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix matrix multiplication of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_i32p_xpulpv2">function plp_mat_mult_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i32/">plp_mat_mult_instance_i32</a> struct initialized by plp_mat_mult_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i32/">plp_mat_mult_instance_i32</a> struct initialized by plp_mat_mult_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_i16_parallel">function plp_mat_mult_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix matrix multiplication of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix matrix multiplication of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_i16p_xpulpv2">function plp_mat_mult_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 16-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i16/">plp_mat_mult_instance_i16</a> struct initialized by plp_mat_mult_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i16/">plp_mat_mult_instance_i16</a> struct initialized by plp_mat_mult_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_i8_parallel">function plp_mat_mult_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix matrix multiplication of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix matrix multiplication of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_f32">function plp_mat_mult_f32</h3>
<pre><code class="language-cpp">void plp_mat_mult_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix matrix multiplication of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix matrix multiplication of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_mult_f32s_xpulpv2">function plp_mat_mult_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    float *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Matrix matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_f32_parallel">function plp_mat_mult_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix matrix multiplication of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix matrix multiplication of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_mult_f32p_xpulpv2">function plp_mat_mult_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__f32/">plp_mat_mult_instance_f32</a> struct initialized by plp_mat_mult_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__f32/">plp_mat_mult_instance_f32</a> struct initialized by plp_mat_mult_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_i8p_xpulpv2">function plp_mat_mult_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 8-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i8/">plp_mat_mult_instance_i8</a> struct initialized by plp_mat_mult_i8_parallel </li>
</ul>
<p><strong>Return</strong>: none</p>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_q32">function plp_mat_mult_q32</h3>
<pre><code class="language-cpp">void plp_mat_mult_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix matrix multiplication of a 32-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Glue code for matrix matrix multiplication of a 32-bit fix-point matrices.</p>
<h3 id="function-plp_mat_mult_q32_parallel">function plp_mat_mult_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix matrix multiplication of a 32-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Glue code for parallel matrix matrix multiplication of a 32-bit fix-point matrices.</p>
<h3 id="function-plp_mat_mult_q32s_rv32im">function plp_mat_mult_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 32-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Matrix matrix multiplication of a 32-bit fix-point matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_q32s_xpulpv2">function plp_mat_mult_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Matrix matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_q32p_xpulpv2">function plp_mat_mult_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q32/">plp_mat_mult_instance_q32</a> struct initialized by plp_mat_mult_q32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q32/">plp_mat_mult_instance_q32</a> struct initialized by plp_mat_mult_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Parallel matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_q16">function plp_mat_mult_q16</h3>
<pre><code class="language-cpp">void plp_mat_mult_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix matrix multiplication of a 16-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for matrix matrix multiplication of a 16-bit fix-point matrices.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_q16_parallel">function plp_mat_mult_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_q16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix matrix multiplication of a 16-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for parallel matrix matrix multiplication of a 16-bit fix-point matrices.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_q16s_rv32im">function plp_mat_mult_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 16-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Matrix matrix multiplication of a 16-bit fix-point matrices for RV32IM extension.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_q16s_xpulpv2">function plp_mat_mult_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Matrix matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_q16p_xpulpv2">function plp_mat_mult_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q16/">plp_mat_mult_instance_q16</a> struct initialized by plp_mat_mult_q16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q16/">plp_mat_mult_instance_q16</a> struct initialized by plp_mat_mult_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>Parallel matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_q8">function plp_mat_mult_q8</h3>
<pre><code class="language-cpp">void plp_mat_mult_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix matrix multiplication of a 8-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for matrix matrix multiplication of a 8-bit fix-point matrices.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_q8_parallel">function plp_mat_mult_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_q8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix matrix multiplication of a 8-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for parallel matrix matrix multiplication of a 8-bit fix-point matrices.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_q8s_rv32im">function plp_mat_mult_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_q8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 8-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Matrix matrix multiplication of a 8-bit fix-point matrices for RV32IM extension.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_q8s_xpulpv2">function plp_mat_mult_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_q8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Matrix matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_q8p_xpulpv2">function plp_mat_mult_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q8/">plp_mat_mult_instance_q8</a> struct initialized by plp_mat_mult_q8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q8/">plp_mat_mult_instance_q8</a> struct initialized by plp_mat_mult_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>Parallel matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_cmplx_i32">function plp_mat_mult_cmplx_i32</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix matrix multiplication for complex 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i32s_rv32im">function plp_mat_mult_cmplx_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 32-bit integers on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i32s_xpulpv2">function plp_mat_mult_cmplx_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 32-bit integers on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i32_parallel">function plp_mat_mult_cmplx_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix matrix multiplication for complex 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i32p_xpulpv2">function plp_mat_mult_cmplx_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix matrix multiplication for complex 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__i32/">plp_mat_mult_cmplx_instance_i32</a> struct initialized by plp_mat_mult_cmplx_i32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_i32 struct initialized by plp_mat_mult_cmplx_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i16">function plp_mat_mult_cmplx_i16</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix matrix multiplication for complex 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i16s_rv32im">function plp_mat_mult_cmplx_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 16-bit integers on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i16s_xpulpv2">function plp_mat_mult_cmplx_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 16-bit integers on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i16_parallel">function plp_mat_mult_cmplx_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix matrix multiplication for complex 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i16p_xpulpv2">function plp_mat_mult_cmplx_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix matrix multiplication for complex 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__i16/">plp_mat_mult_cmplx_instance_i16</a> struct initialized by plp_mat_mult_cmplx_i16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_i16 struct initialized by plp_mat_mult_cmplx_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i8">function plp_mat_mult_cmplx_i8</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix matrix multiplication for complex 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i8s_rv32im">function plp_mat_mult_cmplx_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 8-bit integers on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i8s_xpulpv2">function plp_mat_mult_cmplx_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 8-bit integers on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i8_parallel">function plp_mat_mult_cmplx_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix matrix multiplication for complex 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_i8p_xpulpv2">function plp_mat_mult_cmplx_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix matrix multiplication for complex 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__i8/">plp_mat_mult_cmplx_instance_i8</a> struct initialized by plp_mat_mult_cmplx_i8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_i8 struct initialized by plp_mat_mult_cmplx_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_f32">function plp_mat_mult_cmplx_f32</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix matrix multiplication for complex 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_f32s_xpulpv2">function plp_mat_mult_cmplx_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    float *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 32-bit floats on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_f32_parallel">function plp_mat_mult_cmplx_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix matrix multiplication for complex 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_f32p_xpulpv2">function plp_mat_mult_cmplx_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix matrix multiplication for complex 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__f32/">plp_mat_mult_cmplx_instance_f32</a> struct initialized by plp_mat_mult_cmplx_f32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_f32 struct initialized by plp_mat_mult_cmplx_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q32">function plp_mat_mult_cmplx_q32</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix matrix multiplication for complex 32-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q32s_rv32im">function plp_mat_mult_cmplx_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 32-bit fix-point on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q32s_xpulpv2">function plp_mat_mult_cmplx_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 32-bit fix-point on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q32_parallel">function plp_mat_mult_cmplx_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix matrix multiplication for complex 32-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q32p_xpulpv2">function plp_mat_mult_cmplx_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix matrix multiplication for complex 32-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__q32/">plp_mat_mult_cmplx_instance_q32</a> struct initialized by plp_mat_mult_cmplx_q32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_q32 struct initialized by plp_mat_mult_cmplx_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q16">function plp_mat_mult_cmplx_q16</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix matrix multiplication for complex 16-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q16s_rv32im">function plp_mat_mult_cmplx_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 16-bit fix-point on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q16s_xpulpv2">function plp_mat_mult_cmplx_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 16-bit fix-point on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q16_parallel">function plp_mat_mult_cmplx_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix matrix multiplication for complex 16-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q16p_xpulpv2">function plp_mat_mult_cmplx_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix matrix multiplication for complex 16-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__q16/">plp_mat_mult_cmplx_instance_q16</a> struct initialized by plp_mat_mult_cmplx_q16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_q16 struct initialized by plp_mat_mult_cmplx_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q8">function plp_mat_mult_cmplx_q8</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix matrix multiplication for complex 8-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q8s_rv32im">function plp_mat_mult_cmplx_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 8-bit fix-point on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q8s_xpulpv2">function plp_mat_mult_cmplx_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix matrix multiplication for complex 8-bit fix-point on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q8_parallel">function plp_mat_mult_cmplx_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix matrix multiplication for complex 8-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_q8p_xpulpv2">function plp_mat_mult_cmplx_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix matrix multiplication for complex 8-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__q8/">plp_mat_mult_cmplx_instance_q8</a> struct initialized by plp_mat_mult_cmplx_q8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_q8 struct initialized by plp_mat_mult_cmplx_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_i32">function plp_mat_mult_trans_i32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix transposed matrix multiplication of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix transposed matrix multiplication of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_i32s_rv32im">function plp_mat_mult_trans_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_trans_i32s_xpulpv2">function plp_mat_mult_trans_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix transposed matrix multiplication of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Matrix transposed matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_i16">function plp_mat_mult_trans_i16</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix transposed matrix multiplication of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix transposed matrix multiplication of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_i16s_rv32im">function plp_mat_mult_trans_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix transposed matrix multiplication of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Matrix transposed matrix multiplication of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_trans_i16s_xpulpv2">function plp_mat_mult_trans_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>Matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_i8">function plp_mat_mult_trans_i8</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix transposed matrix multiplication of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix transposed matrix multiplication of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_i8s_rv32im">function plp_mat_mult_trans_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix transposed matrix multiplication of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Matrix transposed matrix multiplication of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_trans_i8s_xpulpv2">function plp_mat_mult_trans_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>Matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_i32_parallel">function plp_mat_mult_trans_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix matrix multiplication of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix matrix multiplication of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_i32p_xpulpv2">function plp_mat_mult_trans_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i32/">plp_mat_mult_instance_i32</a> struct initialized by plp_mat_mult_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i32/">plp_mat_mult_instance_i32</a> struct initialized by plp_mat_mult_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_i16_parallel">function plp_mat_mult_trans_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix transposed matrix multiplication of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix transposed matrix multiplication of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_i16p_xpulpv2">function plp_mat_mult_trans_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i16/">plp_mat_mult_instance_i16</a> struct initialized by plp_mat_mult_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i16/">plp_mat_mult_instance_i16</a> struct initialized by plp_mat_mult_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_i8_parallel">function plp_mat_mult_trans_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix transposed matrix multiplication of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix transposed matrix multiplication of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_i8p_xpulpv2">function plp_mat_mult_trans_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i8/">plp_mat_mult_instance_i8</a> struct initialized by plp_mat_mult_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__i8/">plp_mat_mult_instance_i8</a> struct initialized by plp_mat_mult_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_q32">function plp_mat_mult_trans_q32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix transposed matrix multiplication of a 32-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Glue code for matrix transposed matrix multiplication of a 32-bit fix-point matrices.</p>
<h3 id="function-plp_mat_mult_trans_q32_parallel">function plp_mat_mult_trans_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix transposed matrix multiplication of a 32-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Glue code for parallel matrix transposed matrix multiplication of a 32-bit fix-point matrices.</p>
<h3 id="function-plp_mat_mult_trans_q32s_rv32im">function plp_mat_mult_trans_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transposed matrix multiplication of a 32-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>matrix transposed matrix multiplication of a 32-bit fix-point matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_trans_q32s_xpulpv2">function plp_mat_mult_trans_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transposed matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>matrix transposed matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_q32p_xpulpv2">function plp_mat_mult_trans_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transposed matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q32/">plp_mat_mult_instance_q32</a> struct initialized by plp_mat_mult_trans_q32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q32/">plp_mat_mult_instance_q32</a> struct initialized by plp_mat_mult_trans_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Parallel matrix transposed matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_q16">function plp_mat_mult_trans_q16</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix transposed matrix multiplication of a 16-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for matrix transposed matrix multiplication of a 16-bit fix-point matrices.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_q16_parallel">function plp_mat_mult_trans_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix transposed matrix multiplication of a 16-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for parallel matrix transposed matrix multiplication of a 16-bit fix-point matrices.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_q16s_rv32im">function plp_mat_mult_trans_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transposed matrix multiplication of a 16-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>matrix transposed matrix multiplication of a 16-bit fix-point matrices for RV32IM extension.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_q16s_xpulpv2">function plp_mat_mult_trans_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transposed matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>matrix transposed matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_q16p_xpulpv2">function plp_mat_mult_trans_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transposed matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q16/">plp_mat_mult_instance_q16</a> struct initialized by plp_mat_mult_trans_q16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q16/">plp_mat_mult_instance_q16</a> struct initialized by plp_mat_mult_trans_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>Parallel matrix transposed matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension.</p>
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_q8">function plp_mat_mult_trans_q8</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix transposed matrix multiplication of a 8-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for matrix transposed matrix multiplication of a 8-bit fix-point matrices.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_q8_parallel">function plp_mat_mult_trans_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix transposed matrix multiplication of a 8-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for parallel matrix transposed matrix multiplication of a 8-bit fix-point matrices.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_q8s_rv32im">function plp_mat_mult_trans_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transposed matrix multiplication of a 8-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>matrix transposed matrix multiplication of a 8-bit fix-point matrices for RV32IM extension.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_q8s_xpulpv2">function plp_mat_mult_trans_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transposed matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>matrix transposed matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_q8p_xpulpv2">function plp_mat_mult_trans_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transposed matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q8/">plp_mat_mult_instance_q8</a> struct initialized by plp_mat_mult_trans_q8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__q8/">plp_mat_mult_instance_q8</a> struct initialized by plp_mat_mult_trans_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>Parallel matrix transposed matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension.</p>
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_f32">function plp_mat_mult_trans_f32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code for matrix transposed matrix multiplication of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix transposed matrix multiplication of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_mult_trans_f32s_xpulpv2">function plp_mat_mult_trans_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    float *__restrict__ pDstC
)
</code></pre>
<p>matrix transposed matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transposed matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_f32_parallel">function plp_mat_mult_trans_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel matrix transposed matrix multiplication of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix, stored transposed in memory </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix transposed matrix multiplication of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_mult_trans_f32p_xpulpv2">function plp_mat_mult_trans_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transposed matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__f32/">plp_mat_mult_instance_f32</a> struct initialized by plp_mat_mult_trans_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__instance__f32/">plp_mat_mult_instance_f32</a> struct initialized by plp_mat_mult_trans_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix transposed matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_cmplx_i32">function plp_mat_mult_trans_cmplx_i32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix transpose matrix multiplication for complex 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_i32s_rv32im">function plp_mat_mult_trans_cmplx_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 32-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transpose matrix multiplication for complex 32-bit integers on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_i32s_xpulpv2">function plp_mat_mult_trans_cmplx_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_i32_parallel">function plp_mat_mult_trans_cmplx_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix transpose matrix multiplication for complex 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_i32p_xpulpv2">function plp_mat_mult_trans_cmplx_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__i32/">plp_mat_mult_cmplx_instance_i32</a> struct initialized by plp_mat_mult_trans_cmplx_i32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_i32 struct initialized by plp_mat_mult_trans_cmplx_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_i16">function plp_mat_mult_trans_cmplx_i16</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix transpose matrix multiplication for complex 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_i16s_rv32im">function plp_mat_mult_trans_cmplx_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 16-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transpose matrix multiplication for complex 16-bit integers on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_i16s_xpulpv2">function plp_mat_mult_trans_cmplx_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_i16_parallel">function plp_mat_mult_trans_cmplx_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix transpose matrix multiplication for complex 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_i16p_xpulpv2">function plp_mat_mult_trans_cmplx_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__i16/">plp_mat_mult_cmplx_instance_i16</a> struct initialized by plp_mat_mult_trans_cmplx_i16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_i16 struct initialized by plp_mat_mult_trans_cmplx_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_i8">function plp_mat_mult_trans_cmplx_i8</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix transpose matrix multiplication for complex 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_i8s_rv32im">function plp_mat_mult_trans_cmplx_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 8-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transpose matrix multiplication for complex 8-bit integers on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_i8s_xpulpv2">function plp_mat_mult_trans_cmplx_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_i8_parallel">function plp_mat_mult_trans_cmplx_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix transpose matrix multiplication for complex 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_i8p_xpulpv2">function plp_mat_mult_trans_cmplx_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__i8/">plp_mat_mult_cmplx_instance_i8</a> struct initialized by plp_mat_mult_trans_cmplx_i8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_i8 struct initialized by plp_mat_mult_trans_cmplx_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_f32">function plp_mat_mult_trans_cmplx_f32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix transpose matrix multiplication for complex 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_f32s_xpulpv2">function plp_mat_mult_trans_cmplx_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    float *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_f32_parallel">function plp_mat_mult_trans_cmplx_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t nPE,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix transpose matrix multiplication for complex 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_f32p_xpulpv2">function plp_mat_mult_trans_cmplx_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__f32/">plp_mat_mult_cmplx_instance_f32</a> struct initialized by plp_mat_mult_trans_cmplx_f32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_f32 struct initialized by plp_mat_mult_trans_cmplx_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_q32">function plp_mat_mult_trans_cmplx_q32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix transpose matrix multiplication for complex 32-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_q32s_rv32im">function plp_mat_mult_trans_cmplx_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 32-bit fix-point on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>matrix transpose matrix multiplication for complex 32-bit fix-point on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_q32s_xpulpv2">function plp_mat_mult_trans_cmplx_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_q32_parallel">function plp_mat_mult_trans_cmplx_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix transpose matrix multiplication for complex 32-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_q32p_xpulpv2">function plp_mat_mult_trans_cmplx_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__q32/">plp_mat_mult_cmplx_instance_q32</a> struct initialized by plp_mat_mult_trans_cmplx_q32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_q32 struct initialized by plp_mat_mult_trans_cmplx_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_q16">function plp_mat_mult_trans_cmplx_q16</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix transpose matrix multiplication for complex 16-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_q16s_rv32im">function plp_mat_mult_trans_cmplx_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 16-bit fix-point on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>matrix transpose matrix multiplication for complex 16-bit fix-point on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_q16s_xpulpv2">function plp_mat_mult_trans_cmplx_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_q16_parallel">function plp_mat_mult_trans_cmplx_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix transpose matrix multiplication for complex 16-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_q16p_xpulpv2">function plp_mat_mult_trans_cmplx_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__q16/">plp_mat_mult_cmplx_instance_q16</a> struct initialized by plp_mat_mult_trans_cmplx_q16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_q16 struct initialized by plp_mat_mult_trans_cmplx_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_q8">function plp_mat_mult_trans_cmplx_q8</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of matrix transpose matrix multiplication for complex 8-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_q8s_rv32im">function plp_mat_mult_trans_cmplx_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 8-bit fix-point on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>matrix transpose matrix multiplication for complex 8-bit fix-point on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_q8s_xpulpv2">function plp_mat_mult_trans_cmplx_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_q8_parallel">function plp_mat_mult_trans_cmplx_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel matrix transpose matrix multiplication for complex 8-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_q8p_xpulpv2">function plp_mat_mult_trans_cmplx_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__instance__q8/">plp_mat_mult_cmplx_instance_q8</a> struct initialized by plp_mat_mult_trans_cmplx_q8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_q8 struct initialized by plp_mat_mult_trans_cmplx_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_cmplx_mag_f32">function plp_cmplx_mag_f32</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_f32(
    const float32_t * pSrc,
    float32_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex magnitude calculation in float32. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_f32s_xpulpv2">function plp_cmplx_mag_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_f32s_xpulpv2(
    const float32_t * pSrc,
    float32_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for float32 on XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_q32">function plp_cmplx_mag_q32</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_q32(
    const int32_t * pSrc,
    const uint32_t fracBits,
    int32_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex magnitude calculation for 32 bit fixpoint. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_q32s_rv32im">function plp_cmplx_mag_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_q32s_rv32im(
    const int32_t * pSrc,
    const uint32_t fracBits,
    int32_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for q32 on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_q32s_xpulpv2">function plp_cmplx_mag_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_q32s_xpulpv2(
    const int32_t * pSrc,
    const uint32_t fracBits,
    int32_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for q32 on XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_q8">function plp_cmplx_mag_q8</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_q8(
    const int8_t * pSrc,
    const uint32_t fracBits,
    int8_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex magnitude calculation for 8 bit fixpoint. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(8-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(8-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_q8s_rv32im">function plp_cmplx_mag_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_q8s_rv32im(
    const int8_t * pSrc,
    const uint32_t fracBits,
    int8_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for q8 on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(8-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(8-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_q8s_xpulpv2">function plp_cmplx_mag_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_q8s_xpulpv2(
    const int8_t * pSrc,
    const uint32_t fracBits,
    int8_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for q8 on XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(8-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(8-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_i16">function plp_cmplx_mag_i16</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_i16(
    const int16_t * pSrc,
    int16_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex magnitude calculation in 16-bit integer. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_i16s_rv32im">function plp_cmplx_mag_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_i16s_rv32im(
    const int16_t * pSrc,
    int16_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for i16 on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_i16s_xpulpv2">function plp_cmplx_mag_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_i16s_xpulpv2(
    const int16_t * pSrc,
    int16_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for i16 on XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_i32">function plp_cmplx_mag_i32</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_i32(
    const int32_t * pSrc,
    int32_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex magnitude calculation in 32-bit integer. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_i32s_rv32im">function plp_cmplx_mag_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_i32s_rv32im(
    const int32_t * pSrc,
    int32_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for i32 on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_i32s_xpulpv2">function plp_cmplx_mag_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_i32s_xpulpv2(
    const int32_t * pSrc,
    int32_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for i32 on XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_i8">function plp_cmplx_mag_i8</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_i8(
    const int8_t * pSrc,
    int8_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex magnitude calculation in 8-bit integer. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_i8s_rv32im">function plp_cmplx_mag_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_i8s_rv32im(
    const int8_t * pSrc,
    int8_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for i8 on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_i8s_xpulpv2">function plp_cmplx_mag_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_i8s_xpulpv2(
    const int8_t * pSrc,
    int8_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for i8 on XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_q16">function plp_cmplx_mag_q16</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_q16(
    const int16_t * pSrc,
    const uint32_t fracBits,
    int16_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex magnitude calculation in 16-bit quantized integer. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number of samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number of samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_q16s_rv32im">function plp_cmplx_mag_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_q16s_rv32im(
    const int16_t * pSrc,
    const uint32_t fracBits,
    int16_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for q16 on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number of samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number of samples </li>
</ul>
<h3 id="function-plp_cmplx_mag_q16s_xpulpv2">function plp_cmplx_mag_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_q16s_xpulpv2(
    const int16_t * pSrc,
    const uint32_t fracBits,
    int16_t * pRes,
    uint32_t numSamples
)
</code></pre>
<p>complex magnitude for q16 on XPULPV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number of samples</li>
<li><strong>pSrc</strong> pointer to source </li>
<li><strong>fracBits</strong> fractional bits -&gt; Q(32-fracBits).fracBits </li>
<li><strong>pRes</strong> pointer to result </li>
<li><strong>numSamples</strong> The number of samples </li>
</ul>
<h3 id="function-plp_bitreversal_16s_rv32im">function plp_bitreversal_16s_rv32im</h3>
<pre><code class="language-cpp">void plp_bitreversal_16s_rv32im(
    uint16_t * pSrc,
    const uint16_t bitRevLen,
    const uint16_t * pBitRevTab
)
</code></pre>
<p>In-place 16 bit reversal function for RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to in-place buffer of unknown 16-bit data type </li>
<li><strong>bitRevLen</strong> bit reversal table length </li>
<li><strong>pBitRevTab</strong> points to bit reversal table </li>
<li><strong>pSrc</strong> points to in-place buffer of unknown 16-bit data type </li>
<li><strong>bitRevLen</strong> bit reversal table length </li>
<li><strong>pBitRevTab</strong> points to bit reversal table </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>In-place 16 bit reversal function for RV32IM.</p>
<h3 id="function-plp_bitreversal_16s_xpulpv2">function plp_bitreversal_16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_bitreversal_16s_xpulpv2(
    uint16_t * pSrc,
    const uint16_t bitRevLen,
    const uint16_t * pBitRevTab
)
</code></pre>
<p>In-place 16 bit reversal function for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to in-place buffer of unknown 16-bit data type </li>
<li><strong>bitRevLen</strong> bit reversal table length </li>
<li><strong>pBitRevTab</strong> points to bit reversal table </li>
<li><strong>pSrc</strong> points to in-place buffer of unknown 16-bit data type </li>
<li><strong>bitRevLen</strong> bit reversal table length </li>
<li><strong>pBitRevTab</strong> points to bit reversal table </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>In-place 16 bit reversal function for XPULPV2.</p>
<h3 id="function-plp_bitreversal_16p_xpulpv2">function plp_bitreversal_16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_bitreversal_16p_xpulpv2(
    uint16_t * pSrc,
    const uint16_t bitRevLen,
    const uint16_t * pBitRevTab,
    uint32_t nPE
)
</code></pre>
<p>In-place 16 bit reversal function. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to in-place buffer of unknown 16-bit data type </li>
<li><strong>bitRevLen</strong> bit reversal table length </li>
<li><strong>pBitRevTab</strong> points to bit reversal table </li>
<li><strong>nPE</strong> number of cores </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cfft_q16">function plp_cfft_q16</h3>
<pre><code class="language-cpp">void plp_cfft_q16(
    const plp_cfft_instance_q16 * S,
    int16_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag,
    uint32_t deciPoint
)
</code></pre>
<p>Glue code for quantized 16 bit complex fast fourier transform. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the 16bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>deciPoint</strong> decimal point for right shift</li>
<li><strong>S</strong> points to an instance of the 16bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
</ul>
<p>Fixed point units input -&gt; output dependent on length: len=16: Q1.15 -&gt; Q5.11 len=32: Q1.15 -&gt; Q6.10 len=64: Q1.15 -&gt; Q7.9 len=128: Q1.15 -&gt; Q8.8 len=256: Q1.15 -&gt; Q9.7 len=512: Q1.15 -&gt; Q10.6 len=1024: Q1.15 -&gt; Q11.5 len=2048: Q1.15 -&gt; Q12.4 len=4096: Q1.15 -&gt; Q13.3</p>
<h3 id="function-plp_cfft_q16_parallel">function plp_cfft_q16_parallel</h3>
<pre><code class="language-cpp">void plp_cfft_q16_parallel(
    const plp_cfft_instance_q16 * S,
    int16_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag,
    uint32_t deciPoint,
    uint32_t nPE
)
</code></pre>
<p>Glue code for quantized 16 bit complex fast fourier transform. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the 16bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>nPE</strong> Number of cores to use</li>
<li><strong>S</strong> points to an instance of the 16bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>nPE</strong> Number of cores to use </li>
</ul>
<p>Fixed point units input -&gt; output dependent on length: len=16: Q1.15 -&gt; Q5.11 len=32: Q1.15 -&gt; Q6.10 len=64: Q1.15 -&gt; Q7.9 len=128: Q1.15 -&gt; Q8.8 len=256: Q1.15 -&gt; Q9.7 len=512: Q1.15 -&gt; Q10.6 len=1024: Q1.15 -&gt; Q11.5 len=2048: Q1.15 -&gt; Q12.4 len=4096: Q1.15 -&gt; Q13.3</p>
<p>Fixed point units input -&gt; output dependent on length: len=16: Q1.15 -&gt; Q5.11 len=32: Q1.15 -&gt; Q6.10 len=64: Q1.15 -&gt; Q7.9 len=128: Q1.15 -&gt; Q8.8 len=256: Q1.15 -&gt; Q9.7 len=512: Q1.15 -&gt; Q10.6 len=1024: Q1.15 -&gt; Q11.5 len=2048: Q1.15 -&gt; Q12.4 len=4096: Q1.15 -&gt; Q13.3</p>
<h3 id="function-plp_cfft_q16s_rv32im">function plp_cfft_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_cfft_q16s_rv32im(
    const plp_cfft_instance_q16 * S,
    int16_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag,
    uint32_t deciPoint
)
</code></pre>
<p>Quantized 16 bit complex fast fourier transform for RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the 16bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
</ul>
<h3 id="function-plp_cfft_q16s_xpulpv2">function plp_cfft_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cfft_q16s_xpulpv2(
    const plp_cfft_instance_q16 * S,
    int16_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag,
    uint32_t deciPoint
)
</code></pre>
<p>Quantized 16 bit complex fast fourier transform for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the 16bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
</ul>
<h3 id="function-plp_cfft_q16p_xpulpv2">function plp_cfft_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cfft_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel quantized 16 bit complex fast fourier transform for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q16__parallel/">plp_cfft_instance_q16_parallel</a></li>
</ul>
<h3 id="function-plp_bitreversal_32s_rv32im">function plp_bitreversal_32s_rv32im</h3>
<pre><code class="language-cpp">void plp_bitreversal_32s_rv32im(
    uint32_t * pSrc,
    const uint16_t bitRevLen,
    const uint16_t * pBitRevTab
)
</code></pre>
<p>In-place 32 bit reversal function for RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to in-place buffer of unknown 32-bit data type </li>
<li><strong>bitRevLen</strong> bit reversal table length </li>
<li><strong>pBitRevTab</strong> points to bit reversal table </li>
<li><strong>pSrc</strong> points to in-place buffer of unknown 32-bit data type </li>
<li><strong>bitRevLen</strong> bit reversal table length </li>
<li><strong>pBitRevTab</strong> points to bit reversal table </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>In-place 32 bit reversal function for RV32IM.</p>
<h3 id="function-plp_bitreversal_32s_xpulpv2">function plp_bitreversal_32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_bitreversal_32s_xpulpv2(
    uint32_t * pSrc,
    const uint16_t bitRevLen,
    const uint16_t * pBitRevTab
)
</code></pre>
<p>In-place 32 bit reversal function for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to in-place buffer of unknown 32-bit data type </li>
<li><strong>bitRevLen</strong> bit reversal table length </li>
<li><strong>pBitRevTab</strong> points to bit reversal table </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_bitreversal_32p_xpulpv2">function plp_bitreversal_32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_bitreversal_32p_xpulpv2(
    uint32_t * pSrc,
    const uint16_t bitRevLen,
    const uint16_t * pBitRevTab,
    uint32_t nPE
)
</code></pre>
<p>In-place 32 bit reversal function for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to in-place buffer of unknown 32-bit data type </li>
<li><strong>bitRevLen</strong> bit reversal table length </li>
<li><strong>pBitRevTab</strong> points to bit reversal table </li>
<li><strong>nPE</strong> number of cores </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cfft_q32">function plp_cfft_q32</h3>
<pre><code class="language-cpp">void plp_cfft_q32(
    const plp_cfft_instance_q32 * S,
    int32_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag,
    uint32_t fracBits
)
</code></pre>
<p>Glue code for quantized 32-bit complex fast fourier transform. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the 32bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>fracBits</strong> decimal point for right shift (input format Q(32-fracBits).fracBits)</li>
<li><strong>S</strong> points to an instance of the 32bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>fracBits</strong> decimal point for right shift (input format Q(32-fracBits).fracBits) </li>
</ul>
<p>Fixed point units input -&gt; output dependent on length: len=16: Q1.31 -&gt; Q5.27 len=32: Q1.31 -&gt; Q6.26 len=64: Q1.31 -&gt; Q7.25 len=128: Q1.31 -&gt; Q8.24 len=256: Q1.31 -&gt; Q9.23 len=512: Q1.31 -&gt; Q10.22 len=1024: Q1.31 -&gt; Q11.21 len=2048: Q1.31 -&gt; Q12.20 len=4096: Q1.31 -&gt; Q13.19</p>
<h3 id="function-plp_cfft_q32_parallel">function plp_cfft_q32_parallel</h3>
<pre><code class="language-cpp">void plp_cfft_q32_parallel(
    const plp_cfft_instance_q32 * S,
    int32_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag,
    uint32_t fracBits,
    uint32_t nPE
)
</code></pre>
<p>Quantized 32-bit complex fast fourier transform for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the 32bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>fracBits</strong> decimal point for right shift (input format Q(32-fracBits).fracBits) </li>
<li><strong>nPE</strong> Number of cores to use</li>
<li><strong>S</strong> points to an instance of the 32bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>fracBits</strong> decimal point for right shift (input format Q(32-fracBits).fracBits) </li>
<li><strong>nPE</strong> Number of cores to use </li>
</ul>
<h3 id="function-plp_cfft_q32s_rv32im">function plp_cfft_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_cfft_q32s_rv32im(
    const plp_cfft_instance_q32 * S,
    int32_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag,
    uint32_t fracBits
)
</code></pre>
<p>Quantized 32-bit complex fast fourier transform for RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the 32bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>fracBits</strong> decimal point for right shift (input format Q(32-fracBits).fracBits)</li>
<li><strong>S</strong> points to an instance of the 32bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>fracBits</strong> decimal point for right shift (input format Q(32-fracBits).fracBits) </li>
</ul>
<h3 id="function-plp_cfft_q32s_xpulpv2">function plp_cfft_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cfft_q32s_xpulpv2(
    const plp_cfft_instance_q32 * S,
    int32_t * p1,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag,
    uint32_t fracBits
)
</code></pre>
<p>Quantized 32-bit complex fast fourier transform for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the 32bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>fracBits</strong> decimal point for right shift (input format Q(32-fracBits).fracBits)</li>
<li><strong>S</strong> points to an instance of the 32bit quantized CFFT structure </li>
<li><strong>p1</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>fracBits</strong> decimal point for right shift (input format Q(32-fracBits).fracBits) </li>
</ul>
<h3 id="function-plp_cfft_q32p_xpulpv2">function plp_cfft_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cfft_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel quantized 32 bit complex fast fourier transform for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__cfft__instance__q32__parallel/">plp_cfft_instance_q32_parallel</a></li>
</ul>
<h3 id="function-plp_rfft_f32">function plp_rfft_f32</h3>
<pre><code class="language-cpp">void plp_rfft_f32(
    const plp_fft_instance_f32 * S,
    const float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Floating-point FFT on real input data. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>pDst</strong> points to the output buffer (complex data) </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_rfft_f32_parallel">function plp_rfft_f32_parallel</h3>
<pre><code class="language-cpp">void plp_rfft_f32_parallel(
    const plp_fft_instance_f32 * S,
    const float32_t *__restrict__ pSrc,
    const uint32_t nPE,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Floating-point FFT on real input data (parallel version). </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pDst</strong> points to the output buffer (complex data) </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_rfft_f32s_xpulpv2">function plp_rfft_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_rfft_f32s_xpulpv2(
    const plp_fft_instance_f32 * S,
    const float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Floating-point FFT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrcA</strong> points to the input buffer (real data) </li>
<li><strong>pDst</strong> points to the output buffer (complex data) </li>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>pDst</strong> points to the output buffer (complex data) </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_rfft_f32p_xpulpv2">function plp_rfft_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_rfft_f32p_xpulpv2(
    void * arg
)
</code></pre>
<p>Floating-point FFT on real input data for XPULPV2 extension (parallel version). </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>arg</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>arg</strong> points to an instance of the floating-point FFT structure </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Floating-point FFT on real input data for XPULPV2 extension (parallel version).</p>
<h3 id="function-plp_rfftfast_f32">function plp_rfftfast_f32</h3>
<pre><code class="language-cpp">void plp_rfftfast_f32(
    const plp_fft_fast_instance_f32 * S,
    const float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Floating-point FFT on real input data. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>pDst</strong> points to the output buffer (complex data) </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_rfftfast_f32_parallel">function plp_rfftfast_f32_parallel</h3>
<pre><code class="language-cpp">void plp_rfftfast_f32_parallel(
    const plp_fft_fast_instance_f32 * S,
    float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst,
    const uint32_t nPE
)
</code></pre>
<p>Floating-point parallel FFT on real input data. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>pDst</strong> points to the output buffer (complex data) </li>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>pDst</strong> points to the output buffer (complex data) </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Floating-point parallel FFT on real input data.</p>
<h3 id="function-plp_rfftfast_f32s_xpulpv2">function plp_rfftfast_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_rfftfast_f32s_xpulpv2(
    const plp_fft_fast_instance_f32 * S,
    float32_t * pSrc,
    float32_t * pDst
)
</code></pre>
<p>Floating-point FFT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrcA</strong> points to the input buffer (real data) </li>
<li><strong>pDst</strong> points to the output buffer (complex data) </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_rfftfast_f32p_xpulpv2">function plp_rfftfast_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_rfftfast_f32p_xpulpv2(
    void * arg
)
</code></pre>
<p>Floating-point parallel FFT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>arg</strong> points to an instance of the floating-point FFT structure </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cfft_f32">function plp_cfft_f32</h3>
<pre><code class="language-cpp">void plp_cfft_f32(
    const plp_cfft_instance_f32 * S,
    float32_t * pSrc,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag
)
</code></pre>
<p>Floating-point FFT on complex input data. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrc</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cfft_f32_parallel">function plp_cfft_f32_parallel</h3>
<pre><code class="language-cpp">void plp_cfft_f32_parallel(
    const plp_cfft_instance_f32 * S,
    const float32_t * pSrc,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag,
    const uint32_t nPE
)
</code></pre>
<p>Floating-point FFT on complex input data (parallel version). </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrc</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
<li><strong>nPE</strong> number of parallel processing units </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cfft_f32s_xpulpv2">function plp_cfft_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cfft_f32s_xpulpv2(
    const plp_cfft_instance_f32 * S,
    const float32_t * pSrc,
    uint8_t ifftFlag,
    uint8_t bitReverseFlag
)
</code></pre>
<p>Floating-point FFT on complex input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>pSrc</strong> points to the complex data buffer of size <code>2*fftLen</code>. Processing occurs in-place. </li>
<li><strong>ifftFlag</strong> flag that selects forwart (ifftFlag=0) or inverse (ifftFlag=1) </li>
<li><strong>bitReverseFlag</strong> flag that enables (bitReverseFlag=1) of disables (bitReverseFlag=0) bit reversal of output. </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cfft_f32p_xpulpv2">function plp_cfft_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cfft_f32p_xpulpv2(
    void * arg
)
</code></pre>
<p>Floating-point FFT on complex input data for XPULPV2 extension (parallel version). </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>arg</strong> points to an instance of the floating-point FFT structure </li>
<li><strong>arg</strong> points to an instance of the floating-point FFT structure </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Floating-point FFT on complex input data for XPULPV2 extension (parallel version).</p>
<h3 id="function-plp_dct2_f32">function plp_dct2_f32</h3>
<pre><code class="language-cpp">void plp_dct2_f32(
    const plp_fft_instance_f32 * S,
    const Complex_type_f32 * pShift,
    const uint8_t orthoNorm,
    const float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pBuf,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Floating-point DCT on real input data. Implementation of John Makhoul's "A Fast Cosine Transform in One                      and Two Dimensions" 1980 IEEE paper. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure with FFTLength = DCTLength </li>
<li><strong>pShift</strong> points to twiddle coefficient table of 4*FFTLength, of which only the first quarter is necessary. </li>
<li><strong>pSrc</strong> points to the input buffer (real data) of size FFTLength </li>
<li><strong>pBuf</strong> points to buffer of size 2*FFTLength, used for computation. </li>
<li><strong>pDst</strong> points to output buffer (real data) of size FFTLength, may be the same as pSrc. </li>
<li><strong>S</strong> points to an instance of the floating-point FFT structure with FFTLength = DCTLength </li>
<li><strong>pShift</strong> points to twiddle coefficient table of 4*FFTLength, of which only the first quadrant of the complex unit circle is used. For example, if S contains twiddleCoef_rfft_32, pShift can be set to twiddleCoef_rfft_128. </li>
<li><strong>pSrc</strong> points to the input buffer (real data) of size FFTLength. </li>
<li><strong>pBuf</strong> points to buffer of size 2*FFTLength, used for computation. </li>
<li><strong>pDst</strong> points to output buffer (real data) of size FFTLength, may be the same as pSrc. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_dct2_f32_parallel">function plp_dct2_f32_parallel</h3>
<pre><code class="language-cpp">void plp_dct2_f32_parallel(
    const plp_fft_instance_f32 * S,
    const Complex_type_f32 * pShift,
    const uint8_t orthoNorm,
    const float32_t *__restrict__ pSrc,
    const uint32_t nPE,
    float32_t *__restrict__ pBuf,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Floating-point DCT on real input data. Implementation of John Makhoul's "A Fast Cosine Transform in One                      and Two Dimensions" 1980 IEEE paper. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to an instance of the floating-point FFT structure with FFTLength = DCTLength </li>
<li><strong>pShift</strong> points to twiddle coefficient table of 4*FFTLength, of which only the first quarter is necessary. </li>
<li><strong>pSrc</strong> points to the input buffer (real data) of size FFTLength </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pBuf</strong> points to buffer of size 2*FFTLength, used for computation. </li>
<li><strong>pDst</strong> points to output buffer (real data) of size FFTLength, may be the same as pSrc. </li>
<li><strong>S</strong> points to an instance of the floating-point FFT structure with FFTLength = DCTLength </li>
<li><strong>pShift</strong> points to twiddle coefficient table of 4*FFTLength, of which only the first quadrant of the complex unit circle is used. For example, if S contains twiddleCoef_rfft_32, pShift can be set to twiddleCoef_rfft_128. </li>
<li><strong>pSrc</strong> points to the input buffer (real data) of size FFTLength. </li>
<li><strong>pBuf</strong> points to buffer of size 2*FFTLength, used for computation. </li>
<li><strong>pDst</strong> points to output buffer (real data) of size FFTLength, may be the same as pSrc. </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Floating-point DCT on real input data. Implementation of John Makhoul's "A Fast Cosine Transform in One
                     and Two Dimensions" 1980 IEEE paper.</p>
<h3 id="function-plp_mfcc_f32">function plp_mfcc_f32</h3>
<pre><code class="language-cpp">void plp_mfcc_f32(
    const plp_fft_instance_f32 * SFFT,
    const plp_fft_instance_f32 * SDCT,
    const Complex_type_f32 * pShift,
    const plp_triangular_filter_f32 * filterBank,
    const float32_t * window,
    const uint8_t * orthoNorm,
    const float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>MFCC on real input data. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>SFFT</strong> points to an instance of the floating-point FFT structure for the initial FFT (with FFTLength = n_fft). bitReverseFlag should be on. </li>
<li><strong>SDCT</strong> points to an instance of the floating-point FFT structure for the DCT (with FFTLength = n_mels). bitReverseFlag should be on. </li>
<li><strong>pShift</strong> points to twiddle coefficient table with FFTLength = 4*n_mels. Only first quarter necessary. </li>
<li><strong>filterBank</strong> points to <a href="/pulp-dsp/refmanual/Classes/structplp__triangular__filter__f32/">plp_triangular_filter_f32</a> instance with nFilters = n_mels. </li>
<li><strong>window</strong> vector to use for windowing </li>
<li><strong>orthoNorm</strong> whether to use dct orthonormalisation or not </li>
<li><strong>pSrc</strong> points to the input buffer (real data, size n_fft) </li>
<li><strong>pDst</strong> points to the output buffer of length at least 3*n_fft. pSrc and pDst must not overlap, the calculation can not be done in place. MFCCs are returned in the first n_mels spots. </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_mfcc_f32_parallel">function plp_mfcc_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mfcc_f32_parallel(
    const plp_fft_instance_f32 * SFFT,
    const plp_fft_instance_f32 * SDCT,
    const Complex_type_f32 * pShift,
    const plp_triangular_filter_f32 * filterBank,
    const float32_t * window,
    const uint8_t * orthoNorm,
    const float32_t *__restrict__ pSrc,
    const uint32_t nPE,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>MFCC on real input data. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>SFFT</strong> points to an instance of the floating-point FFT structure for the initial FFT (with FFTLength = n_fft). bitReverseFlag should be on. </li>
<li><strong>SDCT</strong> points to an instance of the floating-point FFT structure for the DCT (with FFTLength = n_mels). bitReverseFlag should be on. </li>
<li><strong>pShift</strong> points to twiddle coefficient table with FFTLength = 4*n_mels. Only first quarter necessary. </li>
<li><strong>filterBank</strong> points to <a href="/pulp-dsp/refmanual/Classes/structplp__triangular__filter__f32/">plp_triangular_filter_f32</a> instance with nFilters = n_mels. </li>
<li><strong>window</strong> vector to use for windowing </li>
<li><strong>orthoNorm</strong> whether to use dct orthonormalisation or not </li>
<li><strong>pSrc</strong> points to the input buffer (real data, size n_fft) </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pDst</strong> points to the output buffer of length at least 3*n_fft. pSrc and pDst must not overlap, the calculation can not be done in place. MFCCs are returned in the first n_mels spots. </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_f32">function plp_dwt_f32</h3>
<pre><code class="language-cpp">void plp_dwt_f32(
    const float32_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_f32 wavelet,
    plp_dwt_extension_mode mode,
    float32_t *__restrict__ pDstA,
    float32_t *__restrict__ pDstD
)
</code></pre>
<p>Glue code for matrix addition of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Floating-point DWT on real input data for XPULPV2 extension. 
Glue code for matrix addition of a 32-bit integer matrices.</p>
<h3 id="function-plp_dwt_q32">function plp_dwt_q32</h3>
<pre><code class="language-cpp">void plp_dwt_q32(
    const int32_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q32 wavelet,
    plp_dwt_extension_mode mode,
    int32_t *__restrict__ pDstA,
    int32_t *__restrict__ pDstD
)
</code></pre>
<p>32bit Fixed-point DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (q32) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32bit Fixed-point DWT for XPULPV2 extension.</p>
<h3 id="function-plp_dwt_q16">function plp_dwt_q16</h3>
<pre><code class="language-cpp">void plp_dwt_q16(
    const int16_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q16 wavelet,
    plp_dwt_extension_mode mode,
    int16_t *__restrict__ pDstA,
    int16_t *__restrict__ pDstD
)
</code></pre>
<p>16bit Fixed-point DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (q16) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16bit Fixed-point DWT for XPULPV2 extension.</p>
<h3 id="function-plp_dwt_q8">function plp_dwt_q8</h3>
<pre><code class="language-cpp">void plp_dwt_q8(
    const int8_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q8 wavelet,
    plp_dwt_extension_mode mode,
    int8_t *__restrict__ pDstA,
    int8_t *__restrict__ pDstD
)
</code></pre>
<p>8bit Fixed-point DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (q8) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8bit Fixed-point DWT for XPULPV2 extension.</p>
<h3 id="function-plp_dwt_dec_f32">function plp_dwt_dec_f32</h3>
<pre><code class="language-cpp">void plp_dwt_dec_f32(
    const float32_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_f32 wavelet,
    plp_dwt_extension_mode mode,
    uint32_t level,
    float32_t *__restrict__ pTmp,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Floating-point n-level DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode </li>
<li><strong>level</strong> Levels of Wavelet decomposition</li>
<li><strong>pDst</strong> points to ouput buffer with Detailed coefficients and final approximate </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_dec_f32_parallel">function plp_dwt_dec_f32_parallel</h3>
<pre><code class="language-cpp">void plp_dwt_dec_f32_parallel(
    const float32_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_f32 wavelet,
    plp_dwt_extension_mode mode,
    uint32_t level,
    uint32_t nPE,
    float32_t *__restrict__ pTemp,
    float32_t *__restrict__ pDst
)
</code></pre>
<p>Floating-point parallel n-level DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode </li>
<li><strong>level</strong> Levels of Wavelet decomposition</li>
<li><strong>pDst</strong> points to ouput buffer with Detailed coefficients and final approximate </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_f32s_xpulpv2">function plp_dwt_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_f32s_xpulpv2(
    const float32_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_f32 wavelet,
    plp_dwt_extension_mode mode,
    float32_t *__restrict__ pDstA,
    float32_t *__restrict__ pDstD
)
</code></pre>
<p>Floating-point DWT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_haar_f32s_xpulpv2">function plp_dwt_haar_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_haar_f32s_xpulpv2(
    const float32_t *__restrict__ pSrc,
    uint32_t length,
    plp_dwt_extension_mode mode,
    float32_t *__restrict__ pDstA,
    float32_t *__restrict__ pDstD
)
</code></pre>
<p>Floating-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q32s_xpulpv2">function plp_dwt_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_q32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q32 wavelet,
    plp_dwt_extension_mode mode,
    int32_t *__restrict__ pDstA,
    int32_t *__restrict__ pDstD
)
</code></pre>
<p>32bit Fixed-point DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32bit Fixed-point DWT for XPULPV2 extension.</p>
<h3 id="function-plp_dwt_haar_q32s_xpulpv2">function plp_dwt_haar_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_haar_q32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t length,
    plp_dwt_extension_mode mode,
    int32_t *__restrict__ pDstA,
    int32_t *__restrict__ pDstD
)
</code></pre>
<p>32bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q16s_xpulpv2">function plp_dwt_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_q16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q16 wavelet,
    plp_dwt_extension_mode mode,
    int16_t *__restrict__ pDstA,
    int16_t *__restrict__ pDstD
)
</code></pre>
<p>16bit Fixed-point DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (q15) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16bit Fixed-point DWT for XPULPV2 extension.</p>
<h3 id="function-plp_dwt_haar_q16s_xpulpv2">function plp_dwt_haar_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_haar_q16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t length,
    plp_dwt_extension_mode mode,
    int16_t *__restrict__ pDstA,
    int16_t *__restrict__ pDstD
)
</code></pre>
<p>16bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (q15) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension.</p>
<h3 id="function-plp_dwt_q8s_xpulpv2">function plp_dwt_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_q8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q8 wavelet,
    plp_dwt_extension_mode mode,
    int8_t *__restrict__ pDstA,
    int8_t *__restrict__ pDstD
)
</code></pre>
<p>8bit Fixed-point DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (q7) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8bit Fixed-point DWT for XPULPV2 extension.</p>
<h3 id="function-plp_dwt_haar_q8s_xpulpv2">function plp_dwt_haar_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_haar_q8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t length,
    plp_dwt_extension_mode mode,
    int8_t *__restrict__ pDstA,
    int8_t *__restrict__ pDstD
)
</code></pre>
<p>8bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (q7) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension.</p>
<h3 id="function-plp_dwt_f32_parallel">function plp_dwt_f32_parallel</h3>
<pre><code class="language-cpp">void plp_dwt_f32_parallel(
    const float32_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_f32 wavelet,
    plp_dwt_extension_mode mode,
    uint32_t nPE,
    float32_t *__restrict__ pDstA,
    float32_t *__restrict__ pDstD
)
</code></pre>
<p>Parallel Floating-point DWT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode </li>
<li><strong>nPE</strong> Number of cores to use</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q8_parallel">function plp_dwt_q8_parallel</h3>
<pre><code class="language-cpp">void plp_dwt_q8_parallel(
    const int8_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q8 wavelet,
    plp_dwt_extension_mode mode,
    uint32_t nPE,
    int8_t *__restrict__ pDstA,
    int8_t *__restrict__ pDstD
)
</code></pre>
<p>8bit Parallel Fixed-point DWT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (q8) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode </li>
<li><strong>nPE</strong> Number of cores to use</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q16_parallel">function plp_dwt_q16_parallel</h3>
<pre><code class="language-cpp">void plp_dwt_q16_parallel(
    const int16_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q16 wavelet,
    plp_dwt_extension_mode mode,
    uint32_t nPE,
    int16_t *__restrict__ pDstA,
    int16_t *__restrict__ pDstD
)
</code></pre>
<p>16bit Parallel Fixed-point DWT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (q16) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode </li>
<li><strong>nPE</strong> Number of cores to use</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q32_parallel">function plp_dwt_q32_parallel</h3>
<pre><code class="language-cpp">void plp_dwt_q32_parallel(
    const int32_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q32 wavelet,
    plp_dwt_extension_mode mode,
    uint32_t nPE,
    int32_t *__restrict__ pDstA,
    int32_t *__restrict__ pDstD
)
</code></pre>
<p>32bit Parallel Fixed-point DWT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (q32) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode </li>
<li><strong>nPE</strong> Number of cores to use</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_f32p_xpulpv2">function plp_dwt_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Floating-point DWT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__f32/">plp_dwt_instance_f32</a></li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_haar_f32p_xpulpv2">function plp_dwt_haar_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_haar_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Floating-point DWT kernel optimized for Haar Wavelet on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__f32/">plp_dwt_instance_f32</a></li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q8p_xpulpv2">function plp_dwt_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>Q7 fixed-point DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__q8/">plp_dwt_instance_q8</a></li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_haar_q8p_xpulpv2">function plp_dwt_haar_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_haar_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>q7 fixed-point DWT kernel optimized for Haar Wavelet for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__q8/">plp_dwt_instance_q8</a></li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q16p_xpulpv2">function plp_dwt_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>Q15 fixed-point DWT for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__q16/">plp_dwt_instance_q16</a></li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_haar_q16p_xpulpv2">function plp_dwt_haar_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_haar_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>q15 fixed-point DWT kernel optimized for Haar Wavelet for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__q16/">plp_dwt_instance_q16</a></li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q32p_xpulpv2">function plp_dwt_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_q32p_xpulpv2(
    void * arg
)
</code></pre>
<p>Q31 fixed-point DWT on real input data for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__q32/">plp_dwt_instance_q32</a></li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_haar_q32p_xpulpv2">function plp_dwt_haar_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_dwt_haar_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>Q31 Fixed-point DWT kernel optimized for Haar Wavelet for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> points to the <a href="/pulp-dsp/refmanual/Classes/structplp__dwt__instance__q32/">plp_dwt_instance_q32</a></li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q32s_rv32im">function plp_dwt_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_dwt_q32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q32 wavelet,
    plp_dwt_extension_mode mode,
    int32_t *__restrict__ pDstA,
    int32_t *__restrict__ pDstD
)
</code></pre>
<p>32bit Fixed-point DWT. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32bit Fixed-point DWT.</p>
<h3 id="function-plp_dwt_haar_q32s_rv32im">function plp_dwt_haar_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_dwt_haar_q32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t length,
    plp_dwt_extension_mode mode,
    int32_t *__restrict__ pDstA,
    int32_t *__restrict__ pDstD
)
</code></pre>
<p>32bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_dwt_q16s_rv32im">function plp_dwt_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_dwt_q16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q16 wavelet,
    plp_dwt_extension_mode mode,
    int16_t *__restrict__ pDstA,
    int16_t *__restrict__ pDstD
)
</code></pre>
<p>16bit Fixed-point DWT. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16bit Fixed-point DWT.</p>
<h3 id="function-plp_dwt_haar_q16s_rv32im">function plp_dwt_haar_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_dwt_haar_q16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t length,
    plp_dwt_extension_mode mode,
    int16_t *__restrict__ pDstA,
    int16_t *__restrict__ pDstD
)
</code></pre>
<p>16bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data.</p>
<h3 id="function-plp_dwt_q8s_rv32im">function plp_dwt_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_dwt_q8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t length,
    const plp_dwt_wavelet_q8 wavelet,
    plp_dwt_extension_mode mode,
    int8_t *__restrict__ pDstA,
    int8_t *__restrict__ pDstD
)
</code></pre>
<p>8bit Fixed-point DWT. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>wavelet</strong> wavelet structure for calculating DWT </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8bit Fixed-point DWT.</p>
<h3 id="function-plp_dwt_haar_q8s_rv32im">function plp_dwt_haar_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_dwt_haar_q8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t length,
    plp_dwt_extension_mode mode,
    int8_t *__restrict__ pDstA,
    int8_t *__restrict__ pDstD
)
</code></pre>
<p>8bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
<li><strong>pSrc</strong> points to the input buffer (real data) </li>
<li><strong>length</strong> length of input buffer </li>
<li><strong>mode</strong> boundary extension mode</li>
<li><strong>pDstA</strong> points to ouput buffer with Approximate coefficients </li>
<li><strong>pDstD</strong> points to ouput buffer with Detailed coefficients </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8bit Fixed-point DWT kernel optimized for Haar Wavelet on real input data.</p>
<h3 id="function-plp_mat_add_i32">function plp_mat_add_i32</h3>
<pre><code class="language-cpp">void plp_mat_add_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix addition of 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_mat_add_i32s_rv32im">function plp_mat_add_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_add_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_add_i32s_xpulpv2">function plp_mat_add_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_i32_parallel">function plp_mat_add_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_add_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix addition of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix addition of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_add_i32p_xpulpv2">function plp_mat_add_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix addition of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__i32/">plp_mat_add_instance_i32</a> struct initialized by plp_mat_add_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__i32/">plp_mat_add_instance_i32</a> struct initialized by plp_mat_add_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix addition of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_i16">function plp_mat_add_i16</h3>
<pre><code class="language-cpp">void plp_mat_add_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix addition of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix addition of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_add_i16s_rv32im">function plp_mat_add_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_add_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_add_i16s_xpulpv2">function plp_mat_add_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix addition of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_i16_parallel">function plp_mat_add_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_add_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix addition of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix addition of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_add_i16p_xpulpv2">function plp_mat_add_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix addition of 16-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__i16/">plp_mat_add_instance_i16</a> struct initialized by plp_mat_add_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__i16/">plp_mat_add_instance_i16</a> struct initialized by plp_mat_add_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_add_i8">function plp_mat_add_i8</h3>
<pre><code class="language-cpp">void plp_mat_add_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix addition of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix addition of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_add_i8s_rv32im">function plp_mat_add_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_add_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_add_i8s_xpulpv2">function plp_mat_add_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix addition of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_i8_parallel">function plp_mat_add_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_add_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix addition of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix addition of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_add_i8p_xpulpv2">function plp_mat_add_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix addition of 8-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__i8/">plp_mat_add_instance_i8</a> struct initialized by plp_mat_add_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__i8/">plp_mat_add_instance_i8</a> struct initialized by plp_mat_add_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_add_f32">function plp_mat_add_f32</h3>
<pre><code class="language-cpp">void plp_mat_add_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix addition of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices <PARALLEL_ARG_DOC> </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix addition of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_add_f32s_xpulpv2">function plp_mat_add_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    float *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_f32_parallel">function plp_mat_add_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_add_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix addition of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix addition of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_add_f32p_xpulpv2">function plp_mat_add_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix addition of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__f32/">plp_mat_add_instance_f32</a> struct initialized by plp_mat_add_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__instance__f32/">plp_mat_add_instance_f32</a> struct initialized by plp_mat_add_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_sub_i32">function plp_mat_sub_i32</h3>
<pre><code class="language-cpp">void plp_mat_sub_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix subtraction of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix subtraction of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_i32s_rv32im">function plp_mat_sub_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_sub_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_sub_i32s_xpulpv2">function plp_mat_sub_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_i32_parallel">function plp_mat_sub_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_sub_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix subtraction of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix subtraction of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_i32p_xpulpv2">function plp_mat_sub_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix subtraction of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__i32/">plp_mat_sub_instance_i32</a> struct initialized by plp_mat_sub_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__i32/">plp_mat_sub_instance_i32</a> struct initialized by plp_mat_sub_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix subtraction of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_i16">function plp_mat_sub_i16</h3>
<pre><code class="language-cpp">void plp_mat_sub_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix subtraction of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix subtraction of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_i16s_rv32im">function plp_mat_sub_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_sub_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_sub_i16s_xpulpv2">function plp_mat_sub_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix subtraction of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_i16_parallel">function plp_mat_sub_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_sub_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix subtraction of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix subtraction of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_i16p_xpulpv2">function plp_mat_sub_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix subtraction of 16-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__i16/">plp_mat_sub_instance_i16</a> struct initialized by plp_mat_sub_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__i16/">plp_mat_sub_instance_i16</a> struct initialized by plp_mat_sub_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_sub_i8">function plp_mat_sub_i8</h3>
<pre><code class="language-cpp">void plp_mat_sub_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix subtraction of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix subtraction of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_i8s_rv32im">function plp_mat_sub_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_sub_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_sub_i8s_xpulpv2">function plp_mat_sub_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix subtraction of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_i8_parallel">function plp_mat_sub_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_sub_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix subtraction of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix subtraction of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_i8p_xpulpv2">function plp_mat_sub_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix subtraction of 8-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__i8/">plp_mat_sub_instance_i8</a> struct initialized by plp_mat_sub_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__i8/">plp_mat_sub_instance_i8</a> struct initialized by plp_mat_sub_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_sub_f32">function plp_mat_sub_f32</h3>
<pre><code class="language-cpp">void plp_mat_sub_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix subtraction of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices <PARALLEL_ARG_DOC> </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix subtraction of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_sub_f32s_xpulpv2">function plp_mat_sub_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    float *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_f32_parallel">function plp_mat_sub_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_sub_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix subtraction of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix subtraction of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_sub_f32p_xpulpv2">function plp_mat_sub_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix subtraction of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__f32/">plp_mat_sub_instance_f32</a> struct initialized by plp_mat_sub_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__instance__f32/">plp_mat_sub_instance_f32</a> struct initialized by plp_mat_sub_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_scale_i32">function plp_mat_scale_i32</h3>
<pre><code class="language-cpp">void plp_mat_scale_i32(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int32_t scaleFactor,
    int32_t shift,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix scale of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix scale of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_i32s_rv32im">function plp_mat_scale_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_scale_i32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int32_t scaleFactor,
    int32_t shift,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix scale of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix scale of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_scale_i32s_xpulpv2">function plp_mat_scale_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_i32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int32_t scaleFactor,
    int32_t shift,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix scale of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix scale of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_i32_parallel">function plp_mat_scale_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_scale_i32_parallel(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int32_t scaleFactor,
    int32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix scale of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix scale of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_i32p_xpulpv2">function plp_mat_scale_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix scale of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__i32/">plp_mat_scale_instance_i32</a> struct initialized by plp_mat_scale_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__i32/">plp_mat_scale_instance_i32</a> struct initialized by plp_mat_scale_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix scale of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_i16">function plp_mat_scale_i16</h3>
<pre><code class="language-cpp">void plp_mat_scale_i16(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int16_t scaleFactor,
    int32_t shift,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix scale of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix scale of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_i16s_rv32im">function plp_mat_scale_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_scale_i16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int16_t scaleFactor,
    int32_t shift,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix scale of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix scale of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_scale_i16s_xpulpv2">function plp_mat_scale_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_i16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int16_t scaleFactor,
    int32_t shift,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix scale of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix scale of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_i16_parallel">function plp_mat_scale_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_scale_i16_parallel(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int16_t scaleFactor,
    int32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix scale of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix scale of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_i16p_xpulpv2">function plp_mat_scale_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix scale of 16-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__i16/">plp_mat_scale_instance_i16</a> struct initialized by plp_mat_scale_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__i16/">plp_mat_scale_instance_i16</a> struct initialized by plp_mat_scale_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_scale_i8">function plp_mat_scale_i8</h3>
<pre><code class="language-cpp">void plp_mat_scale_i8(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int8_t scaleFactor,
    int32_t shift,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix scale of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix scale of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_i8s_rv32im">function plp_mat_scale_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_scale_i8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int8_t scaleFactor,
    int32_t shift,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix scale of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix scale of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_scale_i8s_xpulpv2">function plp_mat_scale_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_i8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int8_t scaleFactor,
    int32_t shift,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix scale of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix scale of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_i8_parallel">function plp_mat_scale_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_scale_i8_parallel(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int8_t scaleFactor,
    int32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix scale of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix scale of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_i8p_xpulpv2">function plp_mat_scale_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix scale of 8-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__i8/">plp_mat_scale_instance_i8</a> struct initialized by plp_mat_scale_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__i8/">plp_mat_scale_instance_i8</a> struct initialized by plp_mat_scale_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_scale_f32">function plp_mat_scale_f32</h3>
<pre><code class="language-cpp">void plp_mat_scale_f32(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    float scaleFactor,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix scale of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix scale of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_scale_f32s_xpulpv2">function plp_mat_scale_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    float scaleFactor,
    float *__restrict__ pDst
)
</code></pre>
<p>matrix scale of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix scale of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_f32_parallel">function plp_mat_scale_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_scale_f32_parallel(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    float scaleFactor,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix scale of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix scale of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_scale_f32p_xpulpv2">function plp_mat_scale_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix scale of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__f32/">plp_mat_scale_instance_f32</a> struct initialized by plp_mat_scale_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__instance__f32/">plp_mat_scale_instance_f32</a> struct initialized by plp_mat_scale_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_trans_i32">function plp_mat_trans_i32</h3>
<pre><code class="language-cpp">void plp_mat_trans_i32(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix transpose of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix transpose of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_trans_i32s_rv32im">function plp_mat_trans_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_trans_i32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix transpose of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transpose of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_trans_i32s_xpulpv2">function plp_mat_trans_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_trans_i32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix transpose of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transpose of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_trans_i32_parallel">function plp_mat_trans_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_trans_i32_parallel(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix transpose of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: none</p>
<hr />
<p>Glue code for parallel matrix transpose of a 32-bit integer matrices. </p>
<h3 id="function-plp_mat_trans_i32p_xpulpv2">function plp_mat_trans_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_trans_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transpose of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__trans__instance__i32/">plp_mat_trans_instance_i32</a> struct initialized by plp_mat_trans_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__trans__instance__i32/">plp_mat_trans_instance_i32</a> struct initialized by plp_mat_trans_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix transpose of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_trans_i16">function plp_mat_trans_i16</h3>
<pre><code class="language-cpp">void plp_mat_trans_i16(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix transpose of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix transpose of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_trans_i16s_rv32im">function plp_mat_trans_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_trans_i16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix transpose of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transpose of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_trans_i16s_xpulpv2">function plp_mat_trans_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_trans_i16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix transpose of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix transpose of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_trans_i16_parallel">function plp_mat_trans_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_trans_i16_parallel(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix transpose of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix transpose of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_trans_i16p_xpulpv2">function plp_mat_trans_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_trans_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transpose of 16-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__trans__instance__i16/">plp_mat_trans_instance_i16</a> struct initialized by plp_mat_trans_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__trans__instance__i16/">plp_mat_trans_instance_i16</a> struct initialized by plp_mat_trans_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_trans_i8">function plp_mat_trans_i8</h3>
<pre><code class="language-cpp">void plp_mat_trans_i8(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix transpose of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix transpose of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_trans_i8s_rv32im">function plp_mat_trans_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_trans_i8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix transpose of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix transpose of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_trans_i8s_xpulpv2">function plp_mat_trans_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_trans_i8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix transpose of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix transpose of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_trans_i8_parallel">function plp_mat_trans_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_trans_i8_parallel(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix transpose of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix transpose of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_trans_i8p_xpulpv2">function plp_mat_trans_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_trans_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix transpose of 8-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__trans__instance__i8/">plp_mat_trans_instance_i8</a> struct initialized by plp_mat_trans_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__trans__instance__i8/">plp_mat_trans_instance_i8</a> struct initialized by plp_mat_trans_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_trans_f32">function plp_mat_trans_f32</h3>
<pre><code class="language-cpp">void plp_mat_trans_f32(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix transpose of a 32-bit float*ing-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>This function will use plp_mat_trans_i32s_xpulpv2 for its computation.</li>
<li>This function will use plp_mat_trans_i32s_xpulpv2 for its computation.</li>
</ul>
<hr />
<p>Glue code for matrix transpose of a 32-bit float*ing-point matrices.</p>
<h3 id="function-plp_mat_trans_f32_parallel">function plp_mat_trans_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_trans_f32_parallel(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix transpose of a 32-bit float*ing-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of the input matrix and width of the output matrix </li>
<li><strong>N</strong> Width of the input matrix and height of the output matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxM </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>This function will use plp_mat_trans_i32p_xpulpv2 for its computation.</li>
<li>This function will use plp_mat_trans_i32p_xpulpv2 for its computation.</li>
</ul>
<hr />
<p>Glue code for parallel matrix transpose of a 32-bit float*ing-point matrices.</p>
<h3 id="function-plp_mat_inv_f32">function plp_mat_inv_f32</h3>
<pre><code class="language-cpp">int plp_mat_inv_f32(
    float *__restrict__ pSrc,
    float *__restrict__ pDst,
    uint32_t N
)
</code></pre>
<p>Glue code for matrix inverse of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the first input matrix. pSrc is modified by this funciton </li>
<li><strong>N</strong> Width and height of both matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix. pSrc is modified by this function </li>
<li><strong>N</strong> Width and height of both matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>0: Success, 1: Matrix is singular, 2: operation not supported</li>
</ul>
<p><strong>Par</strong>: This function will use plp_mat_inv_i32s_xpulpv2 for its computation.</p>
<hr />
<p>Glue code for matrix inverse of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_inv_f32s_xpulpv2">function plp_mat_inv_f32s_xpulpv2</h3>
<pre><code class="language-cpp">int plp_mat_inv_f32s_xpulpv2(
    float *__restrict__ pSrc,
    float *__restrict__ pDst,
    uint32_t N
)
</code></pre>
<p>matrix inverse of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the first input matrix. pSrc is modified by this funciton </li>
<li><strong>N</strong> Width and height of both matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the first input matrix. pSrc is modified by this funciton </li>
<li><strong>N</strong> Width and height of both matrices </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>0: Success, 1: Matrix is singular</li>
<li>0: Success, 1: Matrix is singular </li>
</ul>
<hr />
<p>matrix inverse of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_inv_f32_parallel">function plp_mat_inv_f32_parallel</h3>
<pre><code class="language-cpp">int plp_mat_inv_f32_parallel(
    float *__restrict__ pSrc,
    float *__restrict__ pDst,
    uint32_t N,
    uint32_t nPE
)
</code></pre>
<p>Glue code for parallel matrix inverse of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix. pSrc is modified by this funciton </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of both matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pSrc</strong> Points to the input matrix, pSrc is modified by this function </li>
<li><strong>N</strong> Width and height of both matrices </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>0: Success, 1: Matrix is singular, 2: operation not supported</li>
<li>0: Success, 1: Matrix is singular, 2: operation not supported</li>
</ul>
<hr />
<p>Glue code for parallel matrix inverse of a 32-bit floating-point matrices.</p>
<p>@warn This function is not yet implemented in parallel, and it will call the single-core implementation! </p>
<h3 id="function-plp_mat_inv_f32p_xpulpv2">function plp_mat_inv_f32p_xpulpv2</h3>
<pre><code class="language-cpp">int plp_mat_inv_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix inverse of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__inv__instance__f32/">plp_mat_inv_instance_f32</a> struct initialized by plp_mat_inv_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__inv__instance__f32/">plp_mat_inv_instance_f32</a> struct initialized by plp_mat_inv_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>0: Success, 1: Matrix is singular</li>
<li>0: Success, 1: Matrix is singular</li>
</ul>
<hr />
<p>Parallel matrix inverse of 32-bit floating-point matrices kernel for XPULPV2 extension.</p>
<p>@warn Not yet implemented </p>
<h3 id="function-plp_mat_fill_i_i32">function plp_mat_fill_I_i32</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i32(
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 32-bit integer identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i32s_rv32im">function plp_mat_fill_I_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i32s_rv32im(
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Create a 32-bit integer identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i32s_xpulpv2">function plp_mat_fill_I_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i32s_xpulpv2(
    uint32_t N,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Create a 32-bit integer identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i32_parallel">function plp_mat_fill_I_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i32_parallel(
    uint32_t N,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 32-bit integer identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i32p_xpulpv2">function plp_mat_fill_I_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a 32-bit integer identity matrix in parallel on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__i32/">plp_mat_fill_I_instance_i32</a> struct initialized by plp_mat_fill_I_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__i32/">plp_mat_fill_I_instance_i32</a> struct initialized by plp_mat_fill_I_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i16">function plp_mat_fill_I_i16</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i16(
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 16-bit integer identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i16s_rv32im">function plp_mat_fill_I_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i16s_rv32im(
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Create a 16-bit integer identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i16s_xpulpv2">function plp_mat_fill_I_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i16s_xpulpv2(
    uint32_t N,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Create a 16-bit integer identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_fill_i_i16_parallel">function plp_mat_fill_I_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i16_parallel(
    uint32_t N,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 16-bit integer identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i16p_xpulpv2">function plp_mat_fill_I_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a 16-bit integer identity matrix in parallel on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__i16/">plp_mat_fill_I_instance_i16</a> struct initialized by plp_mat_fill_I_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__i16/">plp_mat_fill_I_instance_i16</a> struct initialized by plp_mat_fill_I_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_fill_i_i8">function plp_mat_fill_I_i8</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i8(
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 8-bit integer identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i8s_rv32im">function plp_mat_fill_I_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i8s_rv32im(
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Create a 8-bit integer identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i8s_xpulpv2">function plp_mat_fill_I_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i8s_xpulpv2(
    uint32_t N,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Create a 8-bit integer identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_fill_i_i8_parallel">function plp_mat_fill_I_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i8_parallel(
    uint32_t N,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 8-bit integer identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_i8p_xpulpv2">function plp_mat_fill_I_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a 8-bit integer identity matrix in parallel on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__i8/">plp_mat_fill_I_instance_i8</a> struct initialized by plp_mat_fill_I_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__i8/">plp_mat_fill_I_instance_i8</a> struct initialized by plp_mat_fill_I_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_fill_i_f32">function plp_mat_fill_I_f32</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_f32(
    uint32_t N,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 32-bit float identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_f32s_xpulpv2">function plp_mat_fill_I_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_f32s_xpulpv2(
    uint32_t N,
    float *__restrict__ pDst
)
</code></pre>
<p>Create a 32-bit float identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_f32_parallel">function plp_mat_fill_I_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_f32_parallel(
    uint32_t N,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 32-bit float identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_f32p_xpulpv2">function plp_mat_fill_I_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a 32-bit float identity matrix in parallel on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__f32/">plp_mat_fill_I_instance_f32</a> struct initialized by plp_mat_fill_I_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__f32/">plp_mat_fill_I_instance_f32</a> struct initialized by plp_mat_fill_I_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q32">function plp_mat_fill_I_q32</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q32(
    uint32_t N,
    int32_t fracBits,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 32-bit fix-point identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q32s_rv32im">function plp_mat_fill_I_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q32s_rv32im(
    uint32_t N,
    int32_t fracBits,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Create a 32-bit fix-point identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q32s_xpulpv2">function plp_mat_fill_I_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q32s_xpulpv2(
    uint32_t N,
    int32_t fracBits,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Create a 32-bit fix-point identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q32_parallel">function plp_mat_fill_I_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q32_parallel(
    uint32_t N,
    int32_t fracBits,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 32-bit fix-point identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q32p_xpulpv2">function plp_mat_fill_I_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a 32-bit fix-point identity matrix in parallel on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__q32/">plp_mat_fill_I_instance_q32</a> struct initialized by plp_mat_fill_I_q32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__q32/">plp_mat_fill_I_instance_q32</a> struct initialized by plp_mat_fill_I_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q16">function plp_mat_fill_I_q16</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q16(
    uint32_t N,
    int32_t fracBits,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 16-bit fix-point identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q16s_rv32im">function plp_mat_fill_I_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q16s_rv32im(
    uint32_t N,
    int32_t fracBits,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Create a 16-bit fix-point identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q16s_xpulpv2">function plp_mat_fill_I_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q16s_xpulpv2(
    uint32_t N,
    int32_t fracBits,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Create a 16-bit fix-point identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_fill_i_q16_parallel">function plp_mat_fill_I_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q16_parallel(
    uint32_t N,
    int32_t fracBits,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 16-bit fix-point identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q16p_xpulpv2">function plp_mat_fill_I_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a 16-bit fix-point identity matrix in parallel on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__q16/">plp_mat_fill_I_instance_q16</a> struct initialized by plp_mat_fill_I_q16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__q16/">plp_mat_fill_I_instance_q16</a> struct initialized by plp_mat_fill_I_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_fill_i_q8">function plp_mat_fill_I_q8</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q8(
    uint32_t N,
    int32_t fracBits,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 8-bit fix-point identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q8s_rv32im">function plp_mat_fill_I_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q8s_rv32im(
    uint32_t N,
    int32_t fracBits,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Create a 8-bit fix-point identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q8s_xpulpv2">function plp_mat_fill_I_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q8s_xpulpv2(
    uint32_t N,
    int32_t fracBits,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Create a 8-bit fix-point identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_fill_i_q8_parallel">function plp_mat_fill_I_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q8_parallel(
    uint32_t N,
    int32_t fracBits,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a 8-bit fix-point identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix of shape NxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_q8p_xpulpv2">function plp_mat_fill_I_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a 8-bit fix-point identity matrix in parallel on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__q8/">plp_mat_fill_I_instance_q8</a> struct initialized by plp_mat_fill_I_q8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__instance__q8/">plp_mat_fill_I_instance_q8</a> struct initialized by plp_mat_fill_I_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_stride_i32">function plp_mat_mult_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix matrix multiplication of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix matrix multiplication of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_stride_i32s_rv32im">function plp_mat_mult_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix matrix multiplication of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_stride_i32s_xpulpv2">function plp_mat_mult_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_i16">function plp_mat_mult_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix matrix multiplication of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix matrix multiplication of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_stride_i16s_rv32im">function plp_mat_mult_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix matrix multiplication of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_stride_i16s_xpulpv2">function plp_mat_mult_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>strided matrix matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_i8">function plp_mat_mult_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix matrix multiplication of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix matrix multiplication of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_stride_i8s_rv32im">function plp_mat_mult_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix matrix multiplication of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_stride_i8s_xpulpv2">function plp_mat_mult_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>strided matrix matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_i32_parallel">function plp_mat_mult_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix matrix multiplication of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix matrix multiplication of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_stride_i32p_xpulpv2">function plp_mat_mult_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i32/">plp_mat_mult_stride_instance_i32</a> struct initialized by plp_mat_mult_stride_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i32/">plp_mat_mult_stride_instance_i32</a> struct initialized by plp_mat_mult_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel strided matrix matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_i16_parallel">function plp_mat_mult_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix matrix multiplication of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix matrix multiplication of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_stride_i16p_xpulpv2">function plp_mat_mult_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 16-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i16/">plp_mat_mult_stride_instance_i16</a> struct initialized by plp_mat_mult_stride_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i16/">plp_mat_mult_stride_instance_i16</a> struct initialized by plp_mat_mult_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<p>Parallel matrix multiplication of 16-bit integer matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_i8_parallel">function plp_mat_mult_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix matrix multiplication of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix matrix multiplication of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_stride_f32">function plp_mat_mult_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix matrix multiplication of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix matrix multiplication of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_mult_stride_f32s_xpulpv2">function plp_mat_mult_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    float *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_f32_parallel">function plp_mat_mult_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix matrix multiplication of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix matrix multiplication of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_mult_stride_f32p_xpulpv2">function plp_mat_mult_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__f32/">plp_mat_mult_stride_instance_f32</a> struct initialized by plp_mat_mult_stride_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__f32/">plp_mat_mult_stride_instance_f32</a> struct initialized by plp_mat_mult_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_i8p_xpulpv2">function plp_mat_mult_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 8-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i8/">plp_mat_mult_stride_instance_i8</a> struct initialized by plp_mat_mult_stride_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i8/">plp_mat_mult_stride_instance_i8</a> struct initialized by plp_mat_mult_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<p>Parallel matrix multiplication of 8-bit integer matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_q32">function plp_mat_mult_stride_q32</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix matrix multiplication of a 32-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Glue code for strided matrix matrix multiplication of a 32-bit fix-point matrices.</p>
<h3 id="function-plp_mat_mult_stride_q32_parallel">function plp_mat_mult_stride_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix matrix multiplication of a 32-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Glue code for parallel strided matrix matrix multiplication of a 32-bit fix-point matrices.</p>
<h3 id="function-plp_mat_mult_stride_q32s_rv32im">function plp_mat_mult_stride_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 32-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>strided matrix matrix multiplication of a 32-bit fix-point matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_stride_q32s_xpulpv2">function plp_mat_mult_stride_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>strided matrix matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_q32p_xpulpv2">function plp_mat_mult_stride_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q32/">plp_mat_mult_stride_instance_q32</a> struct initialized by plp_mat_mult_stride_q32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q32/">plp_mat_mult_stride_instance_q32</a> struct initialized by plp_mat_mult_stride_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Parallel matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_stride_q16">function plp_mat_mult_stride_q16</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix matrix multiplication of a 16-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for strided matrix matrix multiplication of a 16-bit fix-point matrices.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_stride_q16_parallel">function plp_mat_mult_stride_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix matrix multiplication of a 16-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for parallel strided matrix matrix multiplication of a 16-bit fix-point matrices.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_stride_q16s_rv32im">function plp_mat_mult_stride_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 16-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>strided matrix matrix multiplication of a 16-bit fix-point matrices for RV32IM extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_stride_q16s_xpulpv2">function plp_mat_mult_stride_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>strided matrix matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_stride_q16p_xpulpv2">function plp_mat_mult_stride_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q16/">plp_mat_mult_stride_instance_q16</a> struct initialized by plp_mat_mult_stride_q16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q16/">plp_mat_mult_stride_instance_q16</a> struct initialized by plp_mat_mult_stride_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>Parallel matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_stride_q8">function plp_mat_mult_stride_q8</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix matrix multiplication of a 8-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for strided matrix matrix multiplication of a 8-bit fix-point matrices.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_stride_q8_parallel">function plp_mat_mult_stride_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix matrix multiplication of a 8-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for parallel strided matrix matrix multiplication of a 8-bit fix-point matrices.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_stride_q8s_rv32im">function plp_mat_mult_stride_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 8-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>strided matrix matrix multiplication of a 8-bit fix-point matrices for RV32IM extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_stride_q8s_xpulpv2">function plp_mat_mult_stride_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>strided matrix matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_stride_q8p_xpulpv2">function plp_mat_mult_stride_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_stride_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q8/">plp_mat_mult_stride_instance_q8</a> struct initialized by plp_mat_mult_stride_q8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q8/">plp_mat_mult_stride_instance_q8</a> struct initialized by plp_mat_mult_stride_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>Parallel matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_i32">function plp_mat_mult_trans_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix transposed matrix multiplication of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix transposed matrix multiplication of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_i32s_rv32im">function plp_mat_mult_trans_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_i32s_xpulpv2">function plp_mat_mult_trans_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transposed matrix multiplication of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_i16">function plp_mat_mult_trans_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix transposed matrix multiplication of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix transposed matrix multiplication of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_i16s_rv32im">function plp_mat_mult_trans_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transposed matrix multiplication of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_i16s_xpulpv2">function plp_mat_mult_trans_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>strided matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_i8">function plp_mat_mult_trans_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix transposed matrix multiplication of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix transposed matrix multiplication of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_i8s_rv32im">function plp_mat_mult_trans_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transposed matrix multiplication of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_i8s_xpulpv2">function plp_mat_mult_trans_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>strided matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_i32_parallel">function plp_mat_mult_trans_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix matrix multiplication of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix matrix multiplication of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_i32p_xpulpv2">function plp_mat_mult_trans_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i32/">plp_mat_mult_stride_instance_i32</a> struct initialized by plp_mat_mult_stride_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i32/">plp_mat_mult_stride_instance_i32</a> struct initialized by plp_mat_mult_trans_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel strided matrix transposed matrix multiplication of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_i16_parallel">function plp_mat_mult_trans_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_i16p_xpulpv2">function plp_mat_mult_trans_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i16/">plp_mat_mult_stride_instance_i16</a> struct initialized by plp_mat_mult_stride_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i16/">plp_mat_mult_stride_instance_i16</a> struct initialized by plp_mat_mult_trans_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<p>Parallel strided matrix transposed matrix multiplication of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_i8_parallel">function plp_mat_mult_trans_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_i8p_xpulpv2">function plp_mat_mult_trans_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i8/">plp_mat_mult_stride_instance_i8</a> struct initialized by plp_mat_mult_stride_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__i8/">plp_mat_mult_stride_instance_i8</a> struct initialized by plp_mat_mult_trans_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<p>Parallel strided matrix transposed matrix multiplication of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_q32">function plp_mat_mult_trans_stride_q32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix transposed matrix multiplication of a 32-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Glue code for strided matrix transposed matrix multiplication of a 32-bit fix-point matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_q32_parallel">function plp_mat_mult_trans_stride_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 32-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 32-bit fix-point matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_q32s_rv32im">function plp_mat_mult_trans_stride_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 32-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>strided matrix transposed matrix multiplication of a 32-bit fix-point matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_q32s_xpulpv2">function plp_mat_mult_trans_stride_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>strided matrix transposed matrix multiplication of a 32-bit fix-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_q32p_xpulpv2">function plp_mat_mult_trans_stride_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix transposed matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q32/">plp_mat_mult_stride_instance_q32</a> struct initialized by plp_mat_mult_trans_stride_q32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q32/">plp_mat_mult_stride_instance_q32</a> struct initialized by plp_mat_mult_trans_stride_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift). </p>
<hr />
<p>Parallel strided matrix transposed matrix multiplication of 32-bit fix-point matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_q16">function plp_mat_mult_trans_stride_q16</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix transposed matrix multiplication of a 16-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for strided matrix transposed matrix multiplication of a 16-bit fix-point matrices.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_q16_parallel">function plp_mat_mult_trans_stride_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 16-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 16-bit fix-point matrices.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_q16s_rv32im">function plp_mat_mult_trans_stride_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 16-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>strided matrix transposed matrix multiplication of a 16-bit fix-point matrices for RV32IM extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_q16s_xpulpv2">function plp_mat_mult_trans_stride_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>strided matrix transposed matrix multiplication of a 16-bit fix-point matrices for XPULPV2 extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_q16p_xpulpv2">function plp_mat_mult_trans_stride_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix transposed matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q16/">plp_mat_mult_stride_instance_q16</a> struct initialized by plp_mat_mult_trans_stride_q16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q16/">plp_mat_mult_stride_instance_q16</a> struct initialized by plp_mat_mult_trans_stride_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>Parallel strided matrix transposed matrix multiplication of 16-bit fix-point matrices kernel for XPULPV2 extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 16-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_q8">function plp_mat_mult_trans_stride_q8</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix transposed matrix multiplication of a 8-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for strided matrix transposed matrix multiplication of a 8-bit fix-point matrices.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_q8_parallel">function plp_mat_mult_trans_stride_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 8-bit fix-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 8-bit fix-point matrices.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_q8s_rv32im">function plp_mat_mult_trans_stride_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 8-bit fix-point matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>strided matrix transposed matrix multiplication of a 8-bit fix-point matrices for RV32IM extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_q8s_xpulpv2">function plp_mat_mult_trans_stride_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication. </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point and Shifting</li>
</ul>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).
  * Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>The output of the matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs.</p>
<p>strided matrix transposed matrix multiplication of a 8-bit fix-point matrices for XPULPV2 extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_q8p_xpulpv2">function plp_mat_mult_trans_stride_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix transposed matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q8/">plp_mat_mult_stride_instance_q8</a> struct initialized by plp_mat_mult_trans_stride_q8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__q8/">plp_mat_mult_stride_instance_q8</a> struct initialized by plp_mat_mult_trans_stride_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: Fix-Point and Shifting</p>
<p>The result will be shifted by the parameter <code>shift</code> to the right (multiplied by 2^-shift). Assume that matrix A is represented as pSrcA * 2^-x, and matrix B as pSrcB * 2^-y (in other words, A has it's x last digits after the binary point). Then, the output is represented as pDstC * 2^-(x + y - shift).</p>
<hr />
<p>Parallel strided matrix transposed matrix multiplication of 8-bit fix-point matrices kernel for XPULPV2 extension.</p>
<p>The output of the strided matrix multiplication will also be stored as an 8-bit array. Set the <code>shift</code> parameter such that no overflow ocurrs. </p>
<h3 id="function-plp_mat_mult_trans_stride_f32">function plp_mat_mult_trans_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code for strided matrix transposed matrix multiplication of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix transposed matrix multiplication of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_f32s_xpulpv2">function plp_mat_mult_trans_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    float *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transposed matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transposed matrix multiplication of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_trans_stride_f32_parallel">function plp_mat_mult_trans_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to first the input matrix </li>
<li><strong>pSrcB</strong> points to second the input matrix </li>
<li><strong>M</strong> Height of first matrix </li>
<li><strong>N</strong> Width of first and heigt of second matrix </li>
<li><strong>O</strong> Width of second matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strudeY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> Output is written here </li>
<li><strong>pSrcA</strong> points to the first input matrix </li>
<li><strong>pSrcB</strong> points to the second input matrix </li>
<li><strong>M</strong> height of the first input matrix </li>
<li><strong>N</strong> width of the first input matrix and hight of the second </li>
<li><strong>O</strong> width of the second input matrix </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDstC</strong> points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix transposed matrix multiplication of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_mult_trans_stride_f32p_xpulpv2">function plp_mat_mult_trans_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix transposed matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__f32/">plp_mat_mult_stride_instance_f32</a> struct initialized by plp_mat_mult_trans_stride_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__stride__instance__f32/">plp_mat_mult_stride_instance_f32</a> struct initialized by plp_mat_mult_trans_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel strided matrix transposed matrix multiplication of 32-bit floating-point matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_mult_cmplx_stride_i32">function plp_mat_mult_cmplx_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix matrix multiplication for complex 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i32s_rv32im">function plp_mat_mult_cmplx_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 32-bit integers on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i32s_xpulpv2">function plp_mat_mult_cmplx_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 32-bit integers on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i32_parallel">function plp_mat_mult_cmplx_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix matrix multiplication for complex 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i32p_xpulpv2">function plp_mat_mult_cmplx_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix matrix multiplication for complex 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__i32/">plp_mat_mult_cmplx_stride_instance_i32</a> struct initialized by plp_mat_mult_cmplx_stride_i32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_i32 struct initialized by plp_mat_mult_cmplx_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i16">function plp_mat_mult_cmplx_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix matrix multiplication for complex 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i16s_rv32im">function plp_mat_mult_cmplx_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 16-bit integers on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i16s_xpulpv2">function plp_mat_mult_cmplx_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 16-bit integers on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i16_parallel">function plp_mat_mult_cmplx_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix matrix multiplication for complex 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i16p_xpulpv2">function plp_mat_mult_cmplx_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix matrix multiplication for complex 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__i16/">plp_mat_mult_cmplx_stride_instance_i16</a> struct initialized by plp_mat_mult_cmplx_stride_i16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_i16 struct initialized by plp_mat_mult_cmplx_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i8">function plp_mat_mult_cmplx_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix matrix multiplication for complex 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i8s_rv32im">function plp_mat_mult_cmplx_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 8-bit integers on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i8s_xpulpv2">function plp_mat_mult_cmplx_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 8-bit integers on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i8_parallel">function plp_mat_mult_cmplx_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix matrix multiplication for complex 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_i8p_xpulpv2">function plp_mat_mult_cmplx_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix matrix multiplication for complex 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__i8/">plp_mat_mult_cmplx_stride_instance_i8</a> struct initialized by plp_mat_mult_cmplx_stride_i8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_i8 struct initialized by plp_mat_mult_cmplx_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_f32">function plp_mat_mult_cmplx_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix matrix multiplication for complex 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_f32s_xpulpv2">function plp_mat_mult_cmplx_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    float *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 32-bit floats on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_f32_parallel">function plp_mat_mult_cmplx_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix matrix multiplication for complex 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_f32p_xpulpv2">function plp_mat_mult_cmplx_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix matrix multiplication for complex 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__f32/">plp_mat_mult_cmplx_stride_instance_f32</a> struct initialized by plp_mat_mult_cmplx_stride_f32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_f32 struct initialized by plp_mat_mult_cmplx_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q32">function plp_mat_mult_cmplx_stride_q32</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix matrix multiplication for complex 32-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q32s_rv32im">function plp_mat_mult_cmplx_stride_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 32-bit fix-point on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q32s_xpulpv2">function plp_mat_mult_cmplx_stride_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 32-bit fix-point on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q32_parallel">function plp_mat_mult_cmplx_stride_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix matrix multiplication for complex 32-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q32p_xpulpv2">function plp_mat_mult_cmplx_stride_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix matrix multiplication for complex 32-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__q32/">plp_mat_mult_cmplx_stride_instance_q32</a> struct initialized by plp_mat_mult_cmplx_stride_q32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_q32 struct initialized by plp_mat_mult_cmplx_stride_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q16">function plp_mat_mult_cmplx_stride_q16</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix matrix multiplication for complex 16-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q16s_rv32im">function plp_mat_mult_cmplx_stride_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 16-bit fix-point on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q16s_xpulpv2">function plp_mat_mult_cmplx_stride_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 16-bit fix-point on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q16_parallel">function plp_mat_mult_cmplx_stride_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix matrix multiplication for complex 16-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q16p_xpulpv2">function plp_mat_mult_cmplx_stride_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix matrix multiplication for complex 16-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__q16/">plp_mat_mult_cmplx_stride_instance_q16</a> struct initialized by plp_mat_mult_cmplx_stride_q16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_q16 struct initialized by plp_mat_mult_cmplx_stride_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q8">function plp_mat_mult_cmplx_stride_q8</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix matrix multiplication for complex 8-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q8s_rv32im">function plp_mat_mult_cmplx_stride_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 8-bit fix-point on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q8s_xpulpv2">function plp_mat_mult_cmplx_stride_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Strided strided matrix matrix multiplication for complex 8-bit fix-point on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q8_parallel">function plp_mat_mult_cmplx_stride_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix matrix multiplication for complex 8-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape NxO </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and height of matrix SrcB </li>
<li><strong>O</strong> Width of matrix SrcB and DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_cmplx_stride_q8p_xpulpv2">function plp_mat_mult_cmplx_stride_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_cmplx_stride_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix matrix multiplication for complex 8-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__q8/">plp_mat_mult_cmplx_stride_instance_q8</a> struct initialized by plp_mat_mult_cmplx_stride_q8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_cmplx_instance_q8 struct initialized by plp_mat_mult_cmplx_stride_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i32">function plp_mat_mult_trans_cmplx_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix transpose matrix multiplication for complex 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i32s_rv32im">function plp_mat_mult_trans_cmplx_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 32-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transpose matrix multiplication for complex 32-bit integers on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i32s_xpulpv2">function plp_mat_mult_trans_cmplx_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i32_parallel">function plp_mat_mult_trans_cmplx_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix transpose matrix multiplication for complex 32-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i32p_xpulpv2">function plp_mat_mult_trans_cmplx_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix transpose matrix multiplication for complex 32-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__i32/">plp_mat_mult_cmplx_stride_instance_i32</a> struct initialized by plp_mat_mult_trans_cmplx_stride_i32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_i32 struct initialized by plp_mat_mult_trans_cmplx_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i16">function plp_mat_mult_trans_cmplx_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix transpose matrix multiplication for complex 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i16s_rv32im">function plp_mat_mult_trans_cmplx_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 16-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transpose matrix multiplication for complex 16-bit integers on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i16s_xpulpv2">function plp_mat_mult_trans_cmplx_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>strided matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i16_parallel">function plp_mat_mult_trans_cmplx_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix transpose matrix multiplication for complex 16-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i16p_xpulpv2">function plp_mat_mult_trans_cmplx_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix transpose matrix multiplication for complex 16-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__i16/">plp_mat_mult_cmplx_stride_instance_i16</a> struct initialized by plp_mat_mult_trans_cmplx_stride_i16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_i16 struct initialized by plp_mat_mult_trans_cmplx_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i8">function plp_mat_mult_trans_cmplx_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix transpose matrix multiplication for complex 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i8s_rv32im">function plp_mat_mult_trans_cmplx_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 8-bit integers on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transpose matrix multiplication for complex 8-bit integers on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i8s_xpulpv2">function plp_mat_mult_trans_cmplx_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>strided matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i8_parallel">function plp_mat_mult_trans_cmplx_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix transpose matrix multiplication for complex 8-bit integers. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_i8p_xpulpv2">function plp_mat_mult_trans_cmplx_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix transpose matrix multiplication for complex 8-bit integers on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__i8/">plp_mat_mult_cmplx_stride_instance_i8</a> struct initialized by plp_mat_mult_trans_cmplx_stride_i8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_i8 struct initialized by plp_mat_mult_trans_cmplx_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_f32">function plp_mat_mult_trans_cmplx_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix transpose matrix multiplication for complex 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_f32s_xpulpv2">function plp_mat_mult_trans_cmplx_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    float *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_f32_parallel">function plp_mat_mult_trans_cmplx_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t nPE,
    float *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix transpose matrix multiplication for complex 32-bit floats. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_f32p_xpulpv2">function plp_mat_mult_trans_cmplx_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix transpose matrix multiplication for complex 32-bit floats on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__f32/">plp_mat_mult_cmplx_stride_instance_f32</a> struct initialized by plp_mat_mult_trans_cmplx_stride_f32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_f32 struct initialized by plp_mat_mult_trans_cmplx_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q32">function plp_mat_mult_trans_cmplx_stride_q32</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix transpose matrix multiplication for complex 32-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q32s_rv32im">function plp_mat_mult_trans_cmplx_stride_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 32-bit fix-point on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>strided matrix transpose matrix multiplication for complex 32-bit fix-point on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q32s_xpulpv2">function plp_mat_mult_trans_cmplx_stride_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>strided matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q32_parallel">function plp_mat_mult_trans_cmplx_stride_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix transpose matrix multiplication for complex 32-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q32p_xpulpv2">function plp_mat_mult_trans_cmplx_stride_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix transpose matrix multiplication for complex 32-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__q32/">plp_mat_mult_cmplx_stride_instance_q32</a> struct initialized by plp_mat_mult_trans_cmplx_stride_q32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_q32 struct initialized by plp_mat_mult_trans_cmplx_stride_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q16">function plp_mat_mult_trans_cmplx_stride_q16</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix transpose matrix multiplication for complex 16-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q16s_rv32im">function plp_mat_mult_trans_cmplx_stride_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 16-bit fix-point on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>strided matrix transpose matrix multiplication for complex 16-bit fix-point on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q16s_xpulpv2">function plp_mat_mult_trans_cmplx_stride_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>strided matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q16_parallel">function plp_mat_mult_trans_cmplx_stride_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix transpose matrix multiplication for complex 16-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q16p_xpulpv2">function plp_mat_mult_trans_cmplx_stride_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix transpose matrix multiplication for complex 16-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__q16/">plp_mat_mult_cmplx_stride_instance_q16</a> struct initialized by plp_mat_mult_trans_cmplx_stride_q16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_q16 struct initialized by plp_mat_mult_trans_cmplx_stride_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q8">function plp_mat_mult_trans_cmplx_stride_q8</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of strided matrix transpose matrix multiplication for complex 8-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q8s_rv32im">function plp_mat_mult_trans_cmplx_stride_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 8-bit fix-point on RV32IM </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>strided matrix transpose matrix multiplication for complex 8-bit fix-point on RV32IM</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q8s_xpulpv2">function plp_mat_mult_trans_cmplx_stride_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>strided matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<p>strided matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2</p>
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q8_parallel">function plp_mat_mult_trans_cmplx_stride_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t O,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideC,
    uint32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDstC
)
</code></pre>
<p>Glue code of parallel strided matrix transpose matrix multiplication for complex 8-bit fix-point. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
<li><strong>pSrcA</strong> Points to the first input matrix of shape MxN </li>
<li><strong>pSrcB</strong> Points to the second input matrix of shape OxN </li>
<li><strong>M</strong> Height of matrix SrcA and DstC </li>
<li><strong>N</strong> Width of matrix SrcA and SrcB </li>
<li><strong>O</strong> Height of matrix SrcB and width of matrix DstC </li>
<li><strong>strideA</strong> Stride of input matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of input matrix B (elements between each row) </li>
<li><strong>strideC</strong> Stride of output matrix C (Elements between each row) </li>
<li><strong>shift</strong> Amount to shift the result of each multiplication ot the right </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDstC</strong> Points to the output matrix of shape MxO </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs. </p>
<hr />
<h3 id="function-plp_mat_mult_trans_cmplx_stride_q8p_xpulpv2">function plp_mat_mult_trans_cmplx_stride_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_mult_trans_cmplx_stride_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>parallel strided matrix transpose matrix multiplication for complex 8-bit fix-point on XpulpV2 </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__mult__cmplx__stride__instance__q8/">plp_mat_mult_cmplx_stride_instance_q8</a> struct initialized by plp_mat_mult_trans_cmplx_stride_q8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_mult_trans_cmplx_instance_q8 struct initialized by plp_mat_mult_trans_cmplx_stride_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>Fix-Point and Shifting The result will be shifted by the parameter <code>shift</code> to the right (which corresponds to a multiplication by <code>2^-shift</code>). Assume that matrix A is represente as <code>pSrcA * 2^-x</code> and matrix B as <code>pSrcB * 2^-y</code> (which means that A has <code>x</code>, and B has <code>y</code> bits after the binary point). Then, the output matrix C is represented as <code>pDstC * 2^-(x + y - shift)</code>. The output matrix is also stored with the same number of bits as the inputs. Set the <code>shift</code> parameter such that no overflow occurrs.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_add_stride_i32">function plp_mat_add_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix addition of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix addition of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_add_stride_i32s_rv32im">function plp_mat_add_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_add_stride_i32s_xpulpv2">function plp_mat_add_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_stride_i32_parallel">function plp_mat_add_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix addition of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix addition of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_add_stride_i32p_xpulpv2">function plp_mat_add_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix addition of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__i32/">plp_mat_add_stride_instance_i32</a> struct initialized by plp_mat_add_stride_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__i32/">plp_mat_add_stride_instance_i32</a> struct initialized by plp_mat_add_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix addition of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_stride_i16">function plp_mat_add_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix addition of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix addition of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_add_stride_i16s_rv32im">function plp_mat_add_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_add_stride_i16s_xpulpv2">function plp_mat_add_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix addition of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_stride_i16_parallel">function plp_mat_add_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix addition of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix addition of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_add_stride_i16p_xpulpv2">function plp_mat_add_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix addition of 16-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__i16/">plp_mat_add_stride_instance_i16</a> struct initialized by plp_mat_add_stride_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__i16/">plp_mat_add_stride_instance_i16</a> struct initialized by plp_mat_add_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<p>Parallel matrix addition of 16-bit integer matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_stride_i8">function plp_mat_add_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix addition of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix addition of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_add_stride_i8s_rv32im">function plp_mat_add_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_add_stride_i8s_xpulpv2">function plp_mat_add_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix addition of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_stride_i8_parallel">function plp_mat_add_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix addition of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix addition of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_add_stride_i8p_xpulpv2">function plp_mat_add_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix addition of 8-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__i8/">plp_mat_add_stride_instance_i8</a> struct initialized by plp_mat_add_stride_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__i8/">plp_mat_add_stride_instance_i8</a> struct initialized by plp_mat_add_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<p>Parallel matrix addition of 8-bit integer matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_stride_f32">function plp_mat_add_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix addition of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) <PARALLEL_ARG_DOC> </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix addition of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_add_stride_f32s_xpulpv2">function plp_mat_add_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    float *__restrict__ pDst
)
</code></pre>
<p>matrix addition of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix addition of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_add_stride_f32_parallel">function plp_mat_add_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix addition of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix addition of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_add_stride_f32p_xpulpv2">function plp_mat_add_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_add_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix addition of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__f32/">plp_mat_add_stride_instance_f32</a> struct initialized by plp_mat_add_stride_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__add__stride__instance__f32/">plp_mat_add_stride_instance_f32</a> struct initialized by plp_mat_add_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix addition of 32-bit floating-point matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_stride_i32">function plp_mat_sub_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix subtraction of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix subtraction of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_stride_i32s_rv32im">function plp_mat_sub_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_sub_stride_i32s_xpulpv2">function plp_mat_sub_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_stride_i32_parallel">function plp_mat_sub_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix subtraction of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix subtraction of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_stride_i32p_xpulpv2">function plp_mat_sub_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix subtraction of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__i32/">plp_mat_sub_stride_instance_i32</a> struct initialized by plp_mat_sub_stride_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__i32/">plp_mat_sub_stride_instance_i32</a> struct initialized by plp_mat_sub_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix subtraction of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_stride_i16">function plp_mat_sub_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix subtraction of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix subtraction of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_stride_i16s_rv32im">function plp_mat_sub_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_sub_stride_i16s_xpulpv2">function plp_mat_sub_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix subtraction of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_stride_i16_parallel">function plp_mat_sub_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i16_parallel(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix subtraction of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix subtraction of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_stride_i16p_xpulpv2">function plp_mat_sub_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix subtraction of 16-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__i16/">plp_mat_sub_stride_instance_i16</a> struct initialized by plp_mat_sub_stride_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__i16/">plp_mat_sub_stride_instance_i16</a> struct initialized by plp_mat_sub_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<p>Parallel matrix subtraction of 16-bit integer matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_stride_i8">function plp_mat_sub_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix subtraction of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix subtraction of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_stride_i8s_rv32im">function plp_mat_sub_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i8s_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_sub_stride_i8s_xpulpv2">function plp_mat_sub_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i8s_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>matrix subtraction of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_stride_i8_parallel">function plp_mat_sub_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i8_parallel(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix subtraction of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix subtraction of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_sub_stride_i8p_xpulpv2">function plp_mat_sub_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix subtraction of 8-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__i8/">plp_mat_sub_stride_instance_i8</a> struct initialized by plp_mat_sub_stride_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__i8/">plp_mat_sub_stride_instance_i8</a> struct initialized by plp_mat_sub_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<p>Parallel matrix subtraction of 8-bit integer matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_stride_f32">function plp_mat_sub_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_f32(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for matrix subtraction of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) <PARALLEL_ARG_DOC> </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for matrix subtraction of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_sub_stride_f32s_xpulpv2">function plp_mat_sub_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_f32s_xpulpv2(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    float *__restrict__ pDst
)
</code></pre>
<p>matrix subtraction of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>matrix subtraction of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_sub_stride_f32_parallel">function plp_mat_sub_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_f32_parallel(
    const float *__restrict__ pSrcA,
    const float *__restrict__ pSrcB,
    uint32_t M,
    uint32_t N,
    uint32_t strideA,
    uint32_t strideB,
    uint32_t strideY,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel matrix subtraction of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of the matrices </li>
<li><strong>N</strong> Width of the matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrix B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrcA</strong> Points to the first input matrix </li>
<li><strong>pSrcB</strong> Points to the second input matrix </li>
<li><strong>M</strong> Height of all matrices </li>
<li><strong>N</strong> Width of all matrices </li>
<li><strong>strideA</strong> Stride of matrix A (elements between each row) </li>
<li><strong>strideB</strong> Stride of matrid B (elements between each row) </li>
<li><strong>strideY</strong> Stride of output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel matrix subtraction of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_sub_stride_f32p_xpulpv2">function plp_mat_sub_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_sub_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel matrix subtraction of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__f32/">plp_mat_sub_stride_instance_f32</a> struct initialized by plp_mat_sub_stride_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__sub__stride__instance__f32/">plp_mat_sub_stride_instance_f32</a> struct initialized by plp_mat_sub_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel matrix subtraction of 32-bit floating-point matrices kernel for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_stride_i32">function plp_mat_scale_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i32(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int32_t scaleFactor,
    int32_t shift,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for strided matrix scale of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix scale of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_stride_i32s_rv32im">function plp_mat_scale_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int32_t scaleFactor,
    int32_t shift,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>strided matrix scale of a 32-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix scale of a 32-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_scale_stride_i32s_xpulpv2">function plp_mat_scale_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int32_t scaleFactor,
    int32_t shift,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>strided matrix scale of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix scale of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_stride_i32_parallel">function plp_mat_scale_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i32_parallel(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int32_t scaleFactor,
    int32_t shift,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel strided matrix scale of a 32-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix scale of a 32-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_stride_i32p_xpulpv2">function plp_mat_scale_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix scale of a 32-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__i32/">plp_mat_scale_stride_instance_i32</a> struct initialized by plp_mat_scale_stride_i32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__i32/">plp_mat_scale_stride_instance_i32</a> struct initialized by plp_mat_scale_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Parallel strided matrix scale of a 32-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_stride_i16">function plp_mat_scale_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i16(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int16_t scaleFactor,
    int32_t shift,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for strided matrix scale of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix scale of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_stride_i16s_rv32im">function plp_mat_scale_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int16_t scaleFactor,
    int32_t shift,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>strided matrix scale of a 16-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix scale of a 16-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_scale_stride_i16s_xpulpv2">function plp_mat_scale_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int16_t scaleFactor,
    int32_t shift,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>strided matrix scale of a 16-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>strided matrix scale of a 16-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_stride_i16_parallel">function plp_mat_scale_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i16_parallel(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int16_t scaleFactor,
    int32_t shift,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel strided matrix scale of a 16-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix scale of a 16-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_stride_i16p_xpulpv2">function plp_mat_scale_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix scale of 16-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__i16/">plp_mat_scale_stride_instance_i16</a> struct initialized by plp_mat_scale_stride_i16_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__i16/">plp_mat_scale_stride_instance_i16</a> struct initialized by plp_mat_scale_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_scale_stride_i8">function plp_mat_scale_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i8(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int8_t scaleFactor,
    int32_t shift,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for strided matrix scale of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix scale of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_stride_i8s_rv32im">function plp_mat_scale_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int8_t scaleFactor,
    int32_t shift,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>strided matrix scale of a 8-bit integer matrices for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix scale of a 8-bit integer matrices for RV32IM extension.</p>
<h3 id="function-plp_mat_scale_stride_i8s_xpulpv2">function plp_mat_scale_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int8_t scaleFactor,
    int32_t shift,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>strided matrix scale of a 8-bit integer matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<p>strided matrix scale of a 8-bit integer matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_stride_i8_parallel">function plp_mat_scale_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i8_parallel(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int8_t scaleFactor,
    int32_t shift,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel strided matrix scale of a 8-bit integer matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements before shifting </li>
<li><strong>shift</strong> Amount to shift each element </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix scale of a 8-bit integer matrices.</p>
<h3 id="function-plp_mat_scale_stride_i8p_xpulpv2">function plp_mat_scale_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix scale of 8-bit integer matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__i8/">plp_mat_scale_stride_instance_i8</a> struct initialized by plp_mat_scale_stride_i8_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__i8/">plp_mat_scale_stride_instance_i8</a> struct initialized by plp_mat_scale_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_scale_stride_f32">function plp_mat_scale_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_f32(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    float scaleFactor,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for strided matrix scale of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for strided matrix scale of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_scale_stride_f32s_xpulpv2">function plp_mat_scale_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    float scaleFactor,
    float *__restrict__ pDst
)
</code></pre>
<p>strided matrix scale of a 32-bit floating-point matrices for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>strided matrix scale of a 32-bit floating-point matrices for XPULPV2 extension.</p>
<h3 id="function-plp_mat_scale_stride_f32_parallel">function plp_mat_scale_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_f32_parallel(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    float scaleFactor,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for parallel strided matrix scale of a 32-bit floating-point matrices. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride for input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride for output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>pSrc</strong> Points to the input matrix </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of output matrix (elements between each row) </li>
<li><strong>scaleFactor</strong> Factor to mulitply all elements </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Glue code for parallel strided matrix scale of a 32-bit floating-point matrices.</p>
<h3 id="function-plp_mat_scale_stride_f32p_xpulpv2">function plp_mat_scale_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_scale_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Parallel strided matrix scale of 32-bit floating-point matrices kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__f32/">plp_mat_scale_stride_instance_f32</a> struct initialized by plp_mat_scale_stride_f32_parallel </li>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__scale__stride__instance__f32/">plp_mat_scale_stride_instance_f32</a> struct initialized by plp_mat_scale_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i32">function plp_mat_fill_I_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i32(
    uint32_t N,
    uint32_t stride,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 32-bit integers identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i32s_rv32im">function plp_mat_fill_I_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i32s_rv32im(
    uint32_t N,
    uint32_t stride,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 32-bit integers identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Create a strided 32-bit integers identity matrix on RV32IM.</p>
<h3 id="function-plp_mat_fill_i_stride_i32s_xpulpv2">function plp_mat_fill_I_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i32s_xpulpv2(
    uint32_t N,
    uint32_t stride,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 32-bit integers identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i32_parallel">function plp_mat_fill_I_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i32_parallel(
    uint32_t N,
    uint32_t stride,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 32-bit integers identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i32p_xpulpv2">function plp_mat_fill_I_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a strided 32-bit integers identity matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__i32/">plp_mat_fill_I_stride_instance_i32</a> struct initialized by plp_mat_fill_I_stride_i32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_I_stride_instance_i32 struct initialized by plp_mat_fill_I_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i16">function plp_mat_fill_I_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i16(
    uint32_t N,
    uint32_t stride,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 16-bit integers identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i16s_rv32im">function plp_mat_fill_I_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i16s_rv32im(
    uint32_t N,
    uint32_t stride,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 16-bit integers identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Create a strided 16-bit integers identity matrix on RV32IM.</p>
<h3 id="function-plp_mat_fill_i_stride_i16s_xpulpv2">function plp_mat_fill_I_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i16s_xpulpv2(
    uint32_t N,
    uint32_t stride,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 16-bit integers identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i16_parallel">function plp_mat_fill_I_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i16_parallel(
    uint32_t N,
    uint32_t stride,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 16-bit integers identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i16p_xpulpv2">function plp_mat_fill_I_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a strided 16-bit integers identity matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__i16/">plp_mat_fill_I_stride_instance_i16</a> struct initialized by plp_mat_fill_I_stride_i16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_I_stride_instance_i16 struct initialized by plp_mat_fill_I_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i8">function plp_mat_fill_I_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i8(
    uint32_t N,
    uint32_t stride,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 8-bit integers identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i8s_rv32im">function plp_mat_fill_I_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i8s_rv32im(
    uint32_t N,
    uint32_t stride,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 8-bit integers identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<p>Create a strided 8-bit integers identity matrix on RV32IM.</p>
<h3 id="function-plp_mat_fill_i_stride_i8s_xpulpv2">function plp_mat_fill_I_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i8s_xpulpv2(
    uint32_t N,
    uint32_t stride,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 8-bit integers identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i8_parallel">function plp_mat_fill_I_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i8_parallel(
    uint32_t N,
    uint32_t stride,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 8-bit integers identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_i8p_xpulpv2">function plp_mat_fill_I_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a strided 8-bit integers identity matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__i8/">plp_mat_fill_I_stride_instance_i8</a> struct initialized by plp_mat_fill_I_stride_i8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_I_stride_instance_i8 struct initialized by plp_mat_fill_I_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_f32">function plp_mat_fill_I_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_f32(
    uint32_t N,
    uint32_t stride,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 32-bit floats identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_f32s_xpulpv2">function plp_mat_fill_I_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_f32s_xpulpv2(
    uint32_t N,
    uint32_t stride,
    float *__restrict__ pDst
)
</code></pre>
<p>Create a strided 32-bit floats identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_f32_parallel">function plp_mat_fill_I_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_f32_parallel(
    uint32_t N,
    uint32_t stride,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 32-bit floats identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_f32p_xpulpv2">function plp_mat_fill_I_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a strided 32-bit floats identity matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__f32/">plp_mat_fill_I_stride_instance_f32</a> struct initialized by plp_mat_fill_I_stride_f32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_I_stride_instance_f32 struct initialized by plp_mat_fill_I_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q32">function plp_mat_fill_I_stride_q32</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q32(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 32-bit fix-point identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q32s_rv32im">function plp_mat_fill_I_stride_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q32s_rv32im(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 32-bit fix-point identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<p>Create a strided 32-bit fix-point identity matrix on RV32IM.</p>
<h3 id="function-plp_mat_fill_i_stride_q32s_xpulpv2">function plp_mat_fill_I_stride_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q32s_xpulpv2(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 32-bit fix-point identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q32_parallel">function plp_mat_fill_I_stride_q32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q32_parallel(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 32-bit fix-point identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q32p_xpulpv2">function plp_mat_fill_I_stride_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q32p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a strided 32-bit fix-point identity matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__q32/">plp_mat_fill_I_stride_instance_q32</a> struct initialized by plp_mat_fill_I_stride_q32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_I_stride_instance_q32 struct initialized by plp_mat_fill_I_stride_q32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q16">function plp_mat_fill_I_stride_q16</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q16(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 16-bit fix-point identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q16s_rv32im">function plp_mat_fill_I_stride_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q16s_rv32im(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 16-bit fix-point identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<p>Create a strided 16-bit fix-point identity matrix on RV32IM.</p>
<h3 id="function-plp_mat_fill_i_stride_q16s_xpulpv2">function plp_mat_fill_I_stride_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q16s_xpulpv2(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 16-bit fix-point identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q16_parallel">function plp_mat_fill_I_stride_q16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q16_parallel(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 16-bit fix-point identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q16p_xpulpv2">function plp_mat_fill_I_stride_q16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q16p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a strided 16-bit fix-point identity matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__q16/">plp_mat_fill_I_stride_instance_q16</a> struct initialized by plp_mat_fill_I_stride_q16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_I_stride_instance_q16 struct initialized by plp_mat_fill_I_stride_q16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q8">function plp_mat_fill_I_stride_q8</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q8(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 8-bit fix-point identity matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q8s_rv32im">function plp_mat_fill_I_stride_q8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q8s_rv32im(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 8-bit fix-point identity matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<p>Create a strided 8-bit fix-point identity matrix on RV32IM.</p>
<h3 id="function-plp_mat_fill_i_stride_q8s_xpulpv2">function plp_mat_fill_I_stride_q8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q8s_xpulpv2(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Create a strided 8-bit fix-point identity matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q8_parallel">function plp_mat_fill_I_stride_q8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q8_parallel(
    uint32_t N,
    uint32_t stride,
    int32_t fracBits,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for creating a strided 8-bit fix-point identity matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
<li><strong>N</strong> Width and height of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>fracBits</strong> Decimal point for the appropriate scale </li>
<li><strong>nPE</strong> Number of cores to use for computation </li>
<li><strong>pDst</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>. </p>
<hr />
<h3 id="function-plp_mat_fill_i_stride_q8p_xpulpv2">function plp_mat_fill_I_stride_q8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_I_stride_q8p_xpulpv2(
    void * args
)
</code></pre>
<p>Create a strided 8-bit fix-point identity matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__I__stride__instance__q8/">plp_mat_fill_I_stride_instance_q8</a> struct initialized by plp_mat_fill_I_stride_q8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_I_stride_instance_q8 struct initialized by plp_mat_fill_I_stride_q8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Fix-Point</li>
</ul>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Fix-Point</p>
<p>The diagonal elements will be filled with the value: <code>1 &lt;&lt; fracBits</code>.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_fill_stride_i32">function plp_mat_fill_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i32(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int32_t value,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for filling an MxN strided 32-bit integers matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i32s_rv32im">function plp_mat_fill_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i32s_rv32im(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int32_t value,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Fill an MxN strided 32-bit integers matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i32s_xpulpv2">function plp_mat_fill_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i32s_xpulpv2(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int32_t value,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Fill an MxN strided 32-bit integers matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i32_parallel">function plp_mat_fill_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i32_parallel(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int32_t value,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for filling an MxN strided 32-bit integers matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i32p_xpulpv2">function plp_mat_fill_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Fill an MxN strided 32-bit integers matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__stride__instance__i32/">plp_mat_fill_stride_instance_i32</a> struct initialized by plp_mat_fill_stride_i32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_stride_instance_i32 struct initialized by plp_mat_fill_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i16">function plp_mat_fill_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i16(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int16_t value,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for filling an MxN strided 16-bit integers matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i16s_rv32im">function plp_mat_fill_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i16s_rv32im(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int16_t value,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Fill an MxN strided 16-bit integers matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i16s_xpulpv2">function plp_mat_fill_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i16s_xpulpv2(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int16_t value,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Fill an MxN strided 16-bit integers matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_fill_stride_i16_parallel">function plp_mat_fill_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i16_parallel(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int16_t value,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for filling an MxN strided 16-bit integers matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i16p_xpulpv2">function plp_mat_fill_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Fill an MxN strided 16-bit integers matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__stride__instance__i16/">plp_mat_fill_stride_instance_i16</a> struct initialized by plp_mat_fill_stride_i16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_stride_instance_i16 struct initialized by plp_mat_fill_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_fill_stride_i8">function plp_mat_fill_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i8(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int8_t value,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for filling an MxN strided 8-bit integers matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i8s_rv32im">function plp_mat_fill_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i8s_rv32im(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int8_t value,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Fill an MxN strided 8-bit integers matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i8s_xpulpv2">function plp_mat_fill_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i8s_xpulpv2(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int8_t value,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Fill an MxN strided 8-bit integers matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_fill_stride_i8_parallel">function plp_mat_fill_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i8_parallel(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    int8_t value,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code for filling an MxN strided 8-bit integers matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_i8p_xpulpv2">function plp_mat_fill_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Fill an MxN strided 8-bit integers matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__stride__instance__i8/">plp_mat_fill_stride_instance_i8</a> struct initialized by plp_mat_fill_stride_i8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_stride_instance_i8 struct initialized by plp_mat_fill_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_fill_stride_f32">function plp_mat_fill_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_f32(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    float value,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for filling an MxN strided 32-bit floats matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_f32s_xpulpv2">function plp_mat_fill_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_f32s_xpulpv2(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    float value,
    float *__restrict__ pDst
)
</code></pre>
<p>Fill an MxN strided 32-bit floats matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_f32_parallel">function plp_mat_fill_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_f32_parallel(
    uint32_t M,
    uint32_t N,
    uint32_t stride,
    float value,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code for filling an MxN strided 32-bit floats matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
<li><strong>M</strong> Height of the matrix </li>
<li><strong>N</strong> Width of the matrix </li>
<li><strong>stride</strong> Stride of the matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pSrc</strong> Points to the output matrix </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_fill_stride_f32p_xpulpv2">function plp_mat_fill_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_fill_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Fill an MxN strided 32-bit floats matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__fill__stride__instance__f32/">plp_mat_fill_stride_instance_f32</a> struct initialized by plp_mat_fill_stride_f32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_fill_stride_instance_f32 struct initialized by plp_mat_fill_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i32">function plp_mat_copy_stride_i32</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i32(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code to copy an MxN strided 32-bit integers matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i32s_rv32im">function plp_mat_copy_stride_i32s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i32s_rv32im(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Copy an MxN strided 32-bit integers matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i32s_xpulpv2">function plp_mat_copy_stride_i32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i32s_xpulpv2(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Copy an MxN strided 32-bit integers matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i32_parallel">function plp_mat_copy_stride_i32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i32_parallel(
    const int32_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    uint32_t nPE,
    int32_t *__restrict__ pDst
)
</code></pre>
<p>Glue code to copy an MxN strided 32-bit integers matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i32p_xpulpv2">function plp_mat_copy_stride_i32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i32p_xpulpv2(
    void * args
)
</code></pre>
<p>Copy an MxN strided 32-bit integers matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__copy__stride__instance__i32/">plp_mat_copy_stride_instance_i32</a> struct initialized by plp_mat_copy_stride_i32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_copy_stride_instance_i32 struct initialized by plp_mat_copy_stride_i32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i16">function plp_mat_copy_stride_i16</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i16(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code to copy an MxN strided 16-bit integers matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i16s_rv32im">function plp_mat_copy_stride_i16s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i16s_rv32im(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Copy an MxN strided 16-bit integers matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i16s_xpulpv2">function plp_mat_copy_stride_i16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i16s_xpulpv2(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Copy an MxN strided 16-bit integers matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_copy_stride_i16_parallel">function plp_mat_copy_stride_i16_parallel</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i16_parallel(
    const int16_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    uint32_t nPE,
    int16_t *__restrict__ pDst
)
</code></pre>
<p>Glue code to copy an MxN strided 16-bit integers matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i16p_xpulpv2">function plp_mat_copy_stride_i16p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i16p_xpulpv2(
    void * args
)
</code></pre>
<p>Copy an MxN strided 16-bit integers matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__copy__stride__instance__i16/">plp_mat_copy_stride_instance_i16</a> struct initialized by plp_mat_copy_stride_i16_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_copy_stride_instance_i16 struct initialized by plp_mat_copy_stride_i16_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two each into 32 bit vectors and then the two dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_copy_stride_i8">function plp_mat_copy_stride_i8</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i8(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code to copy an MxN strided 8-bit integers matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i8s_rv32im">function plp_mat_copy_stride_i8s_rv32im</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i8s_rv32im(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Copy an MxN strided 8-bit integers matrix on RV32IM. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i8s_xpulpv2">function plp_mat_copy_stride_i8s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i8s_xpulpv2(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Copy an MxN strided 8-bit integers matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.</p>
<hr />
<h3 id="function-plp_mat_copy_stride_i8_parallel">function plp_mat_copy_stride_i8_parallel</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i8_parallel(
    const int8_t *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    uint32_t nPE,
    int8_t *__restrict__ pDst
)
</code></pre>
<p>Glue code to copy an MxN strided 8-bit integers matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_i8p_xpulpv2">function plp_mat_copy_stride_i8p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_i8p_xpulpv2(
    void * args
)
</code></pre>
<p>Copy an MxN strided 8-bit integers matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__copy__stride__instance__i8/">plp_mat_copy_stride_instance_i8</a> struct initialized by plp_mat_copy_stride_i8_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_copy_stride_instance_i8 struct initialized by plp_mat_copy_stride_i8_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 8 bit values are packed four each into 32 bit vectors and then the four dot products are performed on 32 bit vectors, with 32 bit accumulator. </p>
<hr />
<h3 id="function-plp_mat_copy_stride_f32">function plp_mat_copy_stride_f32</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_f32(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code to copy an MxN strided 32-bit floats matrix. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_f32s_xpulpv2">function plp_mat_copy_stride_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_f32s_xpulpv2(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    float *__restrict__ pDst
)
</code></pre>
<p>Copy an MxN strided 32-bit floats matrix on XpulpV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_f32_parallel">function plp_mat_copy_stride_f32_parallel</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_f32_parallel(
    const float *__restrict__ pSrc,
    uint32_t M,
    uint32_t N,
    uint32_t strideSrc,
    uint32_t strideDst,
    uint32_t nPE,
    float *__restrict__ pDst
)
</code></pre>
<p>Glue code to copy an MxN strided 32-bit floats matrix in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
<li><strong>pSrc</strong> Points to the input matrix of shape MxN </li>
<li><strong>M</strong> Height of both matrices </li>
<li><strong>N</strong> Width of both matrices </li>
<li><strong>strideSrc</strong> Stride of the input matrix (elements between each row) </li>
<li><strong>strideDst</strong> Stride of the output matrix (elements between each row) </li>
<li><strong>nPE</strong> Number of cores to use for processing </li>
<li><strong>pDst</strong> Points to the output matrix of shape MxN </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_mat_copy_stride_f32p_xpulpv2">function plp_mat_copy_stride_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_mat_copy_stride_f32p_xpulpv2(
    void * args
)
</code></pre>
<p>Copy an MxN strided 32-bit floats matrix on XpulpV2 in parallel. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>args</strong> pointer to <a href="/pulp-dsp/refmanual/Classes/structplp__mat__copy__stride__instance__f32/">plp_mat_copy_stride_instance_f32</a> struct initialized by plp_mat_copy_stride_f32_parallel </li>
<li><strong>args</strong> pointer to plp_mat_mat_copy_stride_instance_f32 struct initialized by plp_mat_copy_stride_f32_parallel </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<hr />
<h3 id="function-plp_cmplx_conj_f32">function plp_cmplx_conj_f32</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_f32(
    const float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex conjugate of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_f32_xpulpv2">function plp_cmplx_conj_f32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_f32_xpulpv2(
    const float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Floating-point complex conjugate. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_i32">function plp_cmplx_conj_i32</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_i32(
    const int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex conjugate of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_i32_xpulpv2">function plp_cmplx_conj_i32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_i32_xpulpv2(
    const int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>32-bit integer complex conjugate. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_i32_rv32im">function plp_cmplx_conj_i32_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_i32_rv32im(
    const int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>32-bit integer complex conjugate. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_i16">function plp_cmplx_conj_i16</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_i16(
    const int16_t *__restrict__ pSrc,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex conjugate of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_i16_xpulpv2">function plp_cmplx_conj_i16_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_i16_xpulpv2(
    const int16_t *__restrict__ pSrc,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>16-bit integer complex conjugate. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_i16_rv32im">function plp_cmplx_conj_i16_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_i16_rv32im(
    const int16_t *__restrict__ pSrc,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>16-bit integer complex conjugate. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_i8">function plp_cmplx_conj_i8</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_i8(
    const int8_t *__restrict__ pSrc,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex conjugate of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_i8_xpulpv2">function plp_cmplx_conj_i8_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_i8_xpulpv2(
    const int8_t *__restrict__ pSrc,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>8-bit integer complex conjugate. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_conj_i8_rv32im">function plp_cmplx_conj_i8_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_conj_i8_rv32im(
    const int8_t *__restrict__ pSrc,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>8-bit integer complex conjugate. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_dot_prod_f32">function plp_cmplx_dot_prod_f32</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_f32(
    const float32_t * pSrcA,
    const float32_t * pSrcB,
    uint32_t numSamples,
    float32_t * realResult,
    float32_t * imagResult
)
</code></pre>
<p>Glue code for complex dot product of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_dot_prod_f32_xpulpv2">function plp_cmplx_dot_prod_f32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_f32_xpulpv2(
    const float32_t * pSrcA,
    const float32_t * pSrcB,
    uint32_t numSamples,
    float32_t * realResult,
    float32_t * imagResult
)
</code></pre>
<p>Floating-point complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_cmplx_dot_prod_i32">function plp_cmplx_dot_prod_i32</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_i32(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    uint32_t numSamples,
    int32_t * realResult,
    int32_t * imagResult
)
</code></pre>
<p>Glue code for complex dot product of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_dot_prod_i32_xpulpv2">function plp_cmplx_dot_prod_i32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_i32_xpulpv2(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    uint32_t numSamples,
    int32_t * realResult,
    int32_t * imagResult
)
</code></pre>
<p>32-bit integer complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_cmplx_dot_prod_i32_rv32im">function plp_cmplx_dot_prod_i32_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_i32_rv32im(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    uint32_t numSamples,
    int32_t * realResult,
    int32_t * imagResult
)
</code></pre>
<p>32-bit integer complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_cmplx_dot_prod_i16">function plp_cmplx_dot_prod_i16</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_i16(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    uint32_t numSamples,
    int16_t * realResult,
    int16_t * imagResult
)
</code></pre>
<p>Glue code for complex dot product of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_dot_prod_i16_xpulpv2">function plp_cmplx_dot_prod_i16_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_i16_xpulpv2(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    uint32_t numSamples,
    int16_t * realResult,
    int16_t * imagResult
)
</code></pre>
<p>16-bit integer complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_cmplx_dot_prod_i16_rv32im">function plp_cmplx_dot_prod_i16_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_i16_rv32im(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    uint32_t numSamples,
    int16_t * realResult,
    int16_t * imagResult
)
</code></pre>
<p>16-bit integer complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_cmplx_dot_prod_i8">function plp_cmplx_dot_prod_i8</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_i8(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    uint32_t numSamples,
    int8_t * realResult,
    int8_t * imagResult
)
</code></pre>
<p>Glue code for complex dot product of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_dot_prod_i8_xpulpv2">function plp_cmplx_dot_prod_i8_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_i8_xpulpv2(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    uint32_t numSamples,
    int8_t * realResult,
    int8_t * imagResult
)
</code></pre>
<p>8-bit integer complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_cmplx_dot_prod_i8_rv32im">function plp_cmplx_dot_prod_i8_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_i8_rv32im(
    const int8_t * pSrcA,
    const int8_t * pSrcB,
    uint32_t numSamples,
    int8_t * realResult,
    int8_t * imagResult
)
</code></pre>
<p>8-bit integer complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_cmplx_dot_prod_q32">function plp_cmplx_dot_prod_q32</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_q32(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    uint32_t numSamples,
    uint32_t deciPoint,
    int32_t * realResult,
    int32_t * imagResult
)
</code></pre>
<p>Glue code for complex dot product of 32-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_dot_prod_q32_xpulpv2">function plp_cmplx_dot_prod_q32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_q32_xpulpv2(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    uint32_t numSamples,
    uint32_t deciPoint,
    int32_t * realResult,
    int32_t * imagResult
)
</code></pre>
<p>32-bit fixed-point complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit fixed-point complex dot product.</p>
<h3 id="function-plp_cmplx_dot_prod_q32_rv32im">function plp_cmplx_dot_prod_q32_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_q32_rv32im(
    const int32_t * pSrcA,
    const int32_t * pSrcB,
    uint32_t numSamples,
    uint32_t deciPoint,
    int32_t * realResult,
    int32_t * imagResult
)
</code></pre>
<p>32-bit integer complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_cmplx_dot_prod_q16">function plp_cmplx_dot_prod_q16</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_q16(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    uint32_t numSamples,
    uint32_t deciPoint,
    int16_t * realResult,
    int16_t * imagResult
)
</code></pre>
<p>Glue code for complex dot product of 16-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cmplx_dot_prod_q16_xpulpv2">function plp_cmplx_dot_prod_q16_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_q16_xpulpv2(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    uint32_t numSamples,
    uint32_t deciPoint,
    int16_t * realResult,
    int16_t * imagResult
)
</code></pre>
<p>16-bit fixed-point complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit fixed-point complex dot product.</p>
<h3 id="function-plp_cmplx_dot_prod_q16_rv32im">function plp_cmplx_dot_prod_q16_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_dot_prod_q16_rv32im(
    const int16_t * pSrcA,
    const int16_t * pSrcB,
    uint32_t numSamples,
    uint32_t deciPoint,
    int16_t * realResult,
    int16_t * imagResult
)
</code></pre>
<p>16-bit fixed-point complex dot product. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>realResult</strong> real part of the result returned here </li>
<li><strong>imagResult</strong> imaginary part of the result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit fixed-point complex dot product.</p>
<h3 id="function-plp_cmplx_mult_real_f32">function plp_cmplx_mult_real_f32</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_f32(
    const float32_t *__restrict__ pSrcCmplx,
    const float32_t *__restrict__ pSrcReal,
    float32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied with real of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied with real of 32-bit float vectors.</p>
<h3 id="function-plp_cmplx_mult_real_f32_xpulpv2">function plp_cmplx_mult_real_f32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_f32_xpulpv2(
    const float32_t *__restrict__ pSrcCmplx,
    const float32_t *__restrict__ pSrcReal,
    float32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Floating-point complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Floating-point complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_i32">function plp_cmplx_mult_real_i32</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_i32(
    const int32_t *__restrict__ pSrcCmplx,
    const int32_t *__restrict__ pSrcReal,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied with real of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied with real of 32-bit integer vectors.</p>
<h3 id="function-plp_cmplx_mult_real_i32_xpulpv2">function plp_cmplx_mult_real_i32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_i32_xpulpv2(
    const int32_t *__restrict__ pSrcCmplx,
    const int32_t *__restrict__ pSrcReal,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>32-bit integer complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit integer complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_i32_rv32im">function plp_cmplx_mult_real_i32_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_i32_rv32im(
    const int32_t *__restrict__ pSrcCmplx,
    const int32_t *__restrict__ pSrcReal,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>32-bit integer complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit integer complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_i16">function plp_cmplx_mult_real_i16</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_i16(
    const int16_t *__restrict__ pSrcCmplx,
    const int16_t *__restrict__ pSrcReal,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied with real of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied with real of 16-bit integer vectors.</p>
<h3 id="function-plp_cmplx_mult_real_i16_xpulpv2">function plp_cmplx_mult_real_i16_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_i16_xpulpv2(
    const int16_t *__restrict__ pSrcCmplx,
    const int16_t *__restrict__ pSrcReal,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>16-bit integer complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit integer complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_i16_rv32im">function plp_cmplx_mult_real_i16_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_i16_rv32im(
    const int16_t *__restrict__ pSrcCmplx,
    const int16_t *__restrict__ pSrcReal,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>16-bit integer complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit integer complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_i8">function plp_cmplx_mult_real_i8</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_i8(
    const int8_t *__restrict__ pSrcCmplx,
    const int8_t *__restrict__ pSrcReal,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied with real of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied with real of 8-bit integer vectors.</p>
<h3 id="function-plp_cmplx_mult_real_i8_xpulpv2">function plp_cmplx_mult_real_i8_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_i8_xpulpv2(
    const int8_t *__restrict__ pSrcCmplx,
    const int8_t *__restrict__ pSrcReal,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>8-bit integer complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit integer complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_i8_rv32im">function plp_cmplx_mult_real_i8_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_i8_rv32im(
    const int8_t *__restrict__ pSrcCmplx,
    const int8_t *__restrict__ pSrcReal,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>8-bit integer complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit integer complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_q32">function plp_cmplx_mult_real_q32</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_q32(
    const int32_t *__restrict__ pSrcCmplx,
    const int32_t *__restrict__ pSrcReal,
    int32_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied with real of 32-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied with real of 32-bit fixed-point vectors.</p>
<h3 id="function-plp_cmplx_mult_real_q32_xpulpv2">function plp_cmplx_mult_real_q32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_q32_xpulpv2(
    const int32_t *__restrict__ pSrcCmplx,
    const int32_t *__restrict__ pSrcReal,
    int32_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>32-bit fixed-point complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit fixed-point complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_q32_rv32im">function plp_cmplx_mult_real_q32_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_q32_rv32im(
    const int32_t *__restrict__ pSrcCmplx,
    const int32_t *__restrict__ pSrcReal,
    int32_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>32-bit fixed-point complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit fixed-point complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_q16">function plp_cmplx_mult_real_q16</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_q16(
    const int16_t *__restrict__ pSrcCmplx,
    const int16_t *__restrict__ pSrcReal,
    int16_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied with real of 16-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied with real of 16-bit fixed-point vectors.</p>
<h3 id="function-plp_cmplx_mult_real_q16_xpulpv2">function plp_cmplx_mult_real_q16_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_q16_xpulpv2(
    const int16_t *__restrict__ pSrcCmplx,
    const int16_t *__restrict__ pSrcReal,
    int16_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>16-bit fixed-point complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit fixed-point complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_q16_rv32im">function plp_cmplx_mult_real_q16_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_q16_rv32im(
    const int16_t *__restrict__ pSrcCmplx,
    const int16_t *__restrict__ pSrcReal,
    int16_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>16-bit fixed-point complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit fixed-point complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_q8">function plp_cmplx_mult_real_q8</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_q8(
    const int8_t *__restrict__ pSrcCmplx,
    const int8_t *__restrict__ pSrcReal,
    int8_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied with real of 8-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied with real of 8-bit fixed-point vectors.</p>
<h3 id="function-plp_cmplx_mult_real_q8_xpulpv2">function plp_cmplx_mult_real_q8_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_q8_xpulpv2(
    const int8_t *__restrict__ pSrcCmplx,
    const int8_t *__restrict__ pSrcReal,
    int8_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>8-bit fixed-point complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit fixed-point complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mult_real_q8_rv32im">function plp_cmplx_mult_real_q8_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_real_q8_rv32im(
    const int8_t *__restrict__ pSrcCmplx,
    const int8_t *__restrict__ pSrcReal,
    int8_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>8-bit fixed-point complex multiplied with real. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit fixed-point complex multiplied with real.</p>
<h3 id="function-plp_cmplx_mag_squared_f32">function plp_cmplx_mag_squared_f32</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_f32(
    const float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex squared magnitude of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex squared magnitude of 32-bit float vectors.</p>
<h3 id="function-plp_cmplx_mag_squared_f32_xpulpv2">function plp_cmplx_mag_squared_f32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_f32_xpulpv2(
    const float32_t *__restrict__ pSrc,
    float32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Floating-point complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Floating-point complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_i16">function plp_cmplx_mag_squared_i16</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_i16(
    const int16_t *__restrict__ pSrc,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex squared magnitude of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex squared magnitude of 16-bit integer vectors.</p>
<h3 id="function-plp_cmplx_mag_squared_i16_rv32im">function plp_cmplx_mag_squared_i16_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_i16_rv32im(
    const int16_t *__restrict__ pSrc,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>16-bit integer complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit integer complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_i16_xpulpv2">function plp_cmplx_mag_squared_i16_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_i16_xpulpv2(
    const int16_t *__restrict__ pSrc,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>16 bit Integer complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16 bit Integer complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_i32">function plp_cmplx_mag_squared_i32</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_i32(
    const int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex squared magnitude of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex squared magnitude of 32-bit integer vectors.</p>
<h3 id="function-plp_cmplx_mag_squared_i32_rv32im">function plp_cmplx_mag_squared_i32_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_i32_rv32im(
    const int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>32-bit integer complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit integer complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_i32_xpulpv2">function plp_cmplx_mag_squared_i32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_i32_xpulpv2(
    const int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>32-bit integer complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit integer complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_i8_xpulpv2">function plp_cmplx_mag_squared_i8_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_i8_xpulpv2(
    const int8_t *__restrict__ pSrc,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>8 bit Integer complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8 bit Integer complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_i8">function plp_cmplx_mag_squared_i8</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_i8(
    const int8_t *__restrict__ pSrc,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex squared magnitude of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex squared magnitude of 32-bit integer vectors.</p>
<h3 id="function-plp_cmplx_mag_squared_i8_rv32im">function plp_cmplx_mag_squared_i8_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_i8_rv32im(
    const int8_t *__restrict__ pSrc,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>8-bit integer complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit integer complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_q32">function plp_cmplx_mag_squared_q32</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_q32(
    const int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex squared magnitude of 32-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex squared magnitude of 32-bit fixed-point vectors.</p>
<h3 id="function-plp_cmplx_mag_squared_q32_rv32im">function plp_cmplx_mag_squared_q32_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_q32_rv32im(
    const int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>32-bit fixed-point complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit fixed-point complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_q32_xpulpv2">function plp_cmplx_mag_squared_q32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_q32_xpulpv2(
    const int32_t *__restrict__ pSrc,
    int32_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>32 bit fixed-point complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32 bit fixed-point complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_q16">function plp_cmplx_mag_squared_q16</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_q16(
    const int16_t *__restrict__ pSrc,
    int16_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex squared magnitude of 16-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex squared magnitude of 16-bit fixed-point vectors.</p>
<h3 id="function-plp_cmplx_mag_squared_q16_rv32im">function plp_cmplx_mag_squared_q16_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_q16_rv32im(
    const int16_t *__restrict__ pSrc,
    int16_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>16-bit fixed-point complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit fixed-point complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_q16_xpulpv2">function plp_cmplx_mag_squared_q16_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_q16_xpulpv2(
    const int16_t *__restrict__ pSrc,
    int16_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>16 bit fixed-point complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16 bit fixed-point complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_q8">function plp_cmplx_mag_squared_q8</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_q8(
    const int8_t *__restrict__ pSrc,
    int8_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex squared magnitude of 8-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex squared magnitude of 8-bit fixed-point vectors.</p>
<h3 id="function-plp_cmplx_mag_squared_q8_rv32im">function plp_cmplx_mag_squared_q8_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_q8_rv32im(
    const int8_t *__restrict__ pSrc,
    int8_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>8-bit fixed-point complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit fixed-point complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mag_squared_q8_xpulpv2">function plp_cmplx_mag_squared_q8_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mag_squared_q8_xpulpv2(
    const int8_t *__restrict__ pSrc,
    int8_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>8 bit fixed-point complex squared magnitude. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrc</strong> points to input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8 bit fixed-point complex squared magnitude.</p>
<h3 id="function-plp_cmplx_mult_cmplx_f32">function plp_cmplx_mult_cmplx_f32</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_f32(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    float32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied by complex of 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied by complex of 32-bit float vectors.</p>
<h3 id="function-plp_cmplx_mult_cmplx_f32_xpulpv2">function plp_cmplx_mult_cmplx_f32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_f32_xpulpv2(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    float32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Floating-point complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to complex input vector </li>
<li><strong>pSrcB</strong> points to real input vector </li>
<li><strong>pDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Floating-point complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_i32">function plp_cmplx_mult_cmplx_i32</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_i32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied by complex of 32-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcCmplx</strong> points to complex input vector </li>
<li><strong>pSrcReal</strong> points to real input vector </li>
<li><strong>pCmplxDst</strong> points to complex output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied by complex of 32-bit integer vectors.</p>
<h3 id="function-plp_cmplx_mult_cmplx_i32_xpulpv2">function plp_cmplx_mult_cmplx_i32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_i32_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>32-bit integer complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit integer complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_i32_rv32im">function plp_cmplx_mult_cmplx_i32_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_i32_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    int32_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>32-bit integer complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit integer complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_i16">function plp_cmplx_mult_cmplx_i16</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_i16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied by complex of 16-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied by complex of 16-bit integer vectors.</p>
<h3 id="function-plp_cmplx_mult_cmplx_i16_xpulpv2">function plp_cmplx_mult_cmplx_i16_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_i16_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>16-bit integer complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit integer complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_i16_rv32im">function plp_cmplx_mult_cmplx_i16_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_i16_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    int16_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>16-bit integer complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit integer complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_i8">function plp_cmplx_mult_cmplx_i8</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_i8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied by complex of 8-bit integer vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied by complex of 8-bit integer vectors.</p>
<h3 id="function-plp_cmplx_mult_cmplx_i8_xpulpv2">function plp_cmplx_mult_cmplx_i8_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_i8_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>8-bit integer complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit integer complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_i8_rv32im">function plp_cmplx_mult_cmplx_i8_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_i8_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    int8_t *__restrict__ pDst,
    uint32_t numSamples
)
</code></pre>
<p>8-bit integer complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit integer complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_q32">function plp_cmplx_mult_cmplx_q32</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    int32_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied by complex of 32-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied by complex of 32-bit fixed-point vectors.</p>
<h3 id="function-plp_cmplx_mult_cmplx_q32_xpulpv2">function plp_cmplx_mult_cmplx_q32_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_q32_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    int32_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>32-bit fixed-point complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit fixed-point complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_q32_rv32im">function plp_cmplx_mult_cmplx_q32_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_q32_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    int32_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>32-bit fixed-point complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>32-bit fixed-point complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_q16">function plp_cmplx_mult_cmplx_q16</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    int16_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied by complex of 16-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied by complex of 16-bit fixed-point vectors.</p>
<h3 id="function-plp_cmplx_mult_cmplx_q16_xpulpv2">function plp_cmplx_mult_cmplx_q16_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_q16_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    int16_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>16-bit fixed-point complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit fixed-point complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_q16_rv32im">function plp_cmplx_mult_cmplx_q16_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_q16_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    int16_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>16-bit fixed-point complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>16-bit fixed-point complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_q8">function plp_cmplx_mult_cmplx_q8</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_q8(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    int8_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>Glue code for complex multiplied by complex of 8-bit fixed-point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for complex multiplied by complex of 8-bit fixed-point vectors.</p>
<h3 id="function-plp_cmplx_mult_cmplx_q8_xpulpv2">function plp_cmplx_mult_cmplx_q8_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_q8_xpulpv2(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    int8_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>8-bit fixed-point complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit fixed-point complex multiplied by complex.</p>
<h3 id="function-plp_cmplx_mult_cmplx_q8_rv32im">function plp_cmplx_mult_cmplx_q8_rv32im</h3>
<pre><code class="language-cpp">void plp_cmplx_mult_cmplx_q8_rv32im(
    const int8_t *__restrict__ pSrcA,
    const int8_t *__restrict__ pSrcB,
    int8_t *__restrict__ pDst,
    uint32_t deciPoint,
    uint32_t numSamples
)
</code></pre>
<p>8-bit fixed-point complex multiplied by complex. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second vector </li>
<li><strong>pDst</strong> points to the output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
<li><strong>pSrcA</strong> points to first input vector </li>
<li><strong>pSrcB</strong> points to second input vector </li>
<li><strong>pDst</strong> points to output vector </li>
<li><strong>deciPoint</strong> decimal point for right shift </li>
<li><strong>numSamples</strong> number of samples in each vector </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>8-bit fixed-point complex multiplied by complex.</p>
<h3 id="function-plp_euclidean_distance_q32_parallel">function plp_euclidean_distance_q32_parallel</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    uint32_t nPE,
    uint32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for parallel Euclidean distance of 32-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_euclidean_distance_f32_parallel">function plp_euclidean_distance_f32_parallel</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_f32_parallel(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t nPE,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for parallel Euclidean distance between 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_euclidean_distance_q32p_xpulpv2">function plp_euclidean_distance_q32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_q32p_xpulpv2(
    void * S
)
</code></pre>
<p>Parallel euclidean distance with interleaved access 32-bit fixed point vectors. vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for integer parallel dot product </li>
<li><strong>S</strong> points to the instance structure for integer parallel Euclidean distance </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_euclidean_distance_f32p_xpulpv2">function plp_euclidean_distance_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_f32p_xpulpv2(
    void * S
)
</code></pre>
<p>32-bit floating-point parallel Euclidean distance between two vectors </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for float euclidean distance </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_euclidean_distance_q32">function plp_euclidean_distance_q32</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for euclidean distance of 32-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_euclidean_distance_q32s_xpulpv2">function plp_euclidean_distance_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Euclidean distance of 32-bit fixed point vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_euclidean_distance_q32s_rv32im">function plp_euclidean_distance_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Euclidean distance of 32-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_euclidean_distance_q16">function plp_euclidean_distance_q16</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint16_t blockSize,
    uint16_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for euclidean distance of 16-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_euclidean_distance_q16s_xpulpv2">function plp_euclidean_distance_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t deciPoint,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Euclidean distance of 16-bit fixed point vectors kernel for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: none</p>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two by two into 32 bit vectors and then the sums and prducts are performed simultaneously on 32 bit vectors, with 32 bit accumulator. </p>
<h3 id="function-plp_euclidean_distance_q16s_rv32im">function plp_euclidean_distance_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Euclidean distance of 16-bit fixed point vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: none</p>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>When the ISA supports, the 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2). </p>
<h3 id="function-plp_euclidean_distance_f32">function plp_euclidean_distance_f32</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_f32(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for Euclidean distance between 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> First vector </li>
<li><strong>pSrcB</strong> Second vector </li>
<li><strong>blockSize</strong> vector length </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_euclidean_distance_f32s_xpulpv2">function plp_euclidean_distance_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_f32s_xpulpv2(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>32-bit floating point Euclidean distance between two vectors </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pA</strong> First vector </li>
<li><strong>pB</strong> Second vector </li>
<li><strong>blockSize</strong> vector length </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_euclidean_distance_f32s_rv32im">function plp_euclidean_distance_f32s_rv32im</h3>
<pre><code class="language-cpp">void plp_euclidean_distance_f32s_rv32im(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>32-bit floating point Euclidean distance between two vectors </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pA</strong> First vector </li>
<li><strong>pB</strong> Second vector </li>
<li><strong>blockSize</strong> vector length </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cosine_distance_q32_parallel">function plp_cosine_distance_q32_parallel</h3>
<pre><code class="language-cpp">void plp_cosine_distance_q32_parallel(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    uint32_t nPE,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for parallel cosine distance between 32-bit fixed-precision vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for parallel cosine distance between 32-bit fixed-precision vectors.</p>
<h3 id="function-plp_cosine_distance_f32_parallel">function plp_cosine_distance_f32_parallel</h3>
<pre><code class="language-cpp">void plp_cosine_distance_f32_parallel(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t nPE,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for parallel cosine distance between 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>nPE</strong> number of parallel processing units </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cosine_distance_f32p_xpulpv2">function plp_cosine_distance_f32p_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cosine_distance_f32p_xpulpv2(
    void * S
)
</code></pre>
<p>32-bit floating-point parallel cosine distance between two vectors (computes power in parallel) </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>S</strong> points to the instance structure for float cosine distance </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cosine_distance_f32">function plp_cosine_distance_f32</h3>
<pre><code class="language-cpp">void plp_cosine_distance_f32(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for cosine distance between 32-bit float vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> First vector </li>
<li><strong>pSrcB</strong> Second vector </li>
<li><strong>blockSize</strong> vector length </li>
<li><strong>pSrcA</strong> First vector </li>
<li><strong>pSrcB</strong> Second vector </li>
<li><strong>blockSize</strong> vector length </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>Glue code for cosine distance between 32-bit float vectors.</p>
<h3 id="function-plp_cosine_distance_f32s_rv32im">function plp_cosine_distance_f32s_rv32im</h3>
<pre><code class="language-cpp">void plp_cosine_distance_f32s_rv32im(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>32-bit floating point cosine distance between two vectors </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pA</strong> First vector </li>
<li><strong>pB</strong> Second vector </li>
<li><strong>blockSize</strong> vector length </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cosine_distance_f32s_xpulpv2">function plp_cosine_distance_f32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cosine_distance_f32s_xpulpv2(
    const float32_t *__restrict__ pSrcA,
    const float32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    float32_t *__restrict__ pRes
)
</code></pre>
<p>32-bit floating point cosine distance between two vectors </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pA</strong> First vector </li>
<li><strong>pB</strong> Second vector </li>
<li><strong>blockSize</strong> vector length </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cosine_distance_q32">function plp_cosine_distance_q32</h3>
<pre><code class="language-cpp">void plp_cosine_distance_q32(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for cosine distance of 32-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cosine_distance_q32s_rv32im">function plp_cosine_distance_q32s_rv32im</h3>
<pre><code class="language-cpp">void plp_cosine_distance_q32s_rv32im(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>cosine distance of 32-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed-point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<h3 id="function-plp_cosine_distance_q32s_xpulpv2">function plp_cosine_distance_q32s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cosine_distance_q32s_xpulpv2(
    const int32_t *__restrict__ pSrcA,
    const int32_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>cosine distance of 32-bit fixed point vectors kernel for XPULPV2 extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none </li>
</ul>
<p>cosine distance of 32-bit fixed point vectors kernel for XPULPV2 extension.</p>
<h3 id="function-plp_cosine_distance_q16">function plp_cosine_distance_q16</h3>
<pre><code class="language-cpp">void plp_cosine_distance_q16(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint16_t blockSize,
    uint16_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>Glue code for cosine distance of 16-bit fixed point vectors. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector </li>
<li><strong>pSrcB</strong> points to the second input vector </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> number of fixed point fractional bits </li>
<li><strong>pRes</strong> output result returned here </li>
</ul>
<p><strong>Return</strong>: none </p>
<h3 id="function-plp_cosine_distance_q16s_rv32im">function plp_cosine_distance_q16s_rv32im</h3>
<pre><code class="language-cpp">void plp_cosine_distance_q16s_rv32im(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>cosine distance of 16-bit fixed point vectors kernel for RV32IM extension. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: none</p>
<p><strong>Par</strong>: Exploiting SIMD instructions</p>
<p>When the ISA supports, the 16 bit values are packed two by two into 32 bit vectors and then the two dot products are performed simultaneously on 32 bit vectors, with 32 bit accumulator. RV32IM doesn't support SIMD. For SIMD, check out other ISA extensions (e.g. XPULPV2). </p>
<h3 id="function-plp_cosine_distance_q16s_xpulpv2">function plp_cosine_distance_q16s_xpulpv2</h3>
<pre><code class="language-cpp">void plp_cosine_distance_q16s_xpulpv2(
    const int16_t *__restrict__ pSrcA,
    const int16_t *__restrict__ pSrcB,
    uint32_t blockSize,
    uint32_t fracBits,
    int32_t *__restrict__ pRes
)
</code></pre>
<p>cosine distance of 16-bit fixed point vectors kernel for XPULPV2. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
<li><strong>pSrcA</strong> points to the first input vector [16 bit] </li>
<li><strong>pSrcB</strong> points to the second input vector [16 bit] </li>
<li><strong>blockSize</strong> number of samples in each vector </li>
<li><strong>fracBits</strong> decimal point for right shift </li>
<li><strong>pRes</strong> output result returned here [32 bit] </li>
</ul>
<p><strong>Return</strong>: </p>
<ul>
<li>none</li>
<li>none</li>
</ul>
<p><strong>Par</strong>: </p>
<ul>
<li>Exploiting SIMD instructions</li>
</ul>
<p>The 16 bit values are packed two by two into 32 bit vectors and then the sums and prducts are performed simultaneously on 32 bit vectors, with 32 bit accumulator.
  * Exploiting SIMD instructions</p>
<p>The 16 bit values are packed two by two into 32 bit vectors and then the sums and prducts are performed simultaneously on 32 bit vectors, with 32 bit accumulator. </p>
<p>cosine distance of 16-bit fixed point vectors kernel for XPULPV2.</p>
<h2 id="macros-documentation">Macros Documentation</h2>
<h3 id="define-plp_math_ibex">define PLP_MATH_IBEX</h3>
<pre><code class="language-cpp">#define PLP_MATH_IBEX 
</code></pre>
<h3 id="define-plp_math_loopunroll">define PLP_MATH_LOOPUNROLL</h3>
<pre><code class="language-cpp">#define PLP_MATH_LOOPUNROLL 
</code></pre>
<h3 id="define-plp_dwt_dec_len">define PLP_DWT_DEC_LEN</h3>
<pre><code class="language-cpp">#define PLP_DWT_DEC_LEN(
    SIG_LEN,
    WAVELET,
    LEVEL
)
plp_dwt_dec_len(SIG_LEN, WAVELET.length, LEVEL)
</code></pre>
<h3 id="define-plp_dwt_dec_temp_len">define PLP_DWT_DEC_TEMP_LEN</h3>
<pre><code class="language-cpp">#define PLP_DWT_DEC_TEMP_LEN(
    SRC_LEN,
    WAVELET_LEN
)
(((SRC_LEN+WAVELET_LEN-1)/2 + ((SRC_LEN+WAVELET_LEN-1)/2 + WAVELET_LEN-1))/2)
</code></pre>
<h3 id="define-plp_dwt_output_length">define PLP_DWT_OUTPUT_LENGTH</h3>
<pre><code class="language-cpp">#define PLP_DWT_OUTPUT_LENGTH(
    SIG_LEN,
    WAVELET_LEN
)
((SIG_LEN + WAVELET_LEN - 1) &gt;&gt; 1)
</code></pre>
<h3 id="define-fast_math_table_size">define FAST_MATH_TABLE_SIZE</h3>
<pre><code class="language-cpp">#define FAST_MATH_TABLE_SIZE 512
</code></pre>
<p>Glue code for square root of a 32-bit floating point number. </p>
<p><strong>Parameters</strong>: </p>
<ul>
<li><strong>pSrc</strong> points to the input vectoro </li>
<li><strong>pRes</strong> Square root returned here </li>
</ul>
<p><strong>Return</strong>: none</p>
<p>Macros required for SINE and COSINE Fast math approximations </p>
<h3 id="define-fast_math_q32_shift">define FAST_MATH_Q32_SHIFT</h3>
<pre><code class="language-cpp">#define FAST_MATH_Q32_SHIFT (32 - 10)
</code></pre>
<h3 id="define-fast_math_q16_shift">define FAST_MATH_Q16_SHIFT</h3>
<pre><code class="language-cpp">#define FAST_MATH_Q16_SHIFT (16 - 10)
</code></pre>
<h3 id="define-controller_q32_shift">define CONTROLLER_Q32_SHIFT</h3>
<pre><code class="language-cpp">#define CONTROLLER_Q32_SHIFT (32 - 9)
</code></pre>
<h3 id="define-table_spacing_q32">define TABLE_SPACING_Q32</h3>
<pre><code class="language-cpp">#define TABLE_SPACING_Q32 0x400000
</code></pre>
<h3 id="define-table_spacing_q16">define TABLE_SPACING_Q16</h3>
<pre><code class="language-cpp">#define TABLE_SPACING_Q16 0x80
</code></pre>
<h2 id="source-code">Source code</h2>
<pre><code class="language-cpp">
/*
 * Copyright (C) 2019 ETH Zurich and University of Bologna. All rights reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __PLP_MATH_H__
#define __PLP_MATH_H__

#include &quot;math.h&quot;
#include &quot;rtos_hal.h&quot;

typedef float float32_t;

#define PLP_MATH_IBEX // previously called zero-riscy
//#define PLP_MATH_RISCY
#define PLP_MATH_LOOPUNROLL

typedef struct {
    int32_t *pSrcA;     // pointer to the first vector
    int32_t *pSrcB;     // pointer to the second vector
    uint32_t blkSizePE; // number of samples in each vector
    uint32_t nPE;       // number of processing units
    int32_t *resBuffer; // pointer to result vector
} plp_dot_prod_instance_i32;

typedef struct {
    int32_t *pSrcA;     // pointer to the first vector
    int32_t *pSrcB;     // pointer to the second vector
    uint32_t blkSizePE; // number of samples in each vector
    uint32_t deciPoint; // decimal point for right shift
    uint32_t nPE;       // number of processing units
    int32_t *resBuffer; // pointer to result vector
} plp_dot_prod_instance_q32;

typedef struct {
    const float32_t *pSrcA; // pointer to the first vector
    const float32_t *pSrcB; // pointer to the second vector
    uint32_t blkSizePE;     // number of samples in each vector
    uint32_t nPE;           // number of processing units
    float32_t *resBuffer;   // pointer to result vector
} plp_dot_prod_instance_f32;

typedef struct {
    const float32_t *pSrcA; // pointer to the first vector
    const float32_t *pSrcB; // pointer to the second vector
    uint32_t blkSizePE;     // number of samples in each vector
    uint32_t nPE;           // number of processing units
    float32_t *pDst;        // pointer to result vector
} plp_mult_instance_f32;

typedef struct {
    const float32_t *pSrc; // pointer to the vector
    uint32_t blkSizePE;     // number of samples in each vector
    uint32_t nPE;           // number of processing units
    float32_t *pDst;        // pointer to result vector
} plp_log_instance_f32;

typedef struct {
    const int32_t *pSrcA; // pointer to the first vector
    uint32_t srcALen;
    const int32_t *pSrcB; // pointer to the second vector
    uint32_t srcBLen;     // number of samples in each vector
    uint8_t nPE;          // number of processing units
    int32_t *pRes;        // pointer to result vector
} plp_conv_instance_i32;

typedef struct {
    const int16_t *pSrcA; // pointer to the first vector
    uint32_t srcALen;
    const int16_t *pSrcB; // pointer to the second vector
    uint32_t srcBLen;     // number of samples in each vector
    uint8_t nPE;          // number of processing units
    int32_t *pRes;        // pointer to result vector
} plp_conv_instance_i16;

typedef struct {
    const int8_t *pSrcA; // pointer to the first vector
    uint32_t srcALen;
    const int8_t *pSrcB; // pointer to the second vector
    uint32_t srcBLen;    // number of samples in each vector
    uint8_t nPE;         // number of processing units
    int32_t *pRes;       // pointer to result vector
} plp_conv_instance_i8;

typedef struct {
    uint32_t addOffset;
    uint32_t addLengthfirst;
    uint32_t addLengthsecond;
    uint32_t numVectors;
    uint32_t blockOffset;
    int32_t *pRes;
    uint8_t coresPerVector;
} plp_conv_tree_add_instance;

typedef struct {
    uint16_t fftLen;             /*&lt; length of the FFT. */
    const int16_t *pTwiddle;     /*&lt; points to the Twiddle factor table. */
    const int16_t *pBitRevTable; /*&lt; points to the bit reversal table. */
    uint16_t bitRevLength;       /*&lt; bit reversal table length. */
} plp_cfft_instance_q16;

typedef struct {
    plp_cfft_instance_q16 *S;
    int16_t *p1;
    uint8_t ifftFlag;
    uint8_t bitReverseFlag;
    uint32_t deciPoint;
    uint32_t nPE;
} plp_cfft_instance_q16_parallel;

typedef struct {
    uint16_t fftLen;             /*&lt; length of the FFT. */
    const int32_t *pTwiddle;     /*&lt; points to the Twiddle factor table. */
    const int16_t *pBitRevTable; /*&lt; points to the bit reversal table. */
    uint16_t bitRevLength;       /*&lt; bit reversal table length. */
} plp_cfft_instance_q32;

typedef struct {
    plp_cfft_instance_q32 *S;
    int32_t *p1;
    uint8_t ifftFlag;
    uint8_t bitReverseFlag;
    uint32_t fracBits;
    uint32_t nPE;
} plp_cfft_instance_q32_parallel;


typedef struct {
    uint32_t fftLen;
    const float32_t *pTwiddle;
    const uint16_t *pBitRevTable;
    uint16_t bitRevLength;
} plp_cfft_instance_f32;

typedef struct {
    plp_cfft_instance_f32 *S;
    const float32_t *pSrc;
    uint8_t ifftFlag;
    uint8_t bitReverseFlag;
    const uint32_t nPE;
} plp_cfft_instance_f32_parallel;

typedef struct {
    uint32_t FFTLength;
    uint8_t bitReverseFlag;
    const float32_t *pTwiddleFactors;
    const uint16_t *pBitReverseLUT;
} plp_fft_instance_f32;

typedef struct {
    plp_cfft_instance_f32 *Sint;
    uint32_t FFTLengthRFFT;
    const float32_t *pTwiddleFactorsRFFT;
} plp_fft_fast_instance_f32;

typedef struct {
    plp_fft_fast_instance_f32* S;
    float32_t *__restrict__ pSrc;
    float32_t *__restrict__ pDst;
    const uint32_t nPE;
} plp_fft_fast_instance_f32_parallel;


typedef struct {
    plp_fft_instance_f32 *S;
    const float32_t *pSrc;
    const uint32_t nPE;
    float32_t *pDst;
} plp_fft_instance_f32_parallel;

typedef struct {
    const float32_t *V;
    const uint16_t *firstValue;
    const uint16_t *filterLength;
    const uint8_t nFilters;
} plp_triangular_filter_f32;

typedef struct {
    float32_t re;
    float32_t im;
} Complex_type_f32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_instance_i32;

typedef struct {
    const float *__restrict__ pSrcA;
    const float *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t nPE;
    float *__restrict__ pDstC;
} plp_mat_mult_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t shift;
    uint32_t nPE;
    int8_t *__restrict__ pDstC;
} plp_mat_mult_instance_q8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t shift;
    uint32_t nPE;
    int16_t *__restrict__ pDstC;
} plp_mat_mult_instance_q16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t shift;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_instance_q32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_instance_i32;

typedef struct {
    const float *__restrict__ pSrcA;
    const float *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t nPE;
    float *__restrict__ pDstC;
} plp_mat_mult_cmplx_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t shift;
    uint32_t nPE;
    int8_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_instance_q8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t shift;
    uint32_t nPE;
    int16_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_instance_q16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t shift;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_instance_q32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_add_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_add_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_add_instance_i32;

typedef struct {
    const float *__restrict__ pSrcA;
    const float *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_add_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_sub_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_sub_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_sub_instance_i32;

typedef struct {
    const float *__restrict__ pSrcA;
    const float *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_sub_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    int8_t scaleFactor;
    int32_t shift;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_scale_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    int16_t scaleFactor;
    int32_t shift;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_scale_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    int32_t scaleFactor;
    int32_t shift;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_scale_instance_i32;

typedef struct {
    const float *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    float scaleFactor;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_scale_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_trans_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_trans_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_trans_instance_i32;

typedef struct {
    uint32_t N;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_fill_I_instance_i8;

typedef struct {
    uint32_t N;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_fill_I_instance_i16;

typedef struct {
    uint32_t N;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_fill_I_instance_i32;

typedef struct {
    uint32_t N;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_fill_I_instance_f32;

typedef struct {
    uint32_t N;
    int32_t fracBits;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_fill_I_instance_q8;

typedef struct {
    uint32_t N;
    uint32_t fracBits;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_fill_I_instance_q16;

typedef struct {
    uint32_t N;
    uint32_t fracBits;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_fill_I_instance_q32;

typedef struct {
    float *__restrict__ pSrc;
    float *__restrict__ pDst;
    uint32_t *__restrict__ flag;
    uint32_t N;
    uint32_t nPE;
} plp_mat_inv_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_stride_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_stride_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_stride_instance_i32;

typedef struct {
    const float *__restrict__ pSrcA;
    const float *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t nPE;
    float *__restrict__ pDstC;
} plp_mat_mult_stride_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t shift;
    uint32_t nPE;
    int8_t *__restrict__ pDstC;
} plp_mat_mult_stride_instance_q8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t shift;
    uint32_t nPE;
    int16_t *__restrict__ pDstC;
} plp_mat_mult_stride_instance_q16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t shift;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_stride_instance_q32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_stride_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_stride_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_stride_instance_i32;

typedef struct {
    const float *__restrict__ pSrcA;
    const float *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t nPE;
    float *__restrict__ pDstC;
} plp_mat_mult_cmplx_stride_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t shift;
    uint32_t nPE;
    int8_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_stride_instance_q8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t shift;
    uint32_t nPE;
    int16_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_stride_instance_q16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t O;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideC;
    uint32_t shift;
    uint32_t nPE;
    int32_t *__restrict__ pDstC;
} plp_mat_mult_cmplx_stride_instance_q32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideY;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_add_stride_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideY;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_add_stride_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideY;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_add_stride_instance_i32;

typedef struct {
    const float *__restrict__ pSrcA;
    const float *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideY;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_add_stride_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrcA;
    const int8_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideY;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_sub_stride_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrcA;
    const int16_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideY;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_sub_stride_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrcA;
    const int32_t *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideY;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_sub_stride_instance_i32;

typedef struct {
    const float *__restrict__ pSrcA;
    const float *__restrict__ pSrcB;
    uint32_t M;
    uint32_t N;
    uint32_t strideA;
    uint32_t strideB;
    uint32_t strideY;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_sub_stride_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t strideSrc;
    uint32_t strideDst;
    int8_t scaleFactor;
    int32_t shift;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_scale_stride_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t strideSrc;
    uint32_t strideDst;
    int16_t scaleFactor;
    int32_t shift;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_scale_stride_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t strideSrc;
    uint32_t strideDst;
    int32_t scaleFactor;
    int32_t shift;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_scale_stride_instance_i32;

typedef struct {
    const float *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t strideSrc;
    uint32_t strideDst;
    float scaleFactor;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_scale_stride_instance_f32;

typedef struct {
    uint32_t N;
    uint32_t stride;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_fill_I_stride_instance_i8;

typedef struct {
    uint32_t N;
    uint32_t stride;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_fill_I_stride_instance_i16;

typedef struct {
    uint32_t N;
    uint32_t stride;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_fill_I_stride_instance_i32;

typedef struct {
    uint32_t N;
    uint32_t stride;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_fill_I_stride_instance_f32;

typedef struct {
    uint32_t N;
    uint32_t stride;
    uint32_t nPE;
    int32_t fracBits;
    int8_t *__restrict__ pDst;
} plp_mat_fill_I_stride_instance_q8;

typedef struct {
    uint32_t N;
    uint32_t stride;
    uint32_t nPE;
    int32_t fracBits;
    int16_t *__restrict__ pDst;
} plp_mat_fill_I_stride_instance_q16;

typedef struct {
    uint32_t N;
    uint32_t stride;
    uint32_t nPE;
    int32_t fracBits;
    int32_t *__restrict__ pDst;
} plp_mat_fill_I_stride_instance_q32;

typedef struct {
    uint32_t M;
    uint32_t N;
    uint32_t stride;
    int8_t value;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_fill_stride_instance_i8;

typedef struct {
    uint32_t M;
    uint32_t N;
    uint32_t stride;
    int16_t value;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_fill_stride_instance_i16;

typedef struct {
    uint32_t M;
    uint32_t N;
    uint32_t stride;
    int32_t value;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_fill_stride_instance_i32;

typedef struct {
    uint32_t M;
    uint32_t N;
    uint32_t stride;
    float value;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_fill_stride_instance_f32;

typedef struct {
    const int8_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t strideSrc;
    uint32_t strideDst;
    uint32_t nPE;
    int8_t *__restrict__ pDst;
} plp_mat_copy_stride_instance_i8;

typedef struct {
    const int16_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t strideSrc;
    uint32_t strideDst;
    uint32_t nPE;
    int16_t *__restrict__ pDst;
} plp_mat_copy_stride_instance_i16;

typedef struct {
    const int32_t *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t strideSrc;
    uint32_t strideDst;
    uint32_t nPE;
    int32_t *__restrict__ pDst;
} plp_mat_copy_stride_instance_i32;

typedef struct {
    const float *__restrict__ pSrc;
    uint32_t M;
    uint32_t N;
    uint32_t strideSrc;
    uint32_t strideDst;
    uint32_t nPE;
    float *__restrict__ pDst;
} plp_mat_copy_stride_instance_f32;

typedef struct {
    const float32_t *pSrcA; // pointer to the first vector
    const float32_t *pSrcB; // pointer to the second vector
    uint32_t blkSizePE;     // number of samples in each vector
    uint32_t nPE;           // number of processing units
    float32_t *resBuffer;   // pointer to result vector
} plp_euclidean_distance_instance_f32;

typedef struct {
    const int32_t *pSrcA;   // pointer to the first vector
    const int32_t *pSrcB;   // pointer to the second vector
    uint32_t blkSizePE;     // number of samples in each vector
    uint32_t nPE;           // number of processing units
    uint32_t fracBits;      // number of fixed point fractional bits
    int32_t *resBuffer;     // pointer to result vector
} plp_euclidean_distance_instance_q32;

typedef struct {
    const float32_t *pSrcA; // pointer to the first vector
    const float32_t *pSrcB; // pointer to the second vector
    uint32_t blkSizePE;     // number of samples in each vector
    uint32_t nPE;           // number of processing units
    float32_t *resBuffer_A;   // pointer to result vector
    float32_t *resBuffer_B;   // pointer to result vector
    float32_t *resBuffer_dot;   // pointer to result vector
} plp_cosine_distance_instance_f32;

typedef struct {
    int32_t *pSrc;     // pointer to the first vector
    uint32_t blkSizePE; // number of samples in each vector
    uint32_t fracBits; // fracBits for right shift
    uint32_t nPE;       // number of processing units
    int32_t *resBuffer; // pointer to result vector
} plp_power_instance_q32;

typedef struct {
    const float32_t *pSrc; // pointer to the first vector
    uint32_t blkSizePE;     // number of samples in each vector
    uint32_t nPE;           // number of processing units
    float32_t *resBuffer;   // pointer to result vector
} plp_power_instance_f32;



typedef enum {
    PLP_DWT_WAVELET_OTHER,
    PLP_DWT_WAVELET_HAAR,

    PLP_DWT_WAVELET_DB1,
    PLP_DWT_WAVELET_DB2,
    PLP_DWT_WAVELET_DB3,
    PLP_DWT_WAVELET_DB4,
    PLP_DWT_WAVELET_DB5,
    PLP_DWT_WAVELET_DB6,
    PLP_DWT_WAVELET_DB7,
    PLP_DWT_WAVELET_DB8,
    PLP_DWT_WAVELET_DB9,
    PLP_DWT_WAVELET_DB10,
    PLP_DWT_WAVELET_DB11,
    PLP_DWT_WAVELET_DB12,
    PLP_DWT_WAVELET_DB13,
    PLP_DWT_WAVELET_DB14,
    PLP_DWT_WAVELET_DB15,
    PLP_DWT_WAVELET_DB16,
    PLP_DWT_WAVELET_DB17,
    PLP_DWT_WAVELET_DB18,
    PLP_DWT_WAVELET_DB19,
    PLP_DWT_WAVELET_DB20,

    PLP_DWT_WAVELET_SYM2,
    PLP_DWT_WAVELET_SYM3,
    PLP_DWT_WAVELET_SYM4,
    PLP_DWT_WAVELET_SYM5,
    PLP_DWT_WAVELET_SYM6,
    PLP_DWT_WAVELET_SYM7,
    PLP_DWT_WAVELET_SYM8,
    PLP_DWT_WAVELET_SYM9,
    PLP_DWT_WAVELET_SYM10,
    PLP_DWT_WAVELET_SYM11,
    PLP_DWT_WAVELET_SYM12,
    PLP_DWT_WAVELET_SYM13,
    PLP_DWT_WAVELET_SYM14,
    PLP_DWT_WAVELET_SYM15,
    PLP_DWT_WAVELET_SYM16,
    PLP_DWT_WAVELET_SYM17,
    PLP_DWT_WAVELET_SYM18,
    PLP_DWT_WAVELET_SYM19,
    PLP_DWT_WAVELET_SYM20,

    PLP_DWT_WAVELET_COIF1,
    PLP_DWT_WAVELET_COIF2,
    PLP_DWT_WAVELET_COIF3,
    PLP_DWT_WAVELET_COIF4,
    PLP_DWT_WAVELET_COIF5,
    PLP_DWT_WAVELET_COIF6,
    PLP_DWT_WAVELET_COIF7,
    PLP_DWT_WAVELET_COIF8,
    PLP_DWT_WAVELET_COIF9,
    PLP_DWT_WAVELET_COIF10,
    PLP_DWT_WAVELET_COIF11,
    PLP_DWT_WAVELET_COIF12,
    PLP_DWT_WAVELET_COIF13,
    PLP_DWT_WAVELET_COIF14,
    PLP_DWT_WAVELET_COIF15,
    PLP_DWT_WAVELET_COIF16,
    PLP_DWT_WAVELET_COIF17
} plp_dwt_wavelet_type;


typedef struct {

   uint32_t length;
   plp_dwt_wavelet_type type;

   float32_t *dec_lo; /* decomposition lowpass */
   float32_t *dec_hi; /* decomposition highpass */

   float32_t *rec_lo; /* reconstruction lowpass */
   float32_t *rec_hi; /* reconstruction highpass */

} plp_dwt_wavelet_f32;

typedef struct {

   uint32_t length;
   plp_dwt_wavelet_type type;

   int32_t *dec_lo; /* decomposition lowpass */
   int32_t *dec_hi; /* decomposition highpass */
} plp_dwt_wavelet_q32;

typedef struct {

   uint32_t length;
   plp_dwt_wavelet_type type;

   int16_t *dec_lo; /* decomposition lowpass */
   int16_t *dec_hi; /* decomposition highpass */
} plp_dwt_wavelet_q16;

typedef struct {

   uint32_t length;
   plp_dwt_wavelet_type type;

   int8_t *dec_lo; /* decomposition lowpass */
   int8_t *dec_hi; /* decomposition highpass */
} plp_dwt_wavelet_q8;



typedef enum {
    PLP_DWT_MODE_ZERO,
    PLP_DWT_MODE_CONSTANT,
    PLP_DWT_MODE_SYMMETRIC,
    PLP_DWT_MODE_REFLECT,
    PLP_DWT_MODE_PERIODIC,
    PLP_DWT_MODE_ANTISYMMETRIC,
    PLP_DWT_MODE_ANTIREFLECT
} plp_dwt_extension_mode;


typedef struct {
    const float32_t *pSrc;             //  points to the input buffer
    uint32_t length;                   // length of input buffer
    plp_dwt_wavelet_f32 wavelet; // wavelet structure for calculating DWT
    plp_dwt_extension_mode mode;       // boundary extension mode
    uint32_t nPE;                      // number of processing units

    float32_t *pDstA;                  // output buffer with Approximate coefficients
    float32_t *pDstD;                  // ouput buffer with Detailed coefficients
} plp_dwt_instance_f32;

typedef struct {
    const int32_t *pSrc;  //  points to the input buffer
    uint32_t length;        // length of input buffer
    plp_dwt_wavelet_q32 wavelet; // wavelet structure for calculating DWT
    plp_dwt_extension_mode mode; // boundary extension mode
    uint32_t nPE;           // number of processing units

    int32_t *pDstA;   // output buffer with Approximate coefficients
    int32_t *pDstD;   // ouput buffer with Detailed coefficients
} plp_dwt_instance_q32;


typedef struct {
    const int16_t *pSrc;  //  points to the input buffer
    uint32_t length;        // length of input buffer
    plp_dwt_wavelet_q16 wavelet; // wavelet structure for calculating DWT
    plp_dwt_extension_mode mode; // boundary extension mode
    uint32_t nPE;           // number of processing units

    int16_t *pDstA;   // output buffer with Approximate coefficients
    int16_t *pDstD;   // ouput buffer with Detailed coefficients
} plp_dwt_instance_q16;

typedef struct {
    const int8_t *pSrc;  //  points to the input buffer
    uint32_t length;        // length of input buffer
    plp_dwt_wavelet_q8 wavelet; // wavelet structure for calculating DWT
    plp_dwt_extension_mode mode; // boundary extension mode
    uint32_t nPE;           // number of processing units

    int8_t *pDstA;   // output buffer with Approximate coefficients
    int8_t *pDstD;   // ouput buffer with Detailed coefficients
} plp_dwt_instance_q8;


#define PLP_DWT_DEC_LEN(SIG_LEN, WAVELET, LEVEL) plp_dwt_dec_len(SIG_LEN, WAVELET.length, LEVEL)
#define PLP_DWT_DEC_TEMP_LEN(SRC_LEN, WAVELET_LEN) (((SRC_LEN+WAVELET_LEN-1)/2 + ((SRC_LEN+WAVELET_LEN-1)/2 + WAVELET_LEN-1))/2)
#define PLP_DWT_OUTPUT_LENGTH(SIG_LEN, WAVELET_LEN) ((SIG_LEN + WAVELET_LEN - 1) &gt;&gt; 1)

uint32_t plp_dwt_max_level(uint32_t sig_len, uint32_t wavelet_len);

uint32_t plp_dwt_dec_len(uint32_t sig_len, uint32_t wavelet_len, uint32_t level);

void plp_dot_prod_i32_parallel(const int32_t *__restrict__ pSrcA,
                               const int32_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               uint32_t nPE,
                               int32_t *__restrict__ pRes);

void plp_dot_prod_q32_parallel(const int32_t *__restrict__ pSrcA,
                               const int32_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               uint32_t deciPoint,
                               uint32_t nPE,
                               int32_t *__restrict__ pRes);

void plp_dot_prod_f32_parallel(const float32_t *__restrict__ pSrcA,
                               const float32_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               uint32_t nPE,
                               float32_t *__restrict__ pRes);

void plp_dot_prod_i32p_xpulpv2(void *S);

void plp_dot_prod_q32p_xpulpv2(void *S);

void plp_dot_prod_f32p_xpulpv2(void *S);

void plp_dot_prod_i32(const int32_t *__restrict__ pSrcA,
                      const int32_t *__restrict__ pSrcB,
                      uint32_t blockSize,
                      int32_t *__restrict__ pRes);

void plp_dot_prod_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              uint32_t blockSize,
                              int32_t *__restrict__ pRes);

void plp_dot_prod_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                               const int32_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               int32_t *__restrict__ pRes);

void plp_dot_prod_q32(const int32_t *__restrict__ pSrcA,
                      const int32_t *__restrict__ pSrcB,
                      uint32_t blockSize,
                      uint32_t deciPoint,
                      int32_t *__restrict__ pRes);

void plp_dot_prod_q32s_rv32im(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              uint32_t blockSize,
                              uint32_t deciPoint,
                              int32_t *__restrict__ pRes);

void plp_dot_prod_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                               const int32_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               uint32_t deciPoint,
                               int32_t *__restrict__ pRes);

void plp_dot_prod_f32(const float32_t *__restrict__ pSrcA,
                      const float32_t *__restrict__ pSrcB,
                      uint32_t blockSize,
                      float32_t *__restrict__ pRes);

void plp_dot_prod_f32s_xpulpv2(const float32_t *__restrict__ pSrcA,
                               const float32_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               float32_t *__restrict__ pRes);

void plp_dot_prod_f32s_rv32im(const float32_t *__restrict__ pSrcA,
                               const float32_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               float32_t *__restrict__ pRes);


void plp_dot_prod_i16(const int16_t *pSrcA,
                      const int16_t *pSrcB,
                      uint32_t blockSize,
                      int32_t *__restrict__ pRes);

void plp_dot_prod_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t blockSize,
                              int32_t *__restrict__ pRes);

void plp_dot_prod_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                               const int16_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               int32_t *__restrict__ pRes);

void plp_dot_prod_q16(const int16_t *__restrict__ pSrcA,
                      const int16_t *__restrict__ pSrcB,
                      uint32_t blockSize,
                      uint32_t deciPoint,
                      int32_t *__restrict__ pRes);

void plp_dot_prod_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t blockSize,
                              uint32_t deciPoint,
                              int32_t *__restrict__ pRes);

void plp_dot_prod_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                               const int16_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               uint32_t deciPoint,
                               int32_t *__restrict__ pRes);

void plp_dot_prod_i8(const int8_t *__restrict__ pSrcA,
                     const int8_t *__restrict__ pSrcB,
                     uint32_t blockSize,
                     int32_t *__restrict__ pRes);

void plp_dot_prod_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             uint32_t blockSize,
                             int32_t *__restrict__ pRes);

void plp_dot_prod_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                              const int8_t *__restrict__ pSrcB,
                              uint32_t blockSize,
                              int32_t *__restrict__ pRes);

void plp_dot_prod_q8(const int8_t *__restrict__ pSrcA,
                     const int8_t *__restrict__ pSrcB,
                     uint32_t blockSize,
                     uint32_t deciPoint,
                     int32_t *__restrict__ pRes);

void plp_dot_prod_q8s_rv32im(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             uint32_t blockSize,
                             uint32_t deciPoint,
                             int32_t *__restrict__ pRes);

void plp_dot_prod_q8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                              const int8_t *__restrict__ pSrcB,
                              uint32_t blockSize,
                              uint32_t deciPoint,
                              int32_t *__restrict__ pRes);

void plp_abs_i32(const int32_t * pSrc,
                 int32_t * pDst,
                 uint32_t blockSize);

void plp_abs_i32s_rv32im(const int32_t * pSrc,
                         int32_t * pDst,
                         uint32_t blockSize);

void plp_abs_i32s_xpulpv2(const int32_t * pSrc,
                          int32_t * pDst,
                          uint32_t blockSize);

void plp_abs_i16(const int16_t * pSrc,
                 int16_t * pDst,
                 uint32_t blockSize);

void plp_abs_i16s_rv32im(const int16_t * pSrc,
                         int16_t * pDst,
                         uint32_t blockSize);

void plp_abs_i16s_xpulpv2(const int16_t * pSrc,
                          int16_t * pDst,
                          uint32_t blockSize);

void plp_abs_i8(const int8_t * pSrc,
                 int8_t * pDst,
                 uint32_t blockSize);

void plp_abs_i8s_rv32im(const int8_t * pSrc,
                         int8_t * pDst,
                         uint32_t blockSize);

void plp_abs_i8s_xpulpv2(const int8_t * pSrc,
                          int8_t * pDst,
                          uint32_t blockSize);

void plp_add_i32(const int32_t * pSrcA,
                 const int32_t * pSrcB,
                 int32_t * pDst,
                 uint32_t blockSize);

void plp_add_i32s_rv32im(const int32_t * pSrcA,
                         const int32_t * pSrcB,
                         int32_t * pDst,
                         uint32_t blockSize);

void plp_add_i32s_xpulpv2(const int32_t * pSrcA,
                          const int32_t * pSrcB,
                          int32_t * pDst,
                          uint32_t blockSize);

void plp_add_i16(const int16_t * pSrcA,
                 const int16_t * pSrcB,
                 int32_t * pDst,
                 uint32_t blockSize);

void plp_add_i16s_rv32im(const int16_t * pSrcA,
                         const int16_t * pSrcB,
                         int32_t * pDst,
                         uint32_t blockSize);

void plp_add_i16s_xpulpv2(const int16_t * pSrcA,
                          const int16_t * pSrcB,
                          int32_t * pDst,
                          uint32_t blockSize);

void plp_add_i8(const int8_t * pSrcA,
                 const int8_t * pSrcB,
                 int32_t * pDst,
                 uint32_t blockSize);

void plp_add_i8s_rv32im(const int8_t * pSrcA,
                         const int8_t * pSrcB,
                         int32_t * pDst,
                         uint32_t blockSize);

void plp_add_i8s_xpulpv2(const int8_t * pSrcA,
                          const int8_t * pSrcB,
                          int32_t * pDst,
                          uint32_t blockSize);

void plp_mult_i32(const int32_t * pSrcA,
                 const int32_t * pSrcB,
                 int32_t * pDst,
                 uint32_t blockSize);

void plp_mult_i32s_rv32im(const int32_t * pSrcA,
                         const int32_t * pSrcB,
                         int32_t * pDst,
                         uint32_t blockSize);

void plp_mult_i32s_xpulpv2(const int32_t * pSrcA,
                          const int32_t * pSrcB,
                          int32_t * pDst,
                          uint32_t blockSize);

void plp_mult_i16(const int16_t * pSrcA,
                 const int16_t * pSrcB,
                 int32_t * pDst,
                 uint32_t blockSize);

void plp_mult_i16s_rv32im(const int16_t * pSrcA,
                         const int16_t * pSrcB,
                         int32_t * pDst,
                         uint32_t blockSize);

void plp_mult_i16s_xpulpv2(const int16_t * pSrcA,
                          const int16_t * pSrcB,
                          int32_t * pDst,
                          uint32_t blockSize);

void plp_mult_i8(const int8_t * pSrcA,
                 const int8_t * pSrcB,
                 int32_t * pDst,
                 uint32_t blockSize);

void plp_mult_i8s_rv32im(const int8_t * pSrcA,
                         const int8_t * pSrcB,
                         int32_t * pDst,
                         uint32_t blockSize);

void plp_mult_i8s_xpulpv2(const int8_t * pSrcA,
                          const int8_t * pSrcB,
                          int32_t * pDst,
                          uint32_t blockSize);

void plp_mult_f32(const float32_t * pSrcA,
                 const float32_t * pSrcB,
                 float32_t * pDst,
                 uint32_t blockSize);

void plp_mult_f32s_xpulpv2(const float32_t * pSrcA,
                          const float32_t * pSrcB,
                          float32_t * pDst,
                          uint32_t blockSize);

void plp_mult_f32_parallel(const float32_t *__restrict__ pSrcA,
                               const float32_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               uint32_t nPE,
                               float32_t *__restrict__ pDst);
void plp_mult_f32p_xpulpv2(void *S);

void plp_log_f32_parallel(const float32_t *__restrict__ pSrc,
                               uint32_t blockSize,
                               uint32_t nPE,
                               float32_t *__restrict__ pDst);

void plp_log_f32p_xpulpv2(void *S);

void plp_negate_i32(const int32_t * pSrc, int32_t * pDst, uint32_t blockSize);

void plp_negate_i32s_rv32im(const int32_t * pSrc, int32_t * pDst, uint32_t blockSize);

void plp_negate_i32s_xpulpv2(const int32_t * pSrc, int32_t * pDst, uint32_t blockSize);

void plp_negate_i16(const int16_t * pSrc, int16_t * pDst, uint32_t blockSize);

void plp_negate_i16s_rv32im(const int16_t * pSrc, int16_t * pDst, uint32_t blockSize);

void plp_negate_i16s_xpulpv2(const int16_t * pSrc, int16_t * pDst, uint32_t blockSize);

void plp_negate_i8(const int8_t * pSrc, int8_t * pDst, uint32_t blockSize);

void plp_negate_i8s_rv32im(const int8_t * pSrc, int8_t * pDst, uint32_t blockSize);

void plp_negate_i8s_xpulpv2(const int8_t * pSrc, int8_t * pDst, uint32_t blockSize);

void plp_negate_f32(const float32_t * pSrc, float32_t * pDst, uint32_t blockSize);

void plp_negate_f32s_xpulpv2(const float32_t * pSrc, float32_t * pDst, uint32_t blockSize);

void plp_offset_i32(const int32_t * pSrc, int32_t offset, int32_t * pDst, uint32_t blockSize);

void plp_offset_i32s_rv32im(const int32_t * pSrc, int32_t offset, int32_t * pDst, uint32_t blockSize);

void plp_offset_i32s_xpulpv2(const int32_t * pSrc, int32_t offset, int32_t * pDst, uint32_t blockSize);

void plp_offset_i16(const int16_t * pSrc, int16_t offset, int16_t * pDst, uint32_t blockSize);

void plp_offset_i16s_rv32im(const int16_t * pSrc, int16_t offset, int16_t * pDst, uint32_t blockSize);

void plp_offset_i16s_xpulpv2(const int16_t * pSrc, int16_t offset, int16_t * pDst, uint32_t blockSize);

void plp_offset_i8(const int8_t * pSrc, int8_t offset, int8_t * pDst, uint32_t blockSize);

void plp_offset_i8s_rv32im(const int8_t * pSrc, int8_t offset, int8_t * pDst, uint32_t blockSize);

void plp_offset_i8s_xpulpv2(const int8_t * pSrc, int8_t offset, int8_t * pDst, uint32_t blockSize);

void plp_offset_f32(const float32_t * pSrc, float32_t offset, float32_t * pDst, uint32_t blockSize);

void plp_offset_f32s_xpulpv2(const float32_t * pSrc, float32_t offset, float32_t * pDst, uint32_t blockSize);

void plp_sub_i32(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize);

void plp_sub_i32s_rv32im(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize);

void plp_sub_i32s_xpulpv2(const int32_t * pSrcA, const int32_t * pSrcB, int32_t * pDst, uint32_t blockSize);

void plp_sub_i16(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize);

void plp_sub_i16s_rv32im(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize);

void plp_sub_i16s_xpulpv2(const int16_t * pSrcA, const int16_t * pSrcB, int32_t * pDst, uint32_t blockSize);

void plp_sub_i8(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize);

void plp_sub_i8s_rv32im(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize);

void plp_sub_i8s_xpulpv2(const int8_t * pSrcA, const int8_t * pSrcB, int32_t * pDst, uint32_t blockSize);

void plp_sub_f32(const float32_t * pSrcA, const float32_t * pSrcB, float32_t * pDst, uint32_t blockSize);

void plp_sub_f32s_xpulpv2(const float32_t * pSrcA, const float32_t * pSrcB, float32_t * pDst, uint32_t blockSize);

void plp_scale_i32(const int32_t *__restrict__ pSrc, int32_t scaleFactor, int32_t shift, int32_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_i32s_rv32im(const int32_t *__restrict__ pSrc, int32_t scaleFactor, int32_t shift, int32_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_i32s_xpulpv2(const int32_t *__restrict__ pSrc, int32_t scaleFactor, int32_t shift, int32_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_i16(const int16_t *__restrict__ pSrc, int16_t scaleFactor, int32_t shift, int16_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_i16s_rv32im(const int16_t *__restrict__ pSrc, int16_t scaleFactor, int32_t shift, int16_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_i16s_xpulpv2(const int16_t *__restrict__ pSrc, int16_t scaleFactor, int32_t shift, int16_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_i8(const int8_t *__restrict__ pSrc, int8_t scaleFactor, int32_t shift, int8_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_i8s_rv32im(const int8_t *__restrict__ pSrc, int8_t scaleFactor, int32_t shift, int8_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_i8s_xpulpv2(const int8_t *__restrict__ pSrc, int8_t scaleFactor, int32_t shift, int8_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_f32(const float32_t *__restrict__ pSrc, float32_t scaleFactor, float32_t *__restrict__ pDst, uint32_t blockSize);

void plp_scale_f32s_xpulpv2(const float32_t *__restrict__ pSrc, float32_t scaleFactor, float32_t *__restrict__ pDst, uint32_t blockSize);

void plp_fill_i32(int32_t value, int32_t *__restrict__ pDst, uint32_t blockSize);

void plp_fill_i32s_rv32im(int32_t value, int32_t *__restrict__ pDst, uint32_t blockSize);

void plp_fill_i32s_xpulpv2(int32_t value, int32_t *__restrict__ pDst, uint32_t blockSize);

void plp_copy_i32(int32_t *__restrict__ pSrc, int32_t *__restrict__ pDst, uint32_t blockSize);

void plp_copy_i32s_rv32im(int32_t *__restrict__ pSrc,
                          int32_t *__restrict__ pDst,
                          uint32_t blockSize);

void plp_copy_i32s_xpulpv2(int32_t *__restrict__ pSrc,
                           int32_t *__restrict__ pDst,
                           uint32_t blockSize);

void plp_copy_f32(float32_t *__restrict__ pSrc, float32_t *__restrict__ pDst, uint32_t blockSize);

void plp_copy_f32s_xpulpv2(float32_t *__restrict__ pSrc,
                           float32_t *__restrict__ pDst,
                           uint32_t blockSize);

void plp_copy_f32s_rv32im(float32_t *__restrict__ pSrc,
                           float32_t *__restrict__ pDst,
                           uint32_t blockSize);

void plp_mean_f32(const float *__restrict__ pSrc, uint32_t blockSize, float *__restrict__ pRes);

void plp_mean_f32s_xpulpv2(const float *__restrict__ pSrc,
                           uint32_t blockSize,
                           float *__restrict__ pRes);

void plp_mean_i32(const int32_t *__restrict__ pSrc, uint32_t blockSize, int32_t *__restrict__ pRes);

void plp_mean_i32s_rv32im(const int32_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          int32_t *__restrict__ pRes);

void plp_mean_i32s_xpulpv2(const int32_t *__restrict__ pSrc,
                           uint32_t blockSize,
                           int32_t *__restrict__ pRes);

void plp_mean_i16(const int16_t *__restrict__ pSrc, uint32_t blockSize, int16_t *__restrict__ pRes);

void plp_mean_i16s_rv32im(const int16_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          int16_t *__restrict__ pRes);

void plp_mean_i16s_xpulpv2(const int16_t *__restrict__ pSrc,
                           uint32_t blockSize,
                           int16_t *__restrict__ pRes);

void plp_mean_i8(const int8_t *__restrict__ pSrc, uint32_t blockSize, int8_t *__restrict__ pRes);

void plp_mean_i8s_rv32im(const int8_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         int8_t *__restrict__ pRes);

void plp_mean_i8s_xpulpv2(const int8_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          int8_t *__restrict__ pRes);

void plp_max_f32(const float *__restrict__ pSrc, uint32_t blockSize, float *__restrict__ pRes);

void plp_max_f32s_xpulpv2(const float *__restrict__ pSrc,
                          uint32_t blockSize,
                          float *__restrict__ pRes);

void plp_max_i32(const int32_t *__restrict__ pSrc, uint32_t blockSize, int32_t *__restrict__ pRes);

void plp_max_i32s_rv32im(const int32_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         int32_t *__restrict__ pRes);

void plp_max_i32s_xpulpv2(const int32_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          int32_t *__restrict__ pRes);

void plp_max_i16(const int16_t *__restrict__ pSrc, uint32_t blockSize, int16_t *__restrict__ pRes);

void plp_max_i16s_rv32im(const int16_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         int16_t *__restrict__ pRes);

void plp_max_i16s_xpulpv2(const int16_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          int16_t *__restrict__ pRes);

void plp_max_i8(const int8_t *__restrict__ pSrc, uint32_t blockSize, int8_t *__restrict__ pRes);

void plp_max_i8s_rv32im(const int8_t *__restrict__ pSrc,
                        uint32_t blockSize,
                        int8_t *__restrict__ pRes);

void plp_max_i8s_xpulpv2(const int8_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         int8_t *__restrict__ pRes);

void plp_min_f32(const float *__restrict__ pSrc, uint32_t blockSize, float *__restrict__ pRes);

void plp_min_f32s_xpulpv2(const float *__restrict__ pSrc,
                          uint32_t blockSize,
                          float *__restrict__ pRes);

void plp_min_i32(const int32_t *__restrict__ pSrc, uint32_t blockSize, int32_t *__restrict__ pRes);

void plp_min_i32s_rv32im(const int32_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         int32_t *__restrict__ pRes);

void plp_min_i32s_xpulpv2(const int32_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          int32_t *__restrict__ pRes);

void plp_min_i16(const int16_t *__restrict__ pSrc, uint32_t blockSize, int16_t *__restrict__ pRes);

void plp_min_i16s_rv32im(const int16_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         int16_t *__restrict__ pRes);

void plp_min_i16s_xpulpv2(const int16_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          int16_t *__restrict__ pRes);

void plp_min_i8(const int8_t *__restrict__ pSrc, uint32_t blockSize, int8_t *__restrict__ pRes);

void plp_min_i8s_rv32im(const int8_t *__restrict__ pSrc,
                        uint32_t blockSize,
                        int8_t *__restrict__ pRes);

void plp_min_i8s_xpulpv2(const int8_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         int8_t *__restrict__ pRes);

void plp_power_f32_parallel(const float32_t *__restrict__ pSrc,
                            uint32_t blockSize,
                            uint32_t nPE,
                            float32_t *__restrict__ pRes);

void plp_power_f32p_xpulpv2(void* S);

void plp_power_f32(const float *__restrict__ pSrc, uint32_t blockSize, float *__restrict__ pRes);

void plp_power_f32s_xpulpv2(const float *__restrict__ pSrc,
                           uint32_t blockSize,
                           float *__restrict__ pRes);

void plp_power_f32s_rv32im(const float *__restrict__ pSrc,
                            uint32_t blockSize,
                            float *__restrict__ pRes);

void plp_power_i32(const int32_t *__restrict__ pSrc,
                   uint32_t blockSize,
                   int32_t *__restrict__ pRes);

void plp_power_i32s_rv32im(const int32_t *__restrict__ pSrc,
                           uint32_t blockSize,
                           int32_t *__restrict__ pRes);

void plp_power_i32s_xpulpv2(const int32_t *__restrict__ pSrc,
                            uint32_t blockSize,
                            int32_t *__restrict__ pRes);

void plp_power_i16(const int16_t *__restrict__ pSrc,
                   uint32_t blockSize,
                   int32_t *__restrict__ pRes);

void plp_power_i16s_rv32im(const int16_t *__restrict__ pSrc,
                           uint32_t blockSize,
                           int32_t *__restrict__ pRes);

void plp_power_i16s_xpulpv2(const int16_t *__restrict__ pSrc,
                            uint32_t blockSize,
                            int32_t *__restrict__ pRes);

void plp_power_i8(const int8_t *__restrict__ pSrc, uint32_t blockSize, int32_t *__restrict__ pRes);

void plp_power_i8s_rv32im(const int8_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          int32_t *__restrict__ pRes);

void plp_power_i8s_xpulpv2(const int8_t *__restrict__ pSrc,
                           uint32_t blockSize,
                           int32_t *__restrict__ pRes);

void plp_power_q32_parallel(const int32_t *__restrict__ pSrc,
                            uint32_t blockSize,
                            uint32_t fracBits,
                            uint32_t nPE,
                            int32_t *__restrict__ pRes);

void plp_power_q32p_xpulpv2(void *S);

void plp_power_q32(const int32_t *__restrict__ pSrc,
                   uint32_t blockSize,
                   uint32_t fracBits,
                   int32_t *__restrict__ pRes);

void plp_power_q32s_rv32im(const int32_t *__restrict__ pSrc,
                           uint32_t blockSize,
                           uint32_t fracBits,
                           int32_t *__restrict__ pRes);

void plp_power_q32s_xpulpv2(const int32_t *__restrict__ pSrc,
                            uint32_t blockSize,
                            uint32_t fracBits,
                            int32_t *__restrict__ pRes);

void plp_power_q16(const int16_t *__restrict__ pSrc,
                   uint32_t blockSize,
                   uint32_t fracBits,
                   int32_t *__restrict__ pRes);

void plp_power_q16s_rv32im(const int16_t *__restrict__ pSrc,
                           uint32_t blockSize,
                           uint32_t fracBits,
                           int32_t *__restrict__ pRes);

void plp_power_q16s_xpulpv2(const int16_t *__restrict__ pSrc,
                            uint32_t blockSize,
                            uint32_t fracBits,
                            int32_t *__restrict__ pRes);

void plp_power_q8(const int8_t *__restrict__ pSrc,
                  uint32_t blockSize,
                  uint32_t fracBits,
                  int32_t *__restrict__ pRes);

void plp_power_q8s_rv32im(const int8_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          uint32_t fracBits,
                          int32_t *__restrict__ pRes);

void plp_power_q8s_xpulpv2(const int8_t *__restrict__ pSrc,
                           uint32_t blockSize,
                           uint32_t fracBits,
                           int32_t *__restrict__ pRes);

void plp_var_f32(const float *__restrict__ pSrc, uint32_t blockSize, float *__restrict__ pRes);

void plp_var_f32s_xpulpv2(const float *__restrict__ pSrc,
                         uint32_t blockSize,
                         float *__restrict__ pRes);

void plp_var_q32(const int32_t *__restrict__ pSrc,
                 uint32_t blockSize,
                 uint32_t fracBits,
                 int32_t *__restrict__ pRes);

void plp_var_q32s_rv32im(const int32_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         uint32_t fracBits,
                         int32_t *__restrict__ pRes);

void plp_var_q32s_xpulpv2(const int32_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          uint32_t fracBits,
                          int32_t *__restrict__ pRes);

void plp_var_q16(const int16_t *__restrict__ pSrc,
                 uint32_t blockSize,
                 uint32_t fracBits,
                 int16_t *__restrict__ pRes);

void plp_var_q16s_rv32im(const int16_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         uint32_t fracBits,
                         int16_t *__restrict__ pRes);

void plp_var_q16s_xpulpv2(const int16_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          uint32_t fracBits,
                          int16_t *__restrict__ pRes);

void plp_var_q8(const int8_t *__restrict__ pSrc,
                uint32_t blockSize,
                uint32_t fracBits,
                int8_t *__restrict__ pRes);

void plp_var_q8s_rv32im(const int8_t *__restrict__ pSrc,
                        uint32_t blockSize,
                        uint32_t fracBits,
                        int8_t *__restrict__ pRes);

void plp_var_q8s_xpulpv2(const int8_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         uint32_t fracBits,
                         int8_t *__restrict__ pRes);

void plp_std_f32(const float *__restrict__ pSrc, uint32_t blockSize, float *__restrict__ pRes);

void plp_std_f32s_xpulpv2(const float *__restrict__ pSrc,
                         uint32_t blockSize,
                         float *__restrict__ pRes);

void plp_std_q32(const int32_t *__restrict__ pSrc,
                 uint32_t blockSize,
                 uint32_t fracBits,
                 int32_t *__restrict__ pRes);

void plp_std_q32s_rv32im(const int32_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         uint32_t fracBits,
                         int32_t *__restrict__ pRes);

void plp_std_q32s_xpulpv2(const int32_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          uint32_t fracBits,
                          int32_t *__restrict__ pRes);

void plp_std_q16(const int16_t *__restrict__ pSrc,
                 uint32_t blockSize,
                 uint32_t fracBits,
                 int16_t *__restrict__ pRes);

void plp_std_q16s_rv32im(const int16_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         uint32_t fracBits,
                         int16_t *__restrict__ pRes);

void plp_std_q16s_xpulpv2(const int16_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          uint32_t fracBits,
                          int16_t *__restrict__ pRes);

void plp_std_q8(const int8_t *__restrict__ pSrc,
                uint32_t blockSize,
                uint32_t fracBits,
                int8_t *__restrict__ pRes);

void plp_std_q8s_rv32im(const int8_t *__restrict__ pSrc,
                        uint32_t blockSize,
                        uint32_t fracBits,
                        int8_t *__restrict__ pRes);

void plp_std_q8s_xpulpv2(const int8_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         uint32_t fracBits,
                         int8_t *__restrict__ pRes);
void plp_rms_f32(const float *__restrict__ pSrc, uint32_t blockSize, float *__restrict__ pRes);

void plp_rms_f32s_xpulpv2(const float *__restrict__ pSrc,
                         uint32_t blockSize,
                         float *__restrict__ pRes);

void plp_rms_q32(const int32_t *__restrict__ pSrc,
                 uint32_t blockSize,
                 uint32_t fracBits,
                 int32_t *__restrict__ pRes);

void plp_rms_q32s_rv32im(const int32_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         uint32_t fracBits,
                         int32_t *__restrict__ pRes);

void plp_rms_q32s_xpulpv2(const int32_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          uint32_t fracBits,
                          int32_t *__restrict__ pRes);

void plp_rms_q16(const int16_t *__restrict__ pSrc,
                 uint32_t blockSize,
                 uint32_t fracBits,
                 int16_t *__restrict__ pRes);

void plp_rms_q16s_rv32im(const int16_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         uint32_t fracBits,
                         int16_t *__restrict__ pRes);

void plp_rms_q16s_xpulpv2(const int16_t *__restrict__ pSrc,
                          uint32_t blockSize,
                          uint32_t fracBits,
                          int16_t *__restrict__ pRes);

void plp_rms_q8(const int8_t *__restrict__ pSrc,
                uint32_t blockSize,
                uint32_t fracBits,
                int8_t *__restrict__ pRes);

void plp_rms_q8s_rv32im(const int8_t *__restrict__ pSrc,
                        uint32_t blockSize,
                        uint32_t fracBits,
                        int8_t *__restrict__ pRes);

void plp_rms_q8s_xpulpv2(const int8_t *__restrict__ pSrc,
                         uint32_t blockSize,
                         uint32_t fracBits,
                         int8_t *__restrict__ pRes);

void plp_sqrt_q32(const int32_t *__restrict__ pSrc,
                  const uint32_t fracBits,
                  int32_t *__restrict__ pRes);

void plp_sqrt_q32s_rv32im(const int32_t *__restrict__ pSrc,
                          const uint32_t fracBits,
                          int32_t *__restrict__ pRes);

void plp_sqrt_q32s_xpulpv2(const int32_t *__restrict__ pSrc,
                           const uint32_t fracBits,
                           int32_t *__restrict__ pRes);

void plp_sqrt_q16(const int16_t *__restrict__ pSrc,
                  const uint32_t fracBits,
                  int16_t *__restrict__ pRes);

void plp_sqrt_q16s_rv32im(const int16_t *__restrict__ pSrc,
                          const uint32_t fracBits,
                          int16_t *__restrict__ pRes);

void plp_sqrt_q16s_xpulpv2(const int16_t *__restrict__ pSrc,
                           const uint32_t fracBits,
                           int16_t *__restrict__ pRes);


void plp_sqrt_f32(const float *__restrict__ pSrc, 
                  float *__restrict__ pRes);

void plp_sqrt_f32s_rv32im(const float *__restrict__ pSrc, float *__restrict__ pRes);

void plp_sqrt_f32s_xpulpv2(const float *__restrict__ pSrc,
                           float *__restrict__ pRes);


#define FAST_MATH_TABLE_SIZE 512
#define FAST_MATH_Q32_SHIFT (32 - 10)
#define FAST_MATH_Q16_SHIFT (16 - 10)
#define CONTROLLER_Q32_SHIFT (32 - 9)
#define TABLE_SPACING_Q32 0x400000
#define TABLE_SPACING_Q16 0x80

int32_t plp_cos_q32(int32_t x);

int32_t plp_cos_q32s_rv32im(int32_t x);

int32_t plp_cos_q32s_xpulpv2(int32_t x);

int16_t plp_cos_q16(int16_t x);

int16_t plp_cos_q16s_rv32im(int16_t x);

int16_t plp_cos_q16s_xpulpv2(int16_t x);

float32_t plp_cos_f32(float32_t x);

float32_t plp_cos_f32s_xpulpv2(float32_t x);

int32_t plp_sin_q32(int32_t x);

int32_t plp_sin_q32s_rv32im(int32_t x);

int32_t plp_sin_q32s_xpulpv2(int32_t x);

int16_t plp_sin_q16(int16_t x);

int16_t plp_sin_q16s_rv32im(int16_t x);

int16_t plp_sin_q16s_xpulpv2(int16_t x);

float32_t plp_sin_f32(float32_t x);

float32_t plp_sin_f32s_xpulpv2(float32_t x);

void plp_correlate_i32(const int32_t *pSrcA,
                       const uint32_t srcALen,
                       const int32_t *pSrcB,
                       const uint32_t srcBLen,
                       int32_t *pRes);

void plp_correlate_i32s_rv32im(const int32_t *pSrcA,
                               const uint32_t srcALen,
                               const int32_t *pSrcB,
                               const uint32_t srcBLen,
                               int32_t *pRes);

void plp_correlate_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                const uint32_t srcALen,
                                const int32_t *__restrict__ pSrcB,
                                const uint32_t srcBLen,
                                int32_t *__restrict__ pRes);

void plp_correlate_i16(const int16_t *pSrcA,
                       const uint32_t srcALen,
                       const int16_t *pSrcB,
                       const uint32_t srcBLen,
                       int32_t *pRes);

void plp_correlate_i16s_xpulpv2(const int16_t *pSrcA,
                                const uint32_t srcALen,
                                const int16_t *pSrcB,
                                const uint32_t srcBLen,
                                int32_t *pRes);

void plp_correlate_i16s_rv32im(const int16_t *pSrcA,
                               const uint32_t srcALen,
                               const int16_t *pSrcB,
                               const uint32_t srcBLen,
                               int32_t *pRes);

void plp_correlate_i8(const int8_t *pSrcA,
                      const uint32_t srcALen,
                      const int8_t *pSrcB,
                      const uint32_t srcBLen,
                      int32_t *pRes);

void plp_correlate_valid_i8(const int8_t *pSrcA,
                            const uint32_t srcALen,
                            const int8_t *pSrcB,
                            const uint32_t srcBLen,
                            int32_t *pRes);

void plp_correlate_i8s_xpulpv2(const int8_t *pSrcA,
                               const uint32_t srcALen,
                               const int8_t *pSrcB,
                               const uint32_t srcBLen,
                               int32_t *pRes);

void plp_correlate_i8s_rv32im(const int8_t *pSrcA,
                              const uint32_t srcALen,
                              const int8_t *pSrcB,
                              const uint32_t srcBLen,
                              int32_t *pRes);


void plp_correlate_q32(const int32_t *pSrcA,
                       const uint32_t srcALen,
                       const int32_t *pSrcB,
                       const uint32_t srcBLen,
               const uint32_t fracBits,
                       int32_t *pRes);

void plp_correlate_q32s_rv32im(const int32_t *pSrcA,
                               const uint32_t srcALen,
                               const int32_t *pSrcB,
                               const uint32_t srcBLen,
                   const uint32_t fracBits,
                               int32_t *pRes);

void plp_correlate_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                const uint32_t srcALen,
                                const int32_t *__restrict__ pSrcB,
                                const uint32_t srcBLen,
                const uint32_t fracBits,
                                int32_t *__restrict__ pRes);

void plp_correlate_q16(const int16_t *pSrcA,
                       const uint32_t srcALen,
                       const int16_t *pSrcB,
                       const uint32_t srcBLen,
               const uint32_t fracBits,
                       int32_t *pRes);

void plp_correlate_q16s_xpulpv2(const int16_t *pSrcA,
                                const uint32_t srcALen,
                                const int16_t *pSrcB,
                                const uint32_t srcBLen,
                const uint32_t fracBits,
                                int32_t *pRes);

void plp_correlate_q16s_rv32im(const int16_t *pSrcA,
                               const uint32_t srcALen,
                               const int16_t *pSrcB,
                               const uint32_t srcBLen,
                   const uint32_t fracBits,
                               int32_t *pRes);

void plp_correlate_q8(const int8_t *pSrcA,
                      const uint32_t srcALen,
                      const int8_t *pSrcB,
                      const uint32_t srcBLen,
              const uint32_t fracBits,
                      int32_t *pRes);

void plp_correlate_valid_q8(const int8_t *pSrcA,
                            const uint32_t srcALen,
                            const int8_t *pSrcB,
                            const uint32_t srcBLen,
                const uint32_t fracBits,
                            int32_t *pRes);

void plp_correlate_q8s_xpulpv2(const int8_t *pSrcA,
                               const uint32_t srcALen,
                               const int8_t *pSrcB,
                               const uint32_t srcBLen,
                   const uint32_t fracBits,
                               int32_t *pRes);

void plp_correlate_q8s_rv32im(const int8_t *pSrcA,
                              const uint32_t srcALen,
                              const int8_t *pSrcB,
                              const uint32_t srcBLen,
                  const uint32_t fracBits,
                              int32_t *pRes);


void plp_conv_i32(const int32_t *pSrcA,
                  const uint32_t srcALen,
                  const int32_t *pSrcB,
                  const uint32_t srcBLen,
                  int32_t *pRes);

void plp_conv_valid_i32(const int32_t *pSrcA,
                        const uint32_t srcALen,
                        const int32_t *pSrcB,
                        const uint32_t srcBLen,
                        int32_t *pRes);

void plp_conv_i32s_rv32im(const int32_t *pSrcA,
                          const uint32_t srcALen,
                          const int32_t *pSrcB,
                          const uint32_t srcBLen,
                          int32_t *pRes);

void plp_conv_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                           const uint32_t srcALen,
                           const int32_t *__restrict__ pSrcB,
                           const uint32_t srcBLen,
                           int32_t *__restrict__ pRes);

void plp_conv_valid_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                 const uint32_t srcALen,
                                 const int32_t *__restrict__ pSrcB,
                                 const uint32_t srcBLen,
                                 int32_t *__restrict__ pRes);

void plp_conv_i16(const int16_t *pSrcA,
                  const uint32_t srcALen,
                  const int16_t *pSrcB,
                  const uint32_t srcBLen,
                  int32_t *pRes);

void plp_conv_valid_i16(const int16_t *pSrcA,
                        const uint32_t srcALen,
                        const int16_t *pSrcB,
                        const uint32_t srcBLen,
                        int32_t *pRes);

void plp_conv_valid_rep_i16(const int16_t *pSrcA,
                            const uint32_t srcALen,
                            const int16_t *pSrcB,
                            const uint32_t srcBLen,
                            int32_t *pRes);

void plp_conv_i16s_xpulpv2(const int16_t *pSrcA,
                           const uint32_t srcALen,
                           const int16_t *pSrcB,
                           const uint32_t srcBLen,
                           int32_t *pRes);

void plp_conv_valid_i16s_xpulpv2(const int16_t *pSrcA,
                                 const uint32_t srcALen,
                                 const int16_t *pSrcB,
                                 const uint32_t srcBLen,
                                 int32_t *pRes);

void plp_conv_valid_rep_i16s_xpulpv2(const int16_t *pSrcA,
                                     const uint32_t srcALen,
                                     const uint32_t srcAMem,
                                     const int16_t *pSrcB,
                                     const uint32_t srcBLen,
                                     int32_t *pRes);

void plp_conv_i16s_rv32im(const int16_t *pSrcA,
                          const uint32_t srcALen,
                          const int16_t *pSrcB,
                          const uint32_t srcBLen,
                          int32_t *pRes);

void plp_conv_i8(const int8_t *pSrcA,
                 const uint32_t srcALen,
                 const int8_t *pSrcB,
                 const uint32_t srcBLen,
                 int32_t *pRes);

void plp_conv_valid_i8(const int8_t *pSrcA,
                       const uint32_t srcALen,
                       const int8_t *pSrcB,
                       const uint32_t srcBLen,
                       int32_t *pRes);

void plp_conv_valid_rep_i8(const int8_t *pSrcA,
                           const uint32_t srcALen,
                           const int8_t *pSrcB,
                           const uint32_t srcBLen,
                           int32_t *pRes);

void plp_conv_i8s_xpulpv2(const int8_t *pSrcA,
                          const uint32_t srcALen,
                          const int8_t *pSrcB,
                          const uint32_t srcBLen,
                          int32_t *pRes);

void plp_conv_valid_i8s_xpulpv2(const int8_t *pSrcA,
                                const uint32_t srcALen,
                                const int8_t *pSrcB,
                                const uint32_t srcBLen,
                                int32_t *pRes);

void plp_conv_valid_rep_i8s_xpulpv2(const int8_t *pSrcA,
                                    const uint32_t srcALen,
                                    const uint32_t srcAMem,
                                    const int8_t *pSrcB,
                                    const uint32_t srcBLen,
                                    int32_t *pRes);

void plp_conv_i8s_rv32im(const int8_t *pSrcA,
                         const uint32_t srcALen,
                         const int8_t *pSrcB,
                         const uint32_t srcBLen,
                         int32_t *pRes);

void plp_conv_i32_parallel(const int32_t *pSrcA,
                           const uint32_t srcALen,
                           const int32_t *pSrcB,
                           const uint32_t srcBLen,
                           const uint8_t nPE,
                           int32_t *pRes);

void plp_conv_i32p_xpulpv2(void *task_args);

void plp_conv_i16_parallel(const int16_t *pSrcA,
                           const uint32_t srcALen,
                           const int16_t *pSrcB,
                           const uint32_t srcBLen,
                           const uint8_t nPE,
                           int32_t *pRes);
void plp_conv_i16p_xpulpv2(void *task_args);

void plp_conv_i8_parallel(const int8_t *pSrcA,
                          const uint32_t srcALen,
                          const int8_t *pSrcB,
                          const uint32_t srcBLen,
                          const uint8_t nPE,
                          int32_t *pRes);
void plp_conv_i8p_xpulpv2(void *task_args);

void plp_conv_parallel_OLA(uint32_t nPE,
                           uint32_t srcALen,
                           uint32_t srcBLen,
                           int32_t *resultsBuffer);

void plp_conv_parallel_OLA_kernel(void *task_args);

void plp_mat_mult_i32(const int32_t *__restrict__ pSrcA,
                      const int32_t *__restrict__ pSrcB,
                      uint32_t M,
                      uint32_t N,
                      uint32_t O,
                      int32_t *__restrict__ pDstC);

void plp_mat_mult_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t O,
                              int32_t *__restrict__ pDstC);

void plp_mat_mult_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                               const int32_t *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               int32_t *__restrict__ pDstC);

void plp_mat_mult_i16(const int16_t *__restrict__ pSrcA,
                      const int16_t *__restrict__ pSrcB,
                      uint32_t M,
                      uint32_t N,
                      uint32_t O,
                      int32_t *__restrict__ pDstC);

void plp_mat_mult_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t O,
                              int32_t *__restrict__ pDstC);

void plp_mat_mult_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                               const int16_t *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               int32_t *__restrict__ pDstC);

void plp_mat_mult_i8(const int8_t *__restrict__ pSrcA,
                     const int8_t *__restrict__ pSrcB,
                     uint32_t M,
                     uint32_t N,
                     uint32_t O,
                     int32_t *__restrict__ pDstC);

void plp_mat_mult_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             uint32_t O,
                             int32_t *__restrict__ pDstC);

void plp_mat_mult_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                              const int8_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t O,
                              int32_t *__restrict__ pDstC);

void plp_mat_mult_i32_parallel(const int32_t *__restrict__ pSrcA,
                               const int32_t *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               uint32_t nPE,
                               int32_t *__restrict__ pDstC);

void plp_mat_mult_i32p_xpulpv2(void *args);

void plp_mat_mult_i16_parallel(const int16_t *__restrict__ pSrcA,
                               const int16_t *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               uint32_t nPE,
                               int32_t *__restrict__ pDstC);

void plp_mat_mult_i16p_xpulpv2(void *args);

void plp_mat_mult_i8_parallel(const int8_t *__restrict__ pSrcA,
                              const int8_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t O,
                              uint32_t nPE,
                              int32_t *__restrict__ pDstC);

void plp_mat_mult_f32(const float *__restrict__ pSrcA,
                      const float *__restrict__ pSrcB,
                      uint32_t M,
                      uint32_t N,
                      uint32_t O,
                      float *__restrict__ pDstC);

void plp_mat_mult_f32s_xpulpv2(const float *__restrict__ pSrcA,
                               const float *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               float *__restrict__ pDstC);

void plp_mat_mult_f32_parallel(const float *__restrict__ pSrcA,
                               const float *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               uint32_t nPE,
                               float *__restrict__ pDstC);

void plp_mat_mult_f32p_xpulpv2(void *args);

void plp_mat_mult_i8p_xpulpv2(void *args);

void plp_mat_mult_q32(const int32_t *__restrict__ pSrcA,
                      const int32_t *__restrict__ pSrcB,
                      uint32_t M,
                      uint32_t N,
                      uint32_t O,
                      uint32_t shift,
                      int32_t *__restrict__ pDstC);

void plp_mat_mult_q32_parallel(const int32_t *__restrict__ pSrcA,
                               const int32_t *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               uint32_t shift,
                               uint32_t nPE,
                               int32_t *__restrict__ pDstC);

void plp_mat_mult_q32s_rv32im(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t O,
                              uint32_t shift,
                              int32_t *__restrict__ pDstC);

void plp_mat_mult_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                               const int32_t *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               uint32_t shift,
                               int32_t *__restrict__ pDstC);

void plp_mat_mult_q32p_xpulpv2(void *args);

void plp_mat_mult_q16(const int16_t *__restrict__ pSrcA,
                      const int16_t *__restrict__ pSrcB,
                      uint32_t M,
                      uint32_t N,
                      uint32_t O,
                      uint32_t shift,
                      int16_t *__restrict__ pDstC);

void plp_mat_mult_q16_parallel(const int16_t *__restrict__ pSrcA,
                               const int16_t *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               uint32_t shift,
                               uint32_t nPE,
                               int16_t *__restrict__ pDstC);

void plp_mat_mult_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t O,
                              uint32_t shift,
                              int16_t *__restrict__ pDstC);

void plp_mat_mult_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                               const int16_t *__restrict__ pSrcB,
                               uint32_t M,
                               uint32_t N,
                               uint32_t O,
                               uint32_t shift,
                               int16_t *__restrict__ pDstC);

void plp_mat_mult_q16p_xpulpv2(void *args);

void plp_mat_mult_q8(const int8_t *__restrict__ pSrcA,
                     const int8_t *__restrict__ pSrcB,
                     uint32_t M,
                     uint32_t N,
                     uint32_t O,
                     uint32_t shift,
                     int8_t *__restrict__ pDstC);

void plp_mat_mult_q8_parallel(const int8_t *__restrict__ pSrcA,
                              const int8_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t O,
                              uint32_t shift,
                              uint32_t nPE,
                              int8_t *__restrict__ pDstC);

void plp_mat_mult_q8s_rv32im(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             uint32_t O,
                             uint32_t shift,
                             int8_t *__restrict__ pDstC);

void plp_mat_mult_q8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                              const int8_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t O,
                              uint32_t shift,
                              int8_t *__restrict__ pDstC);

void plp_mat_mult_q8p_xpulpv2(void *args);

void plp_mat_mult_cmplx_i32(const int32_t *__restrict__ pSrcA,
                            const int32_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                                    const int32_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i32_parallel(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t nPE,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i32p_xpulpv2(void *args);

void plp_mat_mult_cmplx_i16(const int16_t *__restrict__ pSrcA,
                            const int16_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                                    const int16_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i16_parallel(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t nPE,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i16p_xpulpv2(void *args);

void plp_mat_mult_cmplx_i8(const int8_t *__restrict__ pSrcA,
                           const int8_t *__restrict__ pSrcB,
                           uint32_t M,
                           uint32_t N,
                           uint32_t O,
                           int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                                   const int8_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i8_parallel(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t nPE,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_i8p_xpulpv2(void *args);

void plp_mat_mult_cmplx_f32(const float *__restrict__ pSrcA,
                            const float *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            float *__restrict__ pDstC);

void plp_mat_mult_cmplx_f32s_xpulpv2(const float *__restrict__ pSrcA,
                                     const float *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     float *__restrict__ pDstC);

void plp_mat_mult_cmplx_f32_parallel(const float *__restrict__ pSrcA,
                                     const float *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t nPE,
                                     float *__restrict__ pDstC);

void plp_mat_mult_cmplx_f32p_xpulpv2(void *args);

void plp_mat_mult_cmplx_q32(const int32_t *__restrict__ pSrcA,
                            const int32_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            uint32_t shift,
                            int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q32s_rv32im(const int32_t *__restrict__ pSrcA,
                                    const int32_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t shift,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t shift,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q32_parallel(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t shift,
                                     uint32_t nPE,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q32p_xpulpv2(void *args);

void plp_mat_mult_cmplx_q16(const int16_t *__restrict__ pSrcA,
                            const int16_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            uint32_t shift,
                            int16_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                                    const int16_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t shift,
                                    int16_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t shift,
                                     int16_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q16_parallel(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t shift,
                                     uint32_t nPE,
                                     int16_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q16p_xpulpv2(void *args);

void plp_mat_mult_cmplx_q8(const int8_t *__restrict__ pSrcA,
                           const int8_t *__restrict__ pSrcB,
                           uint32_t M,
                           uint32_t N,
                           uint32_t O,
                           uint32_t shift,
                           int8_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q8s_rv32im(const int8_t *__restrict__ pSrcA,
                                   const int8_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t shift,
                                   int8_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t shift,
                                    int8_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q8_parallel(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t shift,
                                    uint32_t nPE,
                                    int8_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_q8p_xpulpv2(void *args);

void plp_mat_mult_trans_i32(const int32_t *__restrict__ pSrcA,
                            const int32_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                                    const int32_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i16(const int16_t *__restrict__ pSrcA,
                            const int16_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                                    const int16_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i8(const int8_t *__restrict__ pSrcA,
                           const int8_t *__restrict__ pSrcB,
                           uint32_t M,
                           uint32_t N,
                           uint32_t O,
                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                                   const int8_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i32_parallel(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t nPE,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i32p_xpulpv2(void *args);

void plp_mat_mult_trans_i16_parallel(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t nPE,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i16p_xpulpv2(void *args);

void plp_mat_mult_trans_i8_parallel(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t nPE,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_i8p_xpulpv2(void *args);

void plp_mat_mult_trans_q32(const int32_t *__restrict__ pSrcA,
                            const int32_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            uint32_t shift,
                            int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_q32_parallel(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t shift,
                                     uint32_t nPE,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_q32s_rv32im(const int32_t *__restrict__ pSrcA,
                                    const int32_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t shift,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t shift,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_q32p_xpulpv2(void *args);

void plp_mat_mult_trans_q16(const int16_t *__restrict__ pSrcA,
                            const int16_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            uint32_t shift,
                            int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_q16_parallel(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t shift,
                                     uint32_t nPE,
                                     int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                                    const int16_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t shift,
                                    int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t shift,
                                     int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_q16p_xpulpv2(void *args);

void plp_mat_mult_trans_q8(const int8_t *__restrict__ pSrcA,
                           const int8_t *__restrict__ pSrcB,
                           uint32_t M,
                           uint32_t N,
                           uint32_t O,
                           uint32_t shift,
                           int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_q8_parallel(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t shift,
                                    uint32_t nPE,
                                    int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_q8s_rv32im(const int8_t *__restrict__ pSrcA,
                                   const int8_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t shift,
                                   int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_q8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t shift,
                                    int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_q8p_xpulpv2(void *args);

void plp_mat_mult_trans_f32(const float *__restrict__ pSrcA,
                            const float *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            float *__restrict__ pDstC);

void plp_mat_mult_trans_f32s_xpulpv2(const float *__restrict__ pSrcA,
                                     const float *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     float *__restrict__ pDstC);

void plp_mat_mult_trans_f32_parallel(const float *__restrict__ pSrcA,
                                     const float *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t nPE,
                                     float *__restrict__ pDstC);

void plp_mat_mult_trans_f32p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_i32(const int32_t *__restrict__ pSrcA,
                                  const int32_t *__restrict__ pSrcB,
                                  uint32_t M,
                                  uint32_t N,
                                  uint32_t O,
                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                                          const int32_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                           const int32_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i32_parallel(const int32_t *__restrict__ pSrcA,
                                           const int32_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t nPE,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i32p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_i16(const int16_t *__restrict__ pSrcA,
                                  const int16_t *__restrict__ pSrcB,
                                  uint32_t M,
                                  uint32_t N,
                                  uint32_t O,
                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                                          const int16_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                           const int16_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i16_parallel(const int16_t *__restrict__ pSrcA,
                                           const int16_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t nPE,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i16p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_i8(const int8_t *__restrict__ pSrcA,
                                 const int8_t *__restrict__ pSrcB,
                                 uint32_t M,
                                 uint32_t N,
                                 uint32_t O,
                                 int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                                         const int8_t *__restrict__ pSrcB,
                                         uint32_t M,
                                         uint32_t N,
                                         uint32_t O,
                                         int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                          const int8_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i8_parallel(const int8_t *__restrict__ pSrcA,
                                          const int8_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          uint32_t nPE,
                                          int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_i8p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_f32(const float *__restrict__ pSrcA,
                                  const float *__restrict__ pSrcB,
                                  uint32_t M,
                                  uint32_t N,
                                  uint32_t O,
                                  float *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_f32s_xpulpv2(const float *__restrict__ pSrcA,
                                           const float *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           float *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_f32_parallel(const float *__restrict__ pSrcA,
                                           const float *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t nPE,
                                           float *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_f32p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_q32(const int32_t *__restrict__ pSrcA,
                                  const int32_t *__restrict__ pSrcB,
                                  uint32_t M,
                                  uint32_t N,
                                  uint32_t O,
                                  uint32_t shift,
                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q32s_rv32im(const int32_t *__restrict__ pSrcA,
                                          const int32_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          uint32_t shift,
                                          int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                           const int32_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t shift,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q32_parallel(const int32_t *__restrict__ pSrcA,
                                           const int32_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t shift,
                                           uint32_t nPE,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q32p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_q16(const int16_t *__restrict__ pSrcA,
                                  const int16_t *__restrict__ pSrcB,
                                  uint32_t M,
                                  uint32_t N,
                                  uint32_t O,
                                  uint32_t shift,
                                  int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                                          const int16_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          uint32_t shift,
                                          int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                           const int16_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t shift,
                                           int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q16_parallel(const int16_t *__restrict__ pSrcA,
                                           const int16_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t shift,
                                           uint32_t nPE,
                                           int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q16p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_q8(const int8_t *__restrict__ pSrcA,
                                 const int8_t *__restrict__ pSrcB,
                                 uint32_t M,
                                 uint32_t N,
                                 uint32_t O,
                                 uint32_t shift,
                                 int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q8s_rv32im(const int8_t *__restrict__ pSrcA,
                                         const int8_t *__restrict__ pSrcB,
                                         uint32_t M,
                                         uint32_t N,
                                         uint32_t O,
                                         uint32_t shift,
                                         int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                          const int8_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          uint32_t shift,
                                          int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q8_parallel(const int8_t *__restrict__ pSrcA,
                                          const int8_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          uint32_t shift,
                                          uint32_t nPE,
                                          int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_q8p_xpulpv2(void *args);

void plp_cmplx_mag_f32(const float32_t *pSrc,
                       float32_t *pRes,
                       uint32_t numSamples);

void plp_cmplx_mag_f32s_xpulpv2(const float32_t *pSrc,
                                float32_t *pRes,
                                uint32_t numSamples);

void plp_cmplx_mag_q32(const int32_t *pSrc,
                       const uint32_t fracBits,
                       int32_t *pRes,
                       uint32_t numSamples);

void plp_cmplx_mag_q32s_rv32im(const int32_t *pSrc,
                               const uint32_t fracBits,
                               int32_t *pRes,
                               uint32_t numSamples);

void plp_cmplx_mag_q32s_xpulpv2(const int32_t *pSrc,
                                const uint32_t fracBits,
                                int32_t *pRes,
                                uint32_t numSamples);

void plp_cmplx_mag_q8(const int8_t *pSrc,
                       const uint32_t fracBits,
                       int8_t *pRes,
                       uint32_t numSamples);

void plp_cmplx_mag_q8s_rv32im(const int8_t *pSrc,
                               const uint32_t fracBits,
                               int8_t *pRes,
                               uint32_t numSamples);

void plp_cmplx_mag_q8s_xpulpv2(const int8_t *pSrc,
                                const uint32_t fracBits,
                                int8_t *pRes,
                                uint32_t numSamples);

void plp_cmplx_mag_i16(const int16_t *pSrc,
                       int16_t *pRes,
                       uint32_t numSamples);

void plp_cmplx_mag_i16s_rv32im(const int16_t *pSrc,
                               int16_t *pRes,
                               uint32_t numSamples);

void plp_cmplx_mag_i16s_xpulpv2(const int16_t *pSrc,
                                int16_t *pRes,
                                uint32_t numSamples);

void plp_cmplx_mag_i32(const int32_t *pSrc,
                       int32_t *pRes,
                       uint32_t numSamples);

void plp_cmplx_mag_i32s_rv32im(const int32_t *pSrc,
                               int32_t *pRes,
                               uint32_t numSamples);

void plp_cmplx_mag_i32s_xpulpv2(const int32_t *pSrc,
                                int32_t *pRes,
                                uint32_t numSamples);

void plp_cmplx_mag_i8(const int8_t *pSrc,
                      int8_t *pRes,
                      uint32_t numSamples);

void plp_cmplx_mag_i8s_rv32im(const int8_t *pSrc,
                              int8_t *pRes,
                              uint32_t numSamples);

void plp_cmplx_mag_i8s_xpulpv2(const int8_t *pSrc,
                               int8_t *pRes,
                               uint32_t numSamples);

void plp_cmplx_mag_q16(const int16_t *pSrc,
                       const uint32_t fracBits,
                       int16_t *pRes,
                       uint32_t numSamples);

void plp_cmplx_mag_q16s_rv32im(const int16_t *pSrc,
                               const uint32_t fracBits,
                               int16_t *pRes,
                               uint32_t numSamples);

void plp_cmplx_mag_q16s_xpulpv2(const int16_t *pSrc,
                                const uint32_t fracBits,
                                int16_t *pRes,
                                uint32_t numSamples);

void plp_bitreversal_16s_rv32im(uint16_t *pSrc,
                                const uint16_t bitRevLen,
                                const uint16_t *pBitRevTab);

void plp_bitreversal_16s_xpulpv2(uint16_t *pSrc,
                                 const uint16_t bitRevLen,
                                 const uint16_t *pBitRevTab);

void plp_bitreversal_16p_xpulpv2(uint16_t *pSrc,
                                 const uint16_t bitRevLen,
                                 const uint16_t *pBitRevTab,
                                 uint32_t nPE);

void plp_cfft_q16(const plp_cfft_instance_q16 *S,
                  int16_t *p1,
                  uint8_t ifftFlag,
                  uint8_t bitReverseFlag,
                  uint32_t deciPoint);

void plp_cfft_q16_parallel(const plp_cfft_instance_q16 *S,
                           int16_t *p1,
                           uint8_t ifftFlag,
                           uint8_t bitReverseFlag,
                           uint32_t deciPoint,
                           uint32_t nPE);

void plp_cfft_q16s_rv32im(const plp_cfft_instance_q16 *S,
                          int16_t *p1,
                          uint8_t ifftFlag,
                          uint8_t bitReverseFlag,
                          uint32_t deciPoint);

void plp_cfft_q16s_xpulpv2(const plp_cfft_instance_q16 *S,
                           int16_t *p1,
                           uint8_t ifftFlag,
                           uint8_t bitReverseFlag,
                           uint32_t deciPoint);

void plp_cfft_q16p_xpulpv2(void *args);

void plp_bitreversal_32s_rv32im(uint32_t *pSrc, const uint16_t bitRevLen, const uint16_t *pBitRevTab);

void plp_bitreversal_32s_xpulpv2(uint32_t *pSrc, const uint16_t bitRevLen, const uint16_t *pBitRevTab);

void plp_bitreversal_32p_xpulpv2(uint32_t *pSrc, const uint16_t bitRevLen, const uint16_t *pBitRevTab, uint32_t nPE);

void plp_cfft_q32(const plp_cfft_instance_q32 *S,
                      int32_t *p1,
                      uint8_t ifftFlag,
                      uint8_t bitReverseFlag,
                      uint32_t fracBits);

void plp_cfft_q32_parallel( const plp_cfft_instance_q32 *S,
                            int32_t *p1,
                            uint8_t ifftFlag,
                            uint8_t bitReverseFlag,
                            uint32_t fracBits,
                            uint32_t nPE );

void plp_cfft_q32s_rv32im(const plp_cfft_instance_q32 *S,
                      int32_t *p1,
                      uint8_t ifftFlag,
                      uint8_t bitReverseFlag,
                      uint32_t fracBits);

void plp_cfft_q32s_xpulpv2(const plp_cfft_instance_q32 *S,
                      int32_t *p1,
                      uint8_t ifftFlag,
                      uint8_t bitReverseFlag,
                      uint32_t fracBits);

void plp_cfft_q32p_xpulpv2(void *args);

void plp_rfft_f32(const plp_fft_instance_f32 *S,
                  const float32_t *__restrict__ pSrc,
                  float32_t *__restrict__ pDst);

void plp_rfft_f32_parallel(const plp_fft_instance_f32 *S,
                           const float32_t *__restrict__ pSrc,
                           const uint32_t nPE,
                           float32_t *__restrict__ pDst);

void plp_rfft_f32s_xpulpv2(const plp_fft_instance_f32 *S,
                          const float32_t *__restrict__ pSrc,
                          float32_t *__restrict__ pDst);

void plp_rfft_f32p_xpulpv2(void *arg);





void plp_rfftfast_f32( const plp_fft_fast_instance_f32 *S,
                        const float32_t *__restrict__ pSrc,
                        float32_t *__restrict__ pDst);

void plp_rfftfast_f32_parallel( const plp_fft_fast_instance_f32 *S,
                                 float32_t *__restrict__ pSrc,
                                 float32_t *__restrict__ pDst,
                                 const uint32_t nPE);

void plp_rfftfast_f32s_xpulpv2( const plp_fft_fast_instance_f32 *S,
                                 float32_t *pSrc,
                                 float32_t *pDst);

void plp_rfftfast_f32p_xpulpv2( void *arg );

void plp_cfft_f32(  const plp_cfft_instance_f32 *S,
                    float32_t *pSrc,
                    uint8_t ifftFlag,
                    uint8_t bitReverseFlag);

void plp_cfft_f32_parallel( const plp_cfft_instance_f32 *S,
                            const float32_t *pSrc,
                            uint8_t ifftFlag,
                            uint8_t bitReverseFlag,
                            const uint32_t nPE);

void plp_cfft_f32s_xpulpv2( const plp_cfft_instance_f32 *S,
                            const float32_t *pSrc,
                            uint8_t ifftFlag,
                            uint8_t bitReverseFlag);

void plp_cfft_f32p_xpulpv2(void *arg);

void plp_dct2_f32(const plp_fft_instance_f32 *S,
                  const Complex_type_f32 *pShift,
                  const uint8_t orthoNorm,
                  const float32_t *__restrict__ pSrc,
                  float32_t *__restrict__ pBuf,
                  float32_t *__restrict__ pDst);

void plp_dct2_f32_parallel(const plp_fft_instance_f32 *S,
                       const Complex_type_f32 *pShift,
                       const uint8_t orthoNorm,
                       const float32_t *__restrict__ pSrc,
               const uint32_t nPE,
                       float32_t *__restrict__ pBuf,
                       float32_t *__restrict__ pDst);

void plp_mfcc_f32(const plp_fft_instance_f32 *SFFT,
                  const plp_fft_instance_f32 *SDCT,
                  const Complex_type_f32 *pShift,
                  const plp_triangular_filter_f32 *filterBank,
          const float32_t *window,
          const uint8_t *orthoNorm,
                  const float32_t *__restrict__ pSrc,
                  float32_t *__restrict__ pDst);

void plp_mfcc_f32_parallel(const plp_fft_instance_f32 *SFFT,
                       const plp_fft_instance_f32 *SDCT,
                       const Complex_type_f32 *pShift,
                       const plp_triangular_filter_f32 *filterBank,
               const float32_t *window,
               const uint8_t *orthoNorm,
                       const float32_t *__restrict__ pSrc,
               const uint32_t nPE,
                       float32_t *__restrict__ pDst);

void plp_dwt_f32(const float32_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_f32 wavelet,
                  plp_dwt_extension_mode mode,
                  float32_t *__restrict__ pDstA,
                  float32_t *__restrict__ pDstD);


void plp_dwt_q32(const int32_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_q32 wavelet,
                  plp_dwt_extension_mode mode,
                  int32_t *__restrict__ pDstA,
                  int32_t *__restrict__ pDstD);


void plp_dwt_q16(const int16_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_q16 wavelet,
                  plp_dwt_extension_mode mode,
                  int16_t *__restrict__ pDstA,
                  int16_t *__restrict__ pDstD);

void plp_dwt_q8(const int8_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_q8 wavelet,
                  plp_dwt_extension_mode mode,
                  int8_t *__restrict__ pDstA,
                  int8_t *__restrict__ pDstD);


void plp_dwt_dec_f32(const float32_t *__restrict__ pSrc,
                     uint32_t length,
                     const plp_dwt_wavelet_f32 wavelet,
                     plp_dwt_extension_mode mode,
                     uint32_t level,
                     float32_t *__restrict__ pTmp,
                     float32_t *__restrict__ pDst);

void plp_dwt_dec_f32_parallel(const float32_t *__restrict__ pSrc,
                     uint32_t length,
                     const plp_dwt_wavelet_f32 wavelet,
                     plp_dwt_extension_mode mode,
                     uint32_t level,
                     uint32_t nPE,
                     float32_t *__restrict__ pTemp,
                     float32_t *__restrict__ pDst);

void plp_dwt_f32s_xpulpv2(const float32_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_f32 wavelet,
                  plp_dwt_extension_mode mode,
                  float32_t *__restrict__ pDstA,
                  float32_t *__restrict__ pDstD);

void plp_dwt_haar_f32s_xpulpv2(const float32_t *__restrict__ pSrc,
                         uint32_t length,
                         plp_dwt_extension_mode mode,
                         float32_t *__restrict__ pDstA,
                         float32_t *__restrict__ pDstD);




void plp_dwt_q32s_xpulpv2(const int32_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_q32 wavelet,
                  plp_dwt_extension_mode mode,
                  int32_t *__restrict__ pDstA,
                  int32_t *__restrict__ pDstD);

void plp_dwt_haar_q32s_xpulpv2(const int32_t *__restrict__ pSrc,
                         uint32_t length,
                         plp_dwt_extension_mode mode,
                         int32_t *__restrict__ pDstA,
                         int32_t *__restrict__ pDstD);



void plp_dwt_q16s_xpulpv2(const int16_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_q16 wavelet,
                  plp_dwt_extension_mode mode,
                  int16_t *__restrict__ pDstA,
                  int16_t *__restrict__ pDstD);

void plp_dwt_haar_q16s_xpulpv2(const int16_t *__restrict__ pSrc,
                         uint32_t length,
                         plp_dwt_extension_mode mode,
                         int16_t *__restrict__ pDstA,
                         int16_t *__restrict__ pDstD);


void plp_dwt_q8s_xpulpv2(const int8_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_q8 wavelet,
                  plp_dwt_extension_mode mode,
                  int8_t *__restrict__ pDstA,
                  int8_t *__restrict__ pDstD);

void plp_dwt_haar_q8s_xpulpv2(const int8_t *__restrict__ pSrc,
                         uint32_t length,
                         plp_dwt_extension_mode mode,
                         int8_t *__restrict__ pDstA,
                         int8_t *__restrict__ pDstD);


void plp_dwt_f32_parallel(const float32_t *__restrict__ pSrc,
                 uint32_t length,
                 const plp_dwt_wavelet_f32 wavelet,
                 plp_dwt_extension_mode mode,
                 uint32_t nPE,
                 float32_t *__restrict__ pDstA,
                 float32_t *__restrict__ pDstD);


void plp_dwt_q8_parallel(const int8_t *__restrict__ pSrc,
                 uint32_t length,
                 const plp_dwt_wavelet_q8 wavelet,
                 plp_dwt_extension_mode mode,
                 uint32_t nPE,
                 int8_t *__restrict__ pDstA,
                 int8_t *__restrict__ pDstD);


void plp_dwt_q16_parallel(const int16_t *__restrict__ pSrc,
                 uint32_t length,
                 const plp_dwt_wavelet_q16 wavelet,
                 plp_dwt_extension_mode mode,
                 uint32_t nPE,
                 int16_t *__restrict__ pDstA,
                 int16_t *__restrict__ pDstD);

void plp_dwt_q32_parallel(const int32_t *__restrict__ pSrc,
                 uint32_t length,
                 const plp_dwt_wavelet_q32 wavelet,
                 plp_dwt_extension_mode mode,
                 uint32_t nPE,
                 int32_t *__restrict__ pDstA,
                 int32_t *__restrict__ pDstD);


void plp_dwt_f32p_xpulpv2(void *args);


void plp_dwt_haar_f32p_xpulpv2(void *args);


void plp_dwt_q8p_xpulpv2(void *args);



void plp_dwt_haar_q8p_xpulpv2(void *args);



void plp_dwt_q16p_xpulpv2(void *args);


void plp_dwt_haar_q16p_xpulpv2(void *args);

void plp_dwt_q32p_xpulpv2(void *arg);

void plp_dwt_haar_q32p_xpulpv2(void *args);





void plp_dwt_q32s_rv32im(const int32_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_q32 wavelet,
                  plp_dwt_extension_mode mode,
                  int32_t *__restrict__ pDstA,
                  int32_t *__restrict__ pDstD);

void plp_dwt_haar_q32s_rv32im(const int32_t *__restrict__ pSrc,
                         uint32_t length,
                         plp_dwt_extension_mode mode,
                         int32_t *__restrict__ pDstA,
                         int32_t *__restrict__ pDstD);



void plp_dwt_q16s_rv32im(const int16_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_q16 wavelet,
                  plp_dwt_extension_mode mode,
                  int16_t *__restrict__ pDstA,
                  int16_t *__restrict__ pDstD);

void plp_dwt_haar_q16s_rv32im(const int16_t *__restrict__ pSrc,
                         uint32_t length,
                         plp_dwt_extension_mode mode,
                         int16_t *__restrict__ pDstA,
                         int16_t *__restrict__ pDstD);


void plp_dwt_q8s_rv32im(const int8_t *__restrict__ pSrc,
                  uint32_t length,
                  const plp_dwt_wavelet_q8 wavelet,
                  plp_dwt_extension_mode mode,
                  int8_t *__restrict__ pDstA,
                  int8_t *__restrict__ pDstD);

void plp_dwt_haar_q8s_rv32im(const int8_t *__restrict__ pSrc,
                         uint32_t length,
                         plp_dwt_extension_mode mode,
                         int8_t *__restrict__ pDstA,
                         int8_t *__restrict__ pDstD);


void plp_mat_add_i32(const int32_t *__restrict__ pSrcA,
                     const int32_t *__restrict__ pSrcB,
                     uint32_t M,
                     uint32_t N,
                     int32_t *__restrict__ pDst);

void plp_mat_add_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                             const int32_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             int32_t *__restrict__ pDst);

void plp_mat_add_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              int32_t *__restrict__ pDst);

void plp_mat_add_i32_parallel(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t nPE,
                              int32_t *__restrict__ pDst);

void plp_mat_add_i32p_xpulpv2(void *args);

void plp_mat_add_i16(const int16_t *__restrict__ pSrcA,
                     const int16_t *__restrict__ pSrcB,
                     uint32_t M,
                     uint32_t N,
                     int16_t *__restrict__ pDst);

void plp_mat_add_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                             const int16_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             int16_t *__restrict__ pDst);

void plp_mat_add_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              int16_t *__restrict__ pDst);

void plp_mat_add_i16_parallel(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t nPE,
                              int16_t *__restrict__ pDst);

void plp_mat_add_i16p_xpulpv2(void *args);

void plp_mat_add_i8(const int8_t *__restrict__ pSrcA,
                    const int8_t *__restrict__ pSrcB,
                    uint32_t M,
                    uint32_t N,
                    int8_t *__restrict__ pDst);

void plp_mat_add_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                            const int8_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            int8_t *__restrict__ pDst);

void plp_mat_add_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             int8_t *__restrict__ pDst);

void plp_mat_add_i8_parallel(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             uint32_t nPE,
                             int8_t *__restrict__ pDst);

void plp_mat_add_i8p_xpulpv2(void *args);

void plp_mat_add_f32(const float *__restrict__ pSrcA,
                     const float *__restrict__ pSrcB,
                     uint32_t M,
                     uint32_t N,
                     float *__restrict__ pDst);

void plp_mat_add_f32s_xpulpv2(const float *__restrict__ pSrcA,
                              const float *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              float *__restrict__ pDst);

void plp_mat_add_f32_parallel(const float *__restrict__ pSrcA,
                              const float *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t nPE,
                              float *__restrict__ pDst);

void plp_mat_add_f32p_xpulpv2(void *args);

void plp_mat_sub_i32(const int32_t *__restrict__ pSrcA,
                     const int32_t *__restrict__ pSrcB,
                     uint32_t M,
                     uint32_t N,
                     int32_t *__restrict__ pDst);

void plp_mat_sub_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                             const int32_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             int32_t *__restrict__ pDst);

void plp_mat_sub_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              int32_t *__restrict__ pDst);

void plp_mat_sub_i32_parallel(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t nPE,
                              int32_t *__restrict__ pDst);

void plp_mat_sub_i32p_xpulpv2(void *args);

void plp_mat_sub_i16(const int16_t *__restrict__ pSrcA,
                     const int16_t *__restrict__ pSrcB,
                     uint32_t M,
                     uint32_t N,
                     int16_t *__restrict__ pDst);

void plp_mat_sub_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                             const int16_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             int16_t *__restrict__ pDst);

void plp_mat_sub_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              int16_t *__restrict__ pDst);

void plp_mat_sub_i16_parallel(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t nPE,
                              int16_t *__restrict__ pDst);

void plp_mat_sub_i16p_xpulpv2(void *args);

void plp_mat_sub_i8(const int8_t *__restrict__ pSrcA,
                    const int8_t *__restrict__ pSrcB,
                    uint32_t M,
                    uint32_t N,
                    int8_t *__restrict__ pDst);

void plp_mat_sub_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                            const int8_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            int8_t *__restrict__ pDst);

void plp_mat_sub_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             int8_t *__restrict__ pDst);

void plp_mat_sub_i8_parallel(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             uint32_t nPE,
                             int8_t *__restrict__ pDst);

void plp_mat_sub_i8p_xpulpv2(void *args);

void plp_mat_sub_f32(const float *__restrict__ pSrcA,
                     const float *__restrict__ pSrcB,
                     uint32_t M,
                     uint32_t N,
                     float *__restrict__ pDst);

void plp_mat_sub_f32s_xpulpv2(const float *__restrict__ pSrcA,
                              const float *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              float *__restrict__ pDst);

void plp_mat_sub_f32_parallel(const float *__restrict__ pSrcA,
                              const float *__restrict__ pSrcB,
                              uint32_t M,
                              uint32_t N,
                              uint32_t nPE,
                              float *__restrict__ pDst);

void plp_mat_sub_f32p_xpulpv2(void *args);

void plp_mat_scale_i32(const int32_t *__restrict__ pSrc,
                       uint32_t M,
                       uint32_t N,
                       int32_t scaleFactor,
                       int32_t shift,
                       int32_t *__restrict__ pDst);

void plp_mat_scale_i32s_rv32im(const int32_t *__restrict__ pSrc,
                               uint32_t M,
                               uint32_t N,
                               int32_t scaleFactor,
                               int32_t shift,
                               int32_t *__restrict__ pDst);

void plp_mat_scale_i32s_xpulpv2(const int32_t *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                int32_t scaleFactor,
                                int32_t shift,
                                int32_t *__restrict__ pDst);

void plp_mat_scale_i32_parallel(const int32_t *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                int32_t scaleFactor,
                                int32_t shift,
                                uint32_t nPE,
                                int32_t *__restrict__ pDst);

void plp_mat_scale_i32p_xpulpv2(void *args);

void plp_mat_scale_i16(const int16_t *__restrict__ pSrc,
                       uint32_t M,
                       uint32_t N,
                       int16_t scaleFactor,
                       int32_t shift,
                       int16_t *__restrict__ pDst);

void plp_mat_scale_i16s_rv32im(const int16_t *__restrict__ pSrc,
                               uint32_t M,
                               uint32_t N,
                               int16_t scaleFactor,
                               int32_t shift,
                               int16_t *__restrict__ pDst);

void plp_mat_scale_i16s_xpulpv2(const int16_t *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                int16_t scaleFactor,
                                int32_t shift,
                                int16_t *__restrict__ pDst);

void plp_mat_scale_i16_parallel(const int16_t *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                int16_t scaleFactor,
                                int32_t shift,
                                uint32_t nPE,
                                int16_t *__restrict__ pDst);

void plp_mat_scale_i16p_xpulpv2(void *args);

void plp_mat_scale_i8(const int8_t *__restrict__ pSrc,
                      uint32_t M,
                      uint32_t N,
                      int8_t scaleFactor,
                      int32_t shift,
                      int8_t *__restrict__ pDst);

void plp_mat_scale_i8s_rv32im(const int8_t *__restrict__ pSrc,
                              uint32_t M,
                              uint32_t N,
                              int8_t scaleFactor,
                              int32_t shift,
                              int8_t *__restrict__ pDst);

void plp_mat_scale_i8s_xpulpv2(const int8_t *__restrict__ pSrc,
                               uint32_t M,
                               uint32_t N,
                               int8_t scaleFactor,
                               int32_t shift,
                               int8_t *__restrict__ pDst);

void plp_mat_scale_i8_parallel(const int8_t *__restrict__ pSrc,
                               uint32_t M,
                               uint32_t N,
                               int8_t scaleFactor,
                               int32_t shift,
                               uint32_t nPE,
                               int8_t *__restrict__ pDst);

void plp_mat_scale_i8p_xpulpv2(void *args);

void plp_mat_scale_f32(const float *__restrict__ pSrc,
                       uint32_t M,
                       uint32_t N,
                       float scaleFactor,
                       float *__restrict__ pDst);

void plp_mat_scale_f32s_xpulpv2(const float *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                float scaleFactor,
                                float *__restrict__ pDst);

void plp_mat_scale_f32_parallel(const float *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                float scaleFactor,
                                uint32_t nPE,
                                float *__restrict__ pDst);

void plp_mat_scale_f32p_xpulpv2(void *args);

void plp_mat_trans_i32(const int32_t *__restrict__ pSrc,
                       uint32_t M,
                       uint32_t N,
                       int32_t *__restrict__ pDst);

void plp_mat_trans_i32s_rv32im(const int32_t *__restrict__ pSrc,
                               uint32_t M,
                               uint32_t N,
                               int32_t *__restrict__ pDst);

void plp_mat_trans_i32s_xpulpv2(const int32_t *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                int32_t *__restrict__ pDst);

void plp_mat_trans_i32_parallel(const int32_t *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                uint32_t nPE,
                                int32_t *__restrict__ pDst);

void plp_mat_trans_i32p_xpulpv2(void *args);

void plp_mat_trans_i16(const int16_t *__restrict__ pSrc,
                       uint32_t M,
                       uint32_t N,
                       int16_t *__restrict__ pDst);

void plp_mat_trans_i16s_rv32im(const int16_t *__restrict__ pSrc,
                               uint32_t M,
                               uint32_t N,
                               int16_t *__restrict__ pDst);

void plp_mat_trans_i16s_xpulpv2(const int16_t *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                int16_t *__restrict__ pDst);

void plp_mat_trans_i16_parallel(const int16_t *__restrict__ pSrc,
                                uint32_t M,
                                uint32_t N,
                                uint32_t nPE,
                                int16_t *__restrict__ pDst);

void plp_mat_trans_i16p_xpulpv2(void *args);

void plp_mat_trans_i8(const int8_t *__restrict__ pSrc,
                      uint32_t M,
                      uint32_t N,
                      int8_t *__restrict__ pDst);

void plp_mat_trans_i8s_rv32im(const int8_t *__restrict__ pSrc,
                              uint32_t M,
                              uint32_t N,
                              int8_t *__restrict__ pDst);

void plp_mat_trans_i8s_xpulpv2(const int8_t *__restrict__ pSrc,
                               uint32_t M,
                               uint32_t N,
                               int8_t *__restrict__ pDst);

void plp_mat_trans_i8_parallel(const int8_t *__restrict__ pSrc,
                               uint32_t M,
                               uint32_t N,
                               uint32_t nPE,
                               int8_t *__restrict__ pDst);

void plp_mat_trans_i8p_xpulpv2(void *args);

void plp_mat_trans_f32(const float *__restrict__ pSrc,
                       uint32_t M,
                       uint32_t N,
                       float *__restrict__ pDst);

void plp_mat_trans_f32_parallel(
    const float *__restrict__ pSrc, uint32_t M, uint32_t N, uint32_t nPE, float *__restrict__ pDst);

int plp_mat_inv_f32(float *__restrict__ pSrc, float *__restrict__ pDst, uint32_t N);

int plp_mat_inv_f32s_xpulpv2(float *__restrict__ pSrc, float *__restrict__ pDst, uint32_t N);

int plp_mat_inv_f32_parallel( float *__restrict__ pSrc,
                              float *__restrict__ pDst,
                              uint32_t N,
                              uint32_t nPE);

int plp_mat_inv_f32p_xpulpv2(void *args);

void plp_mat_fill_I_i32(uint32_t N, int32_t *__restrict__ pDst);

void plp_mat_fill_I_i32s_rv32im(uint32_t N, int32_t *__restrict__ pDst);

void plp_mat_fill_I_i32s_xpulpv2(uint32_t N, int32_t *__restrict__ pDst);

void plp_mat_fill_I_i32_parallel(uint32_t N, uint32_t nPE, int32_t *__restrict__ pDst);

void plp_mat_fill_I_i32p_xpulpv2(void *args);

void plp_mat_fill_I_i16(uint32_t N, int16_t *__restrict__ pDst);

void plp_mat_fill_I_i16s_rv32im(uint32_t N, int16_t *__restrict__ pDst);

void plp_mat_fill_I_i16s_xpulpv2(uint32_t N, int16_t *__restrict__ pDst);

void plp_mat_fill_I_i16_parallel(uint32_t N, uint32_t nPE, int16_t *__restrict__ pDst);

void plp_mat_fill_I_i16p_xpulpv2(void *args);

void plp_mat_fill_I_i8(uint32_t N, int8_t *__restrict__ pDst);

void plp_mat_fill_I_i8s_rv32im(uint32_t N, int8_t *__restrict__ pDst);

void plp_mat_fill_I_i8s_xpulpv2(uint32_t N, int8_t *__restrict__ pDst);

void plp_mat_fill_I_i8_parallel(uint32_t N, uint32_t nPE, int8_t *__restrict__ pDst);

void plp_mat_fill_I_i8p_xpulpv2(void *args);

void plp_mat_fill_I_f32(uint32_t N, float *__restrict__ pDst);

void plp_mat_fill_I_f32s_xpulpv2(uint32_t N, float *__restrict__ pDst);

void plp_mat_fill_I_f32_parallel(uint32_t N, uint32_t nPE, float *__restrict__ pDst);

void plp_mat_fill_I_f32p_xpulpv2(void *args);

void plp_mat_fill_I_q32(uint32_t N, int32_t fracBits, int32_t *__restrict__ pDst);

void plp_mat_fill_I_q32s_rv32im(uint32_t N, int32_t fracBits, int32_t *__restrict__ pDst);

void plp_mat_fill_I_q32s_xpulpv2(uint32_t N, int32_t fracBits, int32_t *__restrict__ pDst);

void plp_mat_fill_I_q32_parallel(uint32_t N,
                                 int32_t fracBits,
                                 uint32_t nPE,
                                 int32_t *__restrict__ pDst);

void plp_mat_fill_I_q32p_xpulpv2(void *args);

void plp_mat_fill_I_q16(uint32_t N, int32_t fracBits, int16_t *__restrict__ pDst);

void plp_mat_fill_I_q16s_rv32im(uint32_t N, int32_t fracBits, int16_t *__restrict__ pDst);

void plp_mat_fill_I_q16s_xpulpv2(uint32_t N, int32_t fracBits, int16_t *__restrict__ pDst);

void plp_mat_fill_I_q16_parallel(uint32_t N,
                                 int32_t fracBits,
                                 uint32_t nPE,
                                 int16_t *__restrict__ pDst);

void plp_mat_fill_I_q16p_xpulpv2(void *args);

void plp_mat_fill_I_q8(uint32_t N, int32_t fracBits, int8_t *__restrict__ pDst);

void plp_mat_fill_I_q8s_rv32im(uint32_t N, int32_t fracBits, int8_t *__restrict__ pDst);

void plp_mat_fill_I_q8s_xpulpv2(uint32_t N, int32_t fracBits, int8_t *__restrict__ pDst);

void plp_mat_fill_I_q8_parallel(uint32_t N,
                                int32_t fracBits,
                                uint32_t nPE,
                                int8_t *__restrict__ pDst);

void plp_mat_fill_I_q8p_xpulpv2(void *args);

void plp_mat_mult_stride_i32(const int32_t *__restrict__ pSrcA,
                             const int32_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             uint32_t O,
                             uint32_t strideA,
                             uint32_t strideB,
                             uint32_t strideC,
                             int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideC,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                      const int32_t *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i16(const int16_t *__restrict__ pSrcA,
                             const int16_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             uint32_t O,
                             uint32_t strideA,
                             uint32_t strideB,
                             uint32_t strideC,
                             int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideC,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                      const int16_t *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i8(const int8_t *__restrict__ pSrcA,
                            const int8_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            uint32_t strideA,
                            uint32_t strideB,
                            uint32_t strideC,
                            int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideC,
                                    int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                     const int8_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideC,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i32_parallel(const int32_t *__restrict__ pSrcA,
                                      const int32_t *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      uint32_t nPE,
                                      int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i32p_xpulpv2(void *args);

void plp_mat_mult_stride_i16_parallel(const int16_t *__restrict__ pSrcA,
                                      const int16_t *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      uint32_t nPE,
                                      int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_i16p_xpulpv2(void *args);

void plp_mat_mult_stride_i8_parallel(const int8_t *__restrict__ pSrcA,
                                     const int8_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideC,
                                     uint32_t nPE,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_f32(const float *__restrict__ pSrcA,
                             const float *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             uint32_t O,
                             uint32_t strideA,
                             uint32_t strideB,
                             uint32_t strideC,
                             float *__restrict__ pDstC);

void plp_mat_mult_stride_f32s_xpulpv2(const float *__restrict__ pSrcA,
                                      const float *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      float *__restrict__ pDstC);

void plp_mat_mult_stride_f32_parallel(const float *__restrict__ pSrcA,
                                      const float *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      uint32_t nPE,
                                      float *__restrict__ pDstC);

void plp_mat_mult_stride_f32p_xpulpv2(void *args);

void plp_mat_mult_stride_i8p_xpulpv2(void *args);

void plp_mat_mult_stride_q32(const int32_t *__restrict__ pSrcA,
                             const int32_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             uint32_t O,
                             uint32_t strideA,
                             uint32_t strideB,
                             uint32_t strideC,
                             uint32_t shift,
                             int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_q32_parallel(const int32_t *__restrict__ pSrcA,
                                      const int32_t *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      uint32_t shift,
                                      uint32_t nPE,
                                      int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_q32s_rv32im(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideC,
                                     uint32_t shift,
                                     int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                      const int32_t *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      uint32_t shift,
                                      int32_t *__restrict__ pDstC);

void plp_mat_mult_stride_q32p_xpulpv2(void *args);

void plp_mat_mult_stride_q16(const int16_t *__restrict__ pSrcA,
                             const int16_t *__restrict__ pSrcB,
                             uint32_t M,
                             uint32_t N,
                             uint32_t O,
                             uint32_t strideA,
                             uint32_t strideB,
                             uint32_t strideC,
                             uint32_t shift,
                             int16_t *__restrict__ pDstC);

void plp_mat_mult_stride_q16_parallel(const int16_t *__restrict__ pSrcA,
                                      const int16_t *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      uint32_t shift,
                                      uint32_t nPE,
                                      int16_t *__restrict__ pDstC);

void plp_mat_mult_stride_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideC,
                                     uint32_t shift,
                                     int16_t *__restrict__ pDstC);

void plp_mat_mult_stride_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                      const int16_t *__restrict__ pSrcB,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t O,
                                      uint32_t strideA,
                                      uint32_t strideB,
                                      uint32_t strideC,
                                      uint32_t shift,
                                      int16_t *__restrict__ pDstC);

void plp_mat_mult_stride_q16p_xpulpv2(void *args);

void plp_mat_mult_stride_q8(const int8_t *__restrict__ pSrcA,
                            const int8_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t O,
                            uint32_t strideA,
                            uint32_t strideB,
                            uint32_t strideC,
                            uint32_t shift,
                            int8_t *__restrict__ pDstC);

void plp_mat_mult_stride_q8_parallel(const int8_t *__restrict__ pSrcA,
                                     const int8_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideC,
                                     uint32_t shift,
                                     uint32_t nPE,
                                     int8_t *__restrict__ pDstC);

void plp_mat_mult_stride_q8s_rv32im(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t O,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideC,
                                    uint32_t shift,
                                    int8_t *__restrict__ pDstC);

void plp_mat_mult_stride_q8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                     const int8_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t O,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideC,
                                     uint32_t shift,
                                     int8_t *__restrict__ pDstC);

void plp_mat_mult_stride_q8p_xpulpv2(void *args);

void plp_mat_mult_trans_stride_i32(const int32_t *__restrict__ pSrcA,
                                   const int32_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                                           const int32_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i16(const int16_t *__restrict__ pSrcA,
                                   const int16_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                                           const int16_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                            const int16_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i8(const int8_t *__restrict__ pSrcA,
                                  const int8_t *__restrict__ pSrcB,
                                  uint32_t M,
                                  uint32_t N,
                                  uint32_t O,
                                  uint32_t strideA,
                                  uint32_t strideB,
                                  uint32_t strideC,
                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                                          const int8_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          uint32_t strideA,
                                          uint32_t strideB,
                                          uint32_t strideC,
                                          int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                           const int8_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i32_parallel(const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t nPE,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i32p_xpulpv2(void *args);

void plp_mat_mult_trans_stride_i16_parallel(const int16_t *__restrict__ pSrcA,
                                            const int16_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t nPE,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i16p_xpulpv2(void *args);

void plp_mat_mult_trans_stride_i8_parallel(const int8_t *__restrict__ pSrcA,
                                           const int8_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t nPE,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_i8p_xpulpv2(void *args);

void plp_mat_mult_trans_stride_q32(const int32_t *__restrict__ pSrcA,
                                   const int32_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   uint32_t shift,
                                   int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q32_parallel(const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t shift,
                                            uint32_t nPE,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q32s_rv32im(const int32_t *__restrict__ pSrcA,
                                           const int32_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t shift,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t shift,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q32p_xpulpv2(void *args);

void plp_mat_mult_trans_stride_q16(const int16_t *__restrict__ pSrcA,
                                   const int16_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   uint32_t shift,
                                   int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q16_parallel(const int16_t *__restrict__ pSrcA,
                                            const int16_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t shift,
                                            uint32_t nPE,
                                            int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                                           const int16_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t shift,
                                           int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                            const int16_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t shift,
                                            int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q16p_xpulpv2(void *args);

void plp_mat_mult_trans_stride_q8(const int8_t *__restrict__ pSrcA,
                                  const int8_t *__restrict__ pSrcB,
                                  uint32_t M,
                                  uint32_t N,
                                  uint32_t O,
                                  uint32_t strideA,
                                  uint32_t strideB,
                                  uint32_t strideC,
                                  uint32_t shift,
                                  int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q8_parallel(const int8_t *__restrict__ pSrcA,
                                           const int8_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t shift,
                                           uint32_t nPE,
                                           int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q8s_rv32im(const int8_t *__restrict__ pSrcA,
                                          const int8_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          uint32_t strideA,
                                          uint32_t strideB,
                                          uint32_t strideC,
                                          uint32_t shift,
                                          int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                           const int8_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t shift,
                                           int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_stride_q8p_xpulpv2(void *args);

void plp_mat_mult_trans_stride_f32(const float *__restrict__ pSrcA,
                                   const float *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   float *__restrict__ pDstC);

void plp_mat_mult_trans_stride_f32s_xpulpv2(const float *__restrict__ pSrcA,
                                            const float *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            float *__restrict__ pDstC);

void plp_mat_mult_trans_stride_f32_parallel(const float *__restrict__ pSrcA,
                                            const float *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t nPE,
                                            float *__restrict__ pDstC);

void plp_mat_mult_trans_stride_f32p_xpulpv2(void *args);

void plp_mat_mult_cmplx_stride_i32(const int32_t *__restrict__ pSrcA,
                                   const int32_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                                           const int32_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i32_parallel(const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t nPE,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i32p_xpulpv2(void *args);

void plp_mat_mult_cmplx_stride_i16(const int16_t *__restrict__ pSrcA,
                                   const int16_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                                           const int16_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                            const int16_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i16_parallel(const int16_t *__restrict__ pSrcA,
                                            const int16_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t nPE,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i16p_xpulpv2(void *args);

void plp_mat_mult_cmplx_stride_i8(const int8_t *__restrict__ pSrcA,
                                  const int8_t *__restrict__ pSrcB,
                                  uint32_t M,
                                  uint32_t N,
                                  uint32_t O,
                                  uint32_t strideA,
                                  uint32_t strideB,
                                  uint32_t strideC,
                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                                          const int8_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          uint32_t strideA,
                                          uint32_t strideB,
                                          uint32_t strideC,
                                          int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                           const int8_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i8_parallel(const int8_t *__restrict__ pSrcA,
                                           const int8_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t nPE,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_i8p_xpulpv2(void *args);

void plp_mat_mult_cmplx_stride_f32(const float *__restrict__ pSrcA,
                                   const float *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   float *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_f32s_xpulpv2(const float *__restrict__ pSrcA,
                                            const float *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            float *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_f32_parallel(const float *__restrict__ pSrcA,
                                            const float *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t nPE,
                                            float *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_f32p_xpulpv2(void *args);

void plp_mat_mult_cmplx_stride_q32(const int32_t *__restrict__ pSrcA,
                                   const int32_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   uint32_t shift,
                                   int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q32s_rv32im(const int32_t *__restrict__ pSrcA,
                                           const int32_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t shift,
                                           int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t shift,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q32_parallel(const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t shift,
                                            uint32_t nPE,
                                            int32_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q32p_xpulpv2(void *args);

void plp_mat_mult_cmplx_stride_q16(const int16_t *__restrict__ pSrcA,
                                   const int16_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t O,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideC,
                                   uint32_t shift,
                                   int16_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                                           const int16_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t shift,
                                           int16_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                            const int16_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t shift,
                                            int16_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q16_parallel(const int16_t *__restrict__ pSrcA,
                                            const int16_t *__restrict__ pSrcB,
                                            uint32_t M,
                                            uint32_t N,
                                            uint32_t O,
                                            uint32_t strideA,
                                            uint32_t strideB,
                                            uint32_t strideC,
                                            uint32_t shift,
                                            uint32_t nPE,
                                            int16_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q16p_xpulpv2(void *args);

void plp_mat_mult_cmplx_stride_q8(const int8_t *__restrict__ pSrcA,
                                  const int8_t *__restrict__ pSrcB,
                                  uint32_t M,
                                  uint32_t N,
                                  uint32_t O,
                                  uint32_t strideA,
                                  uint32_t strideB,
                                  uint32_t strideC,
                                  uint32_t shift,
                                  int8_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q8s_rv32im(const int8_t *__restrict__ pSrcA,
                                          const int8_t *__restrict__ pSrcB,
                                          uint32_t M,
                                          uint32_t N,
                                          uint32_t O,
                                          uint32_t strideA,
                                          uint32_t strideB,
                                          uint32_t strideC,
                                          uint32_t shift,
                                          int8_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                           const int8_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t shift,
                                           int8_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q8_parallel(const int8_t *__restrict__ pSrcA,
                                           const int8_t *__restrict__ pSrcB,
                                           uint32_t M,
                                           uint32_t N,
                                           uint32_t O,
                                           uint32_t strideA,
                                           uint32_t strideB,
                                           uint32_t strideC,
                                           uint32_t shift,
                                           uint32_t nPE,
                                           int8_t *__restrict__ pDstC);

void plp_mat_mult_cmplx_stride_q8p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_stride_i32(const int32_t *__restrict__ pSrcA,
                                         const int32_t *__restrict__ pSrcB,
                                         uint32_t M,
                                         uint32_t N,
                                         uint32_t O,
                                         uint32_t strideA,
                                         uint32_t strideB,
                                         uint32_t strideC,
                                         int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                                                 const int32_t *__restrict__ pSrcB,
                                                 uint32_t M,
                                                 uint32_t N,
                                                 uint32_t O,
                                                 uint32_t strideA,
                                                 uint32_t strideB,
                                                 uint32_t strideC,
                                                 int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                                  const int32_t *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i32_parallel(const int32_t *__restrict__ pSrcA,
                                                  const int32_t *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  uint32_t nPE,
                                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i32p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_stride_i16(const int16_t *__restrict__ pSrcA,
                                         const int16_t *__restrict__ pSrcB,
                                         uint32_t M,
                                         uint32_t N,
                                         uint32_t O,
                                         uint32_t strideA,
                                         uint32_t strideB,
                                         uint32_t strideC,
                                         int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                                                 const int16_t *__restrict__ pSrcB,
                                                 uint32_t M,
                                                 uint32_t N,
                                                 uint32_t O,
                                                 uint32_t strideA,
                                                 uint32_t strideB,
                                                 uint32_t strideC,
                                                 int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                                  const int16_t *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i16_parallel(const int16_t *__restrict__ pSrcA,
                                                  const int16_t *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  uint32_t nPE,
                                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i16p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_stride_i8(const int8_t *__restrict__ pSrcA,
                                        const int8_t *__restrict__ pSrcB,
                                        uint32_t M,
                                        uint32_t N,
                                        uint32_t O,
                                        uint32_t strideA,
                                        uint32_t strideB,
                                        uint32_t strideC,
                                        int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                                                const int8_t *__restrict__ pSrcB,
                                                uint32_t M,
                                                uint32_t N,
                                                uint32_t O,
                                                uint32_t strideA,
                                                uint32_t strideB,
                                                uint32_t strideC,
                                                int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                                 const int8_t *__restrict__ pSrcB,
                                                 uint32_t M,
                                                 uint32_t N,
                                                 uint32_t O,
                                                 uint32_t strideA,
                                                 uint32_t strideB,
                                                 uint32_t strideC,
                                                 int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i8_parallel(const int8_t *__restrict__ pSrcA,
                                                 const int8_t *__restrict__ pSrcB,
                                                 uint32_t M,
                                                 uint32_t N,
                                                 uint32_t O,
                                                 uint32_t strideA,
                                                 uint32_t strideB,
                                                 uint32_t strideC,
                                                 uint32_t nPE,
                                                 int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_i8p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_stride_f32(const float *__restrict__ pSrcA,
                                         const float *__restrict__ pSrcB,
                                         uint32_t M,
                                         uint32_t N,
                                         uint32_t O,
                                         uint32_t strideA,
                                         uint32_t strideB,
                                         uint32_t strideC,
                                         float *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_f32s_xpulpv2(const float *__restrict__ pSrcA,
                                                  const float *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  float *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_f32_parallel(const float *__restrict__ pSrcA,
                                                  const float *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  uint32_t nPE,
                                                  float *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_f32p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_stride_q32(const int32_t *__restrict__ pSrcA,
                                         const int32_t *__restrict__ pSrcB,
                                         uint32_t M,
                                         uint32_t N,
                                         uint32_t O,
                                         uint32_t strideA,
                                         uint32_t strideB,
                                         uint32_t strideC,
                                         uint32_t shift,
                                         int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q32s_rv32im(const int32_t *__restrict__ pSrcA,
                                                 const int32_t *__restrict__ pSrcB,
                                                 uint32_t M,
                                                 uint32_t N,
                                                 uint32_t O,
                                                 uint32_t strideA,
                                                 uint32_t strideB,
                                                 uint32_t strideC,
                                                 uint32_t shift,
                                                 int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                                  const int32_t *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  uint32_t shift,
                                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q32_parallel(const int32_t *__restrict__ pSrcA,
                                                  const int32_t *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  uint32_t shift,
                                                  uint32_t nPE,
                                                  int32_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q32p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_stride_q16(const int16_t *__restrict__ pSrcA,
                                         const int16_t *__restrict__ pSrcB,
                                         uint32_t M,
                                         uint32_t N,
                                         uint32_t O,
                                         uint32_t strideA,
                                         uint32_t strideB,
                                         uint32_t strideC,
                                         uint32_t shift,
                                         int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                                                 const int16_t *__restrict__ pSrcB,
                                                 uint32_t M,
                                                 uint32_t N,
                                                 uint32_t O,
                                                 uint32_t strideA,
                                                 uint32_t strideB,
                                                 uint32_t strideC,
                                                 uint32_t shift,
                                                 int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                                  const int16_t *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  uint32_t shift,
                                                  int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q16_parallel(const int16_t *__restrict__ pSrcA,
                                                  const int16_t *__restrict__ pSrcB,
                                                  uint32_t M,
                                                  uint32_t N,
                                                  uint32_t O,
                                                  uint32_t strideA,
                                                  uint32_t strideB,
                                                  uint32_t strideC,
                                                  uint32_t shift,
                                                  uint32_t nPE,
                                                  int16_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q16p_xpulpv2(void *args);

void plp_mat_mult_trans_cmplx_stride_q8(const int8_t *__restrict__ pSrcA,
                                        const int8_t *__restrict__ pSrcB,
                                        uint32_t M,
                                        uint32_t N,
                                        uint32_t O,
                                        uint32_t strideA,
                                        uint32_t strideB,
                                        uint32_t strideC,
                                        uint32_t shift,
                                        int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q8s_rv32im(const int8_t *__restrict__ pSrcA,
                                                const int8_t *__restrict__ pSrcB,
                                                uint32_t M,
                                                uint32_t N,
                                                uint32_t O,
                                                uint32_t strideA,
                                                uint32_t strideB,
                                                uint32_t strideC,
                                                uint32_t shift,
                                                int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                                 const int8_t *__restrict__ pSrcB,
                                                 uint32_t M,
                                                 uint32_t N,
                                                 uint32_t O,
                                                 uint32_t strideA,
                                                 uint32_t strideB,
                                                 uint32_t strideC,
                                                 uint32_t shift,
                                                 int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q8_parallel(const int8_t *__restrict__ pSrcA,
                                                 const int8_t *__restrict__ pSrcB,
                                                 uint32_t M,
                                                 uint32_t N,
                                                 uint32_t O,
                                                 uint32_t strideA,
                                                 uint32_t strideB,
                                                 uint32_t strideC,
                                                 uint32_t shift,
                                                 uint32_t nPE,
                                                 int8_t *__restrict__ pDstC);

void plp_mat_mult_trans_cmplx_stride_q8p_xpulpv2(void *args);

void plp_mat_add_stride_i32(const int32_t *__restrict__ pSrcA,
                            const int32_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t strideA,
                            uint32_t strideB,
                            uint32_t strideY,
                            int32_t *__restrict__ pDst);

void plp_mat_add_stride_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                                    const int32_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideY,
                                    int32_t *__restrict__ pDst);

void plp_mat_add_stride_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     int32_t *__restrict__ pDst);

void plp_mat_add_stride_i32_parallel(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     uint32_t nPE,
                                     int32_t *__restrict__ pDst);

void plp_mat_add_stride_i32p_xpulpv2(void *args);

void plp_mat_add_stride_i16(const int16_t *__restrict__ pSrcA,
                            const int16_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t strideA,
                            uint32_t strideB,
                            uint32_t strideY,
                            int16_t *__restrict__ pDst);

void plp_mat_add_stride_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                                    const int16_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideY,
                                    int16_t *__restrict__ pDst);

void plp_mat_add_stride_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     int16_t *__restrict__ pDst);

void plp_mat_add_stride_i16_parallel(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     uint32_t nPE,
                                     int16_t *__restrict__ pDst);

void plp_mat_add_stride_i16p_xpulpv2(void *args);

void plp_mat_add_stride_i8(const int8_t *__restrict__ pSrcA,
                           const int8_t *__restrict__ pSrcB,
                           uint32_t M,
                           uint32_t N,
                           uint32_t strideA,
                           uint32_t strideB,
                           uint32_t strideY,
                           int8_t *__restrict__ pDst);

void plp_mat_add_stride_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                                   const int8_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideY,
                                   int8_t *__restrict__ pDst);

void plp_mat_add_stride_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideY,
                                    int8_t *__restrict__ pDst);

void plp_mat_add_stride_i8_parallel(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideY,
                                    uint32_t nPE,
                                    int8_t *__restrict__ pDst);

void plp_mat_add_stride_i8p_xpulpv2(void *args);

void plp_mat_add_stride_f32(const float *__restrict__ pSrcA,
                            const float *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t strideA,
                            uint32_t strideB,
                            uint32_t strideY,
                            float *__restrict__ pDst);

void plp_mat_add_stride_f32s_xpulpv2(const float *__restrict__ pSrcA,
                                     const float *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     float *__restrict__ pDst);

void plp_mat_add_stride_f32_parallel(const float *__restrict__ pSrcA,
                                     const float *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     uint32_t nPE,
                                     float *__restrict__ pDst);

void plp_mat_add_stride_f32p_xpulpv2(void *args);

void plp_mat_sub_stride_i32(const int32_t *__restrict__ pSrcA,
                            const int32_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t strideA,
                            uint32_t strideB,
                            uint32_t strideY,
                            int32_t *__restrict__ pDst);

void plp_mat_sub_stride_i32s_rv32im(const int32_t *__restrict__ pSrcA,
                                    const int32_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideY,
                                    int32_t *__restrict__ pDst);

void plp_mat_sub_stride_i32s_xpulpv2(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     int32_t *__restrict__ pDst);

void plp_mat_sub_stride_i32_parallel(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     uint32_t nPE,
                                     int32_t *__restrict__ pDst);

void plp_mat_sub_stride_i32p_xpulpv2(void *args);

void plp_mat_sub_stride_i16(const int16_t *__restrict__ pSrcA,
                            const int16_t *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t strideA,
                            uint32_t strideB,
                            uint32_t strideY,
                            int16_t *__restrict__ pDst);

void plp_mat_sub_stride_i16s_rv32im(const int16_t *__restrict__ pSrcA,
                                    const int16_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideY,
                                    int16_t *__restrict__ pDst);

void plp_mat_sub_stride_i16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     int16_t *__restrict__ pDst);

void plp_mat_sub_stride_i16_parallel(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     uint32_t nPE,
                                     int16_t *__restrict__ pDst);

void plp_mat_sub_stride_i16p_xpulpv2(void *args);

void plp_mat_sub_stride_i8(const int8_t *__restrict__ pSrcA,
                           const int8_t *__restrict__ pSrcB,
                           uint32_t M,
                           uint32_t N,
                           uint32_t strideA,
                           uint32_t strideB,
                           uint32_t strideY,
                           int8_t *__restrict__ pDst);

void plp_mat_sub_stride_i8s_rv32im(const int8_t *__restrict__ pSrcA,
                                   const int8_t *__restrict__ pSrcB,
                                   uint32_t M,
                                   uint32_t N,
                                   uint32_t strideA,
                                   uint32_t strideB,
                                   uint32_t strideY,
                                   int8_t *__restrict__ pDst);

void plp_mat_sub_stride_i8s_xpulpv2(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideY,
                                    int8_t *__restrict__ pDst);

void plp_mat_sub_stride_i8_parallel(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t strideA,
                                    uint32_t strideB,
                                    uint32_t strideY,
                                    uint32_t nPE,
                                    int8_t *__restrict__ pDst);

void plp_mat_sub_stride_i8p_xpulpv2(void *args);

void plp_mat_sub_stride_f32(const float *__restrict__ pSrcA,
                            const float *__restrict__ pSrcB,
                            uint32_t M,
                            uint32_t N,
                            uint32_t strideA,
                            uint32_t strideB,
                            uint32_t strideY,
                            float *__restrict__ pDst);

void plp_mat_sub_stride_f32s_xpulpv2(const float *__restrict__ pSrcA,
                                     const float *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     float *__restrict__ pDst);

void plp_mat_sub_stride_f32_parallel(const float *__restrict__ pSrcA,
                                     const float *__restrict__ pSrcB,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideA,
                                     uint32_t strideB,
                                     uint32_t strideY,
                                     uint32_t nPE,
                                     float *__restrict__ pDst);

void plp_mat_sub_stride_f32p_xpulpv2(void *args);

void plp_mat_scale_stride_i32(const int32_t *__restrict__ pSrc,
                              uint32_t M,
                              uint32_t N,
                              uint32_t strideSrc,
                              uint32_t strideDst,
                              int32_t scaleFactor,
                              int32_t shift,
                              int32_t *__restrict__ pDst);

void plp_mat_scale_stride_i32s_rv32im(const int32_t *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      int32_t scaleFactor,
                                      int32_t shift,
                                      int32_t *__restrict__ pDst);

void plp_mat_scale_stride_i32s_xpulpv2(const int32_t *__restrict__ pSrc,
                                       uint32_t M,
                                       uint32_t N,
                                       uint32_t strideSrc,
                                       uint32_t strideDst,
                                       int32_t scaleFactor,
                                       int32_t shift,
                                       int32_t *__restrict__ pDst);

void plp_mat_scale_stride_i32_parallel(const int32_t *__restrict__ pSrc,
                                       uint32_t M,
                                       uint32_t N,
                                       uint32_t strideSrc,
                                       uint32_t strideDst,
                                       int32_t scaleFactor,
                                       int32_t shift,
                                       uint32_t nPE,
                                       int32_t *__restrict__ pDst);

void plp_mat_scale_stride_i32p_xpulpv2(void *args);

void plp_mat_scale_stride_i16(const int16_t *__restrict__ pSrc,
                              uint32_t M,
                              uint32_t N,
                              uint32_t strideSrc,
                              uint32_t strideDst,
                              int16_t scaleFactor,
                              int32_t shift,
                              int16_t *__restrict__ pDst);

void plp_mat_scale_stride_i16s_rv32im(const int16_t *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      int16_t scaleFactor,
                                      int32_t shift,
                                      int16_t *__restrict__ pDst);

void plp_mat_scale_stride_i16s_xpulpv2(const int16_t *__restrict__ pSrc,
                                       uint32_t M,
                                       uint32_t N,
                                       uint32_t strideSrc,
                                       uint32_t strideDst,
                                       int16_t scaleFactor,
                                       int32_t shift,
                                       int16_t *__restrict__ pDst);

void plp_mat_scale_stride_i16_parallel(const int16_t *__restrict__ pSrc,
                                       uint32_t M,
                                       uint32_t N,
                                       uint32_t strideSrc,
                                       uint32_t strideDst,
                                       int16_t scaleFactor,
                                       int32_t shift,
                                       uint32_t nPE,
                                       int16_t *__restrict__ pDst);

void plp_mat_scale_stride_i16p_xpulpv2(void *args);

void plp_mat_scale_stride_i8(const int8_t *__restrict__ pSrc,
                             uint32_t M,
                             uint32_t N,
                             uint32_t strideSrc,
                             uint32_t strideDst,
                             int8_t scaleFactor,
                             int32_t shift,
                             int8_t *__restrict__ pDst);

void plp_mat_scale_stride_i8s_rv32im(const int8_t *__restrict__ pSrc,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideSrc,
                                     uint32_t strideDst,
                                     int8_t scaleFactor,
                                     int32_t shift,
                                     int8_t *__restrict__ pDst);

void plp_mat_scale_stride_i8s_xpulpv2(const int8_t *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      int8_t scaleFactor,
                                      int32_t shift,
                                      int8_t *__restrict__ pDst);

void plp_mat_scale_stride_i8_parallel(const int8_t *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      int8_t scaleFactor,
                                      int32_t shift,
                                      uint32_t nPE,
                                      int8_t *__restrict__ pDst);

void plp_mat_scale_stride_i8p_xpulpv2(void *args);

void plp_mat_scale_stride_f32(const float *__restrict__ pSrc,
                              uint32_t M,
                              uint32_t N,
                              uint32_t strideSrc,
                              uint32_t strideDst,
                              float scaleFactor,
                              float *__restrict__ pDst);

void plp_mat_scale_stride_f32s_xpulpv2(const float *__restrict__ pSrc,
                                       uint32_t M,
                                       uint32_t N,
                                       uint32_t strideSrc,
                                       uint32_t strideDst,
                                       float scaleFactor,
                                       float *__restrict__ pDst);

void plp_mat_scale_stride_f32_parallel(const float *__restrict__ pSrc,
                                       uint32_t M,
                                       uint32_t N,
                                       uint32_t strideSrc,
                                       uint32_t strideDst,
                                       float scaleFactor,
                                       uint32_t nPE,
                                       float *__restrict__ pDst);

void plp_mat_scale_stride_f32p_xpulpv2(void *args);

void plp_mat_fill_I_stride_i32(uint32_t N, uint32_t stride, int32_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i32s_rv32im(uint32_t N, uint32_t stride, int32_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i32s_xpulpv2(uint32_t N, uint32_t stride, int32_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i32_parallel(uint32_t N,
                                        uint32_t stride,
                                        uint32_t nPE,
                                        int32_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i32p_xpulpv2(void *args);

void plp_mat_fill_I_stride_i16(uint32_t N, uint32_t stride, int16_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i16s_rv32im(uint32_t N, uint32_t stride, int16_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i16s_xpulpv2(uint32_t N, uint32_t stride, int16_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i16_parallel(uint32_t N,
                                        uint32_t stride,
                                        uint32_t nPE,
                                        int16_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i16p_xpulpv2(void *args);

void plp_mat_fill_I_stride_i8(uint32_t N, uint32_t stride, int8_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i8s_rv32im(uint32_t N, uint32_t stride, int8_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i8s_xpulpv2(uint32_t N, uint32_t stride, int8_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i8_parallel(uint32_t N,
                                       uint32_t stride,
                                       uint32_t nPE,
                                       int8_t *__restrict__ pDst);

void plp_mat_fill_I_stride_i8p_xpulpv2(void *args);

void plp_mat_fill_I_stride_f32(uint32_t N, uint32_t stride, float *__restrict__ pDst);

void plp_mat_fill_I_stride_f32s_xpulpv2(uint32_t N, uint32_t stride, float *__restrict__ pDst);

void plp_mat_fill_I_stride_f32_parallel(uint32_t N,
                                        uint32_t stride,
                                        uint32_t nPE,
                                        float *__restrict__ pDst);

void plp_mat_fill_I_stride_f32p_xpulpv2(void *args);

void plp_mat_fill_I_stride_q32(uint32_t N,
                               uint32_t stride,
                               int32_t fracBits,
                               int32_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q32s_rv32im(uint32_t N,
                                       uint32_t stride,
                                       int32_t fracBits,
                                       int32_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q32s_xpulpv2(uint32_t N,
                                        uint32_t stride,
                                        int32_t fracBits,
                                        int32_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q32_parallel(
    uint32_t N, uint32_t stride, int32_t fracBits, uint32_t nPE, int32_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q32p_xpulpv2(void *args);

void plp_mat_fill_I_stride_q16(uint32_t N,
                               uint32_t stride,
                               int32_t fracBits,
                               int16_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q16s_rv32im(uint32_t N,
                                       uint32_t stride,
                                       int32_t fracBits,
                                       int16_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q16s_xpulpv2(uint32_t N,
                                        uint32_t stride,
                                        int32_t fracBits,
                                        int16_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q16_parallel(
    uint32_t N, uint32_t stride, int32_t fracBits, uint32_t nPE, int16_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q16p_xpulpv2(void *args);

void plp_mat_fill_I_stride_q8(uint32_t N,
                              uint32_t stride,
                              int32_t fracBits,
                              int8_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q8s_rv32im(uint32_t N,
                                      uint32_t stride,
                                      int32_t fracBits,
                                      int8_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q8s_xpulpv2(uint32_t N,
                                       uint32_t stride,
                                       int32_t fracBits,
                                       int8_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q8_parallel(
    uint32_t N, uint32_t stride, int32_t fracBits, uint32_t nPE, int8_t *__restrict__ pDst);

void plp_mat_fill_I_stride_q8p_xpulpv2(void *args);

void plp_mat_fill_stride_i32(
    uint32_t M, uint32_t N, uint32_t stride, int32_t value, int32_t *__restrict__ pDst);

void plp_mat_fill_stride_i32s_rv32im(
    uint32_t M, uint32_t N, uint32_t stride, int32_t value, int32_t *__restrict__ pDst);

void plp_mat_fill_stride_i32s_xpulpv2(
    uint32_t M, uint32_t N, uint32_t stride, int32_t value, int32_t *__restrict__ pDst);

void plp_mat_fill_stride_i32_parallel(uint32_t M,
                                      uint32_t N,
                                      uint32_t stride,
                                      int32_t value,
                                      uint32_t nPE,
                                      int32_t *__restrict__ pDst);

void plp_mat_fill_stride_i32p_xpulpv2(void *args);

void plp_mat_fill_stride_i16(
    uint32_t M, uint32_t N, uint32_t stride, int16_t value, int16_t *__restrict__ pDst);

void plp_mat_fill_stride_i16s_rv32im(
    uint32_t M, uint32_t N, uint32_t stride, int16_t value, int16_t *__restrict__ pDst);

void plp_mat_fill_stride_i16s_xpulpv2(
    uint32_t M, uint32_t N, uint32_t stride, int16_t value, int16_t *__restrict__ pDst);

void plp_mat_fill_stride_i16_parallel(uint32_t M,
                                      uint32_t N,
                                      uint32_t stride,
                                      int16_t value,
                                      uint32_t nPE,
                                      int16_t *__restrict__ pDst);

void plp_mat_fill_stride_i16p_xpulpv2(void *args);

void plp_mat_fill_stride_i8(
    uint32_t M, uint32_t N, uint32_t stride, int8_t value, int8_t *__restrict__ pDst);

void plp_mat_fill_stride_i8s_rv32im(
    uint32_t M, uint32_t N, uint32_t stride, int8_t value, int8_t *__restrict__ pDst);

void plp_mat_fill_stride_i8s_xpulpv2(
    uint32_t M, uint32_t N, uint32_t stride, int8_t value, int8_t *__restrict__ pDst);

void plp_mat_fill_stride_i8_parallel(
    uint32_t M, uint32_t N, uint32_t stride, int8_t value, uint32_t nPE, int8_t *__restrict__ pDst);

void plp_mat_fill_stride_i8p_xpulpv2(void *args);

void plp_mat_fill_stride_f32(
    uint32_t M, uint32_t N, uint32_t stride, float value, float *__restrict__ pDst);

void plp_mat_fill_stride_f32s_xpulpv2(
    uint32_t M, uint32_t N, uint32_t stride, float value, float *__restrict__ pDst);

void plp_mat_fill_stride_f32_parallel(
    uint32_t M, uint32_t N, uint32_t stride, float value, uint32_t nPE, float *__restrict__ pDst);

void plp_mat_fill_stride_f32p_xpulpv2(void *args);

void plp_mat_copy_stride_i32(const int32_t *__restrict__ pSrc,
                             uint32_t M,
                             uint32_t N,
                             uint32_t strideSrc,
                             uint32_t strideDst,
                             int32_t *__restrict__ pDst);

void plp_mat_copy_stride_i32s_rv32im(const int32_t *__restrict__ pSrc,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideSrc,
                                     uint32_t strideDst,
                                     int32_t *__restrict__ pDst);

void plp_mat_copy_stride_i32s_xpulpv2(const int32_t *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      int32_t *__restrict__ pDst);

void plp_mat_copy_stride_i32_parallel(const int32_t *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      uint32_t nPE,
                                      int32_t *__restrict__ pDst);

void plp_mat_copy_stride_i32p_xpulpv2(void *args);

void plp_mat_copy_stride_i16(const int16_t *__restrict__ pSrc,
                             uint32_t M,
                             uint32_t N,
                             uint32_t strideSrc,
                             uint32_t strideDst,
                             int16_t *__restrict__ pDst);

void plp_mat_copy_stride_i16s_rv32im(const int16_t *__restrict__ pSrc,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideSrc,
                                     uint32_t strideDst,
                                     int16_t *__restrict__ pDst);

void plp_mat_copy_stride_i16s_xpulpv2(const int16_t *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      int16_t *__restrict__ pDst);

void plp_mat_copy_stride_i16_parallel(const int16_t *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      uint32_t nPE,
                                      int16_t *__restrict__ pDst);

void plp_mat_copy_stride_i16p_xpulpv2(void *args);

void plp_mat_copy_stride_i8(const int8_t *__restrict__ pSrc,
                            uint32_t M,
                            uint32_t N,
                            uint32_t strideSrc,
                            uint32_t strideDst,
                            int8_t *__restrict__ pDst);

void plp_mat_copy_stride_i8s_rv32im(const int8_t *__restrict__ pSrc,
                                    uint32_t M,
                                    uint32_t N,
                                    uint32_t strideSrc,
                                    uint32_t strideDst,
                                    int8_t *__restrict__ pDst);

void plp_mat_copy_stride_i8s_xpulpv2(const int8_t *__restrict__ pSrc,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideSrc,
                                     uint32_t strideDst,
                                     int8_t *__restrict__ pDst);

void plp_mat_copy_stride_i8_parallel(const int8_t *__restrict__ pSrc,
                                     uint32_t M,
                                     uint32_t N,
                                     uint32_t strideSrc,
                                     uint32_t strideDst,
                                     uint32_t nPE,
                                     int8_t *__restrict__ pDst);

void plp_mat_copy_stride_i8p_xpulpv2(void *args);

void plp_mat_copy_stride_f32(const float *__restrict__ pSrc,
                             uint32_t M,
                             uint32_t N,
                             uint32_t strideSrc,
                             uint32_t strideDst,
                             float *__restrict__ pDst);

void plp_mat_copy_stride_f32s_xpulpv2(const float *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      float *__restrict__ pDst);

void plp_mat_copy_stride_f32_parallel(const float *__restrict__ pSrc,
                                      uint32_t M,
                                      uint32_t N,
                                      uint32_t strideSrc,
                                      uint32_t strideDst,
                                      uint32_t nPE,
                                      float *__restrict__ pDst);

void plp_mat_copy_stride_f32p_xpulpv2(void *args);

void plp_cmplx_conj_f32(const float32_t *__restrict__ pSrc,
                        float32_t *__restrict__ pDst,
                        uint32_t numSamples);

void plp_cmplx_conj_f32_xpulpv2(const float32_t *__restrict__ pSrc,
                                float32_t *__restrict__ pDst,
                                uint32_t numSamples);

void plp_cmplx_conj_i32(const int32_t *__restrict__ pSrc,
                        int32_t *__restrict__ pDst,
                        uint32_t numSamples);

void plp_cmplx_conj_i32_xpulpv2(const int32_t *__restrict__ pSrc,
                                int32_t *__restrict__ pDst,
                                uint32_t numSamples);

void plp_cmplx_conj_i32_rv32im(const int32_t *__restrict__ pSrc,
                               int32_t *__restrict__ pDst,
                               uint32_t numSamples);

void plp_cmplx_conj_i16(const int16_t *__restrict__ pSrc,
                        int16_t *__restrict__ pDst,
                        uint32_t numSamples);

void plp_cmplx_conj_i16_xpulpv2(const int16_t *__restrict__ pSrc,
                                int16_t *__restrict__ pDst,
                                uint32_t numSamples);

void plp_cmplx_conj_i16_rv32im(const int16_t *__restrict__ pSrc,
                               int16_t *__restrict__ pDst,
                               uint32_t numSamples);

void plp_cmplx_conj_i8(const int8_t *__restrict__ pSrc,
                       int8_t *__restrict__ pDst,
                       uint32_t numSamples);

void plp_cmplx_conj_i8_xpulpv2(const int8_t *__restrict__ pSrc,
                               int8_t *__restrict__ pDst,
                               uint32_t numSamples);

void plp_cmplx_conj_i8_rv32im(const int8_t *__restrict__ pSrc,
                              int8_t *__restrict__ pDst,
                              uint32_t numSamples);

void plp_cmplx_dot_prod_f32(const float32_t *pSrcA,
                            const float32_t *pSrcB,
                            uint32_t numSamples,
                            float32_t *realResult,
                            float32_t *imagResult);

void plp_cmplx_dot_prod_f32_xpulpv2(const float32_t *pSrcA,
                                    const float32_t *pSrcB,
                                    uint32_t numSamples,
                                    float32_t *realResult,
                                    float32_t *imagResult);

void plp_cmplx_dot_prod_i32(const int32_t *pSrcA,
                            const int32_t *pSrcB,
                            uint32_t numSamples,
                            int32_t *realResult,
                            int32_t *imagResult);

void plp_cmplx_dot_prod_i32_xpulpv2(const int32_t *pSrcA,
                                    const int32_t *pSrcB,
                                    uint32_t numSamples,
                                    int32_t *realResult,
                                    int32_t *imagResult);

void plp_cmplx_dot_prod_i32_rv32im(const int32_t *pSrcA,
                                   const int32_t *pSrcB,
                                   uint32_t numSamples,
                                   int32_t *realResult,
                                   int32_t *imagResult);

void plp_cmplx_dot_prod_i16(const int16_t *pSrcA,
                            const int16_t *pSrcB,
                            uint32_t numSamples,
                            int16_t *realResult,
                            int16_t *imagResult);

void plp_cmplx_dot_prod_i16_xpulpv2(const int16_t *pSrcA,
                                    const int16_t *pSrcB,
                                    uint32_t numSamples,
                                    int16_t *realResult,
                                    int16_t *imagResult);

void plp_cmplx_dot_prod_i16_rv32im(const int16_t *pSrcA,
                                   const int16_t *pSrcB,
                                   uint32_t numSamples,
                                   int16_t *realResult,
                                   int16_t *imagResult);

void plp_cmplx_dot_prod_i8(const int8_t *pSrcA,
                           const int8_t *pSrcB,
                           uint32_t numSamples,
                           int8_t *realResult,
                           int8_t *imagResult);

void plp_cmplx_dot_prod_i8_xpulpv2(const int8_t *pSrcA,
                                   const int8_t *pSrcB,
                                   uint32_t numSamples,
                                   int8_t *realResult,
                                   int8_t *imagResult);

void plp_cmplx_dot_prod_i8_rv32im(const int8_t *pSrcA,
                                  const int8_t *pSrcB,
                                  uint32_t numSamples,
                                  int8_t *realResult,
                                  int8_t *imagResult);

void plp_cmplx_dot_prod_q32(const int32_t *pSrcA,
                            const int32_t *pSrcB,
                            uint32_t numSamples,
                            uint32_t deciPoint,
                            int32_t *realResult,
                            int32_t *imagResult);

void plp_cmplx_dot_prod_q32_xpulpv2(const int32_t *pSrcA,
                                    const int32_t *pSrcB,
                                    uint32_t numSamples,
                                    uint32_t deciPoint,
                                    int32_t *realResult,
                                    int32_t *imagResult);

void plp_cmplx_dot_prod_q32_rv32im(const int32_t *pSrcA,
                                   const int32_t *pSrcB,
                                   uint32_t numSamples,
                                   uint32_t deciPoint,
                                   int32_t *realResult,
                                   int32_t *imagResult);

void plp_cmplx_dot_prod_q16(const int16_t *pSrcA,
                            const int16_t *pSrcB,
                            uint32_t numSamples,
                            uint32_t deciPoint,
                            int16_t *realResult,
                            int16_t *imagResult);

void plp_cmplx_dot_prod_q16_xpulpv2(const int16_t *pSrcA,
                                    const int16_t *pSrcB,
                                    uint32_t numSamples,
                                    uint32_t deciPoint,
                                    int16_t *realResult,
                                    int16_t *imagResult);

void plp_cmplx_dot_prod_q16_rv32im(const int16_t *pSrcA,
                                   const int16_t *pSrcB,
                                   uint32_t numSamples,
                                   uint32_t deciPoint,
                                   int16_t *realResult,
                                   int16_t *imagResult);

void plp_cmplx_mult_real_f32(const float32_t *__restrict__ pSrcCmplx,
                             const float32_t *__restrict__ pSrcReal,
                             float32_t *__restrict__ pDst,
                             uint32_t numSamples);

void plp_cmplx_mult_real_f32_xpulpv2(const float32_t *__restrict__ pSrcCmplx,
                                     const float32_t *__restrict__ pSrcReal,
                                     float32_t *__restrict__ pDst,
                                     uint32_t numSamples);

void plp_cmplx_mult_real_i32(const int32_t *__restrict__ pSrcCmplx,
                             const int32_t *__restrict__ pSrcReal,
                             int32_t *__restrict__ pDst,
                             uint32_t numSamples);

void plp_cmplx_mult_real_i32_xpulpv2(const int32_t *__restrict__ pSrcCmplx,
                                     const int32_t *__restrict__ pSrcReal,
                                     int32_t *__restrict__ pDst,
                                     uint32_t numSamples);

void plp_cmplx_mult_real_i32_rv32im(const int32_t *__restrict__ pSrcCmplx,
                                    const int32_t *__restrict__ pSrcReal,
                                    int32_t *__restrict__ pDst,
                                    uint32_t numSamples);

void plp_cmplx_mult_real_i16(const int16_t *__restrict__ pSrcCmplx,
                             const int16_t *__restrict__ pSrcReal,
                             int16_t *__restrict__ pDst,
                             uint32_t numSamples);

void plp_cmplx_mult_real_i16_xpulpv2(const int16_t *__restrict__ pSrcCmplx,
                                     const int16_t *__restrict__ pSrcReal,
                                     int16_t *__restrict__ pDst,
                                     uint32_t numSamples);

void plp_cmplx_mult_real_i16_rv32im(const int16_t *__restrict__ pSrcCmplx,
                                    const int16_t *__restrict__ pSrcReal,
                                    int16_t *__restrict__ pDst,
                                    uint32_t numSamples);

void plp_cmplx_mult_real_i8(const int8_t *__restrict__ pSrcCmplx,
                            const int8_t *__restrict__ pSrcReal,
                            int8_t *__restrict__ pDst,
                            uint32_t numSamples);

void plp_cmplx_mult_real_i8_xpulpv2(const int8_t *__restrict__ pSrcCmplx,
                                    const int8_t *__restrict__ pSrcReal,
                                    int8_t *__restrict__ pDst,
                                    uint32_t numSamples);

void plp_cmplx_mult_real_i8_rv32im(const int8_t *__restrict__ pSrcCmplx,
                                   const int8_t *__restrict__ pSrcReal,
                                   int8_t *__restrict__ pDst,
                                   uint32_t numSamples);

void plp_cmplx_mult_real_q32(const int32_t *__restrict__ pSrcCmplx,
                             const int32_t *__restrict__ pSrcReal,
                             int32_t *__restrict__ pDst,
                             uint32_t deciPoint,
                             uint32_t numSamples);

void plp_cmplx_mult_real_q32_xpulpv2(const int32_t *__restrict__ pSrcCmplx,
                                     const int32_t *__restrict__ pSrcReal,
                                     int32_t *__restrict__ pDst,
                                     uint32_t deciPoint,
                                     uint32_t numSamples);

void plp_cmplx_mult_real_q32_rv32im(const int32_t *__restrict__ pSrcCmplx,
                                    const int32_t *__restrict__ pSrcReal,
                                    int32_t *__restrict__ pDst,
                                    uint32_t deciPoint,
                                    uint32_t numSamples);

void plp_cmplx_mult_real_q16(const int16_t *__restrict__ pSrcCmplx,
                             const int16_t *__restrict__ pSrcReal,
                             int16_t *__restrict__ pDst,
                             uint32_t deciPoint,
                             uint32_t numSamples);

void plp_cmplx_mult_real_q16_xpulpv2(const int16_t *__restrict__ pSrcCmplx,
                                     const int16_t *__restrict__ pSrcReal,
                                     int16_t *__restrict__ pDst,
                                     uint32_t deciPoint,
                                     uint32_t numSamples);

void plp_cmplx_mult_real_q16_rv32im(const int16_t *__restrict__ pSrcCmplx,
                                    const int16_t *__restrict__ pSrcReal,
                                    int16_t *__restrict__ pDst,
                                    uint32_t deciPoint,
                                    uint32_t numSamples);

void plp_cmplx_mult_real_q8(const int8_t *__restrict__ pSrcCmplx,
                            const int8_t *__restrict__ pSrcReal,
                            int8_t *__restrict__ pDst,
                            uint32_t deciPoint,
                            uint32_t numSamples);

void plp_cmplx_mult_real_q8_xpulpv2(const int8_t *__restrict__ pSrcCmplx,
                                    const int8_t *__restrict__ pSrcReal,
                                    int8_t *__restrict__ pDst,
                                    uint32_t deciPoint,
                                    uint32_t numSamples);

void plp_cmplx_mult_real_q8_rv32im(const int8_t *__restrict__ pSrcCmplx,
                                   const int8_t *__restrict__ pSrcReal,
                                   int8_t *__restrict__ pDst,
                                   uint32_t deciPoint,
                                   uint32_t numSamples);

void plp_cmplx_mag_squared_f32(const float32_t *__restrict__ pSrc,
                               float32_t *__restrict__ pDst,
                               uint32_t numSamples);

void plp_cmplx_mag_squared_f32_xpulpv2(const float32_t *__restrict__ pSrc,
                                       float32_t *__restrict__ pDst,
                                       uint32_t numSamples);

void plp_cmplx_mag_squared_i16(const int16_t *__restrict__ pSrc,
                               int16_t *__restrict__ pDst,
                               uint32_t numSamples);

void plp_cmplx_mag_squared_i16_rv32im(const int16_t *__restrict__ pSrc,
                                      int16_t *__restrict__ pDst,
                                      uint32_t numSamples);

void plp_cmplx_mag_squared_i16_xpulpv2(const int16_t *__restrict__ pSrc,
                                       int16_t *__restrict__ pDst,
                                       uint32_t numSamples);

void plp_cmplx_mag_squared_i32(const int32_t *__restrict__ pSrc,
                               int32_t *__restrict__ pDst,
                               uint32_t numSamples);

void plp_cmplx_mag_squared_i32_rv32im(const int32_t *__restrict__ pSrc,
                                      int32_t *__restrict__ pDst,
                                      uint32_t numSamples);

void plp_cmplx_mag_squared_i32_xpulpv2(const int32_t *__restrict__ pSrc,
                                      int32_t *__restrict__ pDst,
                                      uint32_t numSamples);

void plp_cmplx_mag_squared_i8_xpulpv2(const int8_t *__restrict__ pSrc,
                                      int8_t *__restrict__ pDst,
                                      uint32_t numSamples);

void plp_cmplx_mag_squared_i8(const int8_t *__restrict__ pSrc,
                              int8_t *__restrict__ pDst,
                              uint32_t numSamples);

void plp_cmplx_mag_squared_i8_rv32im(const int8_t *__restrict__ pSrc,
                                     int8_t *__restrict__ pDst,
                                     uint32_t numSamples);

void plp_cmplx_mag_squared_i8_xpulpv2(const int8_t *__restrict__ pSrc,
                                      int8_t *__restrict__ pDst,
                                      uint32_t numSamples);

void plp_cmplx_mag_squared_q32(const int32_t *__restrict__ pSrc,
                               int32_t *__restrict__ pDst,
                               uint32_t deciPoint,
                               uint32_t numSamples);

void plp_cmplx_mag_squared_q32_rv32im(const int32_t *__restrict__ pSrc,
                                      int32_t *__restrict__ pDst,
                                      uint32_t deciPoint,
                                      uint32_t numSamples);

void plp_cmplx_mag_squared_q32_xpulpv2(const int32_t *__restrict__ pSrc,
                                       int32_t *__restrict__ pDst,
                                       uint32_t deciPoint,
                                       uint32_t numSamples);

void plp_cmplx_mag_squared_q16(const int16_t *__restrict__ pSrc,
                               int16_t *__restrict__ pDst,
                               uint32_t deciPoint,
                               uint32_t numSamples);

void plp_cmplx_mag_squared_q16_rv32im(const int16_t *__restrict__ pSrc,
                                      int16_t *__restrict__ pDst,
                                      uint32_t deciPoint,
                                      uint32_t numSamples);

void plp_cmplx_mag_squared_q16_xpulpv2(const int16_t *__restrict__ pSrc,
                                       int16_t *__restrict__ pDst,
                                       uint32_t deciPoint,
                                       uint32_t numSamples);

void plp_cmplx_mag_squared_q8(const int8_t *__restrict__ pSrc,
                              int8_t *__restrict__ pDst,
                              uint32_t deciPoint,
                              uint32_t numSamples);

void plp_cmplx_mag_squared_q8_rv32im(const int8_t *__restrict__ pSrc,
                                     int8_t *__restrict__ pDst,
                                     uint32_t deciPoint,
                                     uint32_t numSamples);

void plp_cmplx_mag_squared_q8_xpulpv2(const int8_t *__restrict__ pSrc,
                                      int8_t *__restrict__ pDst,
                                      uint32_t deciPoint,
                                      uint32_t numSamples);

void plp_cmplx_mult_cmplx_f32(const float32_t *__restrict__ pSrcA,
                              const float32_t *__restrict__ pSrcB,
                              float32_t *__restrict__ pDst,
                              uint32_t numSamples);

void plp_cmplx_mult_cmplx_f32_xpulpv2(const float32_t *__restrict__ pSrcA,
                                      const float32_t *__restrict__ pSrcB,
                                      float32_t *__restrict__ pDst,
                                      uint32_t numSamples);

void plp_cmplx_mult_cmplx_i32(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              int32_t *__restrict__ pDst,
                              uint32_t numSamples);

void plp_cmplx_mult_cmplx_i32_xpulpv2(const int32_t *__restrict__ pSrcA,
                                      const int32_t *__restrict__ pSrcB,
                                      int32_t *__restrict__ pDst,
                                      uint32_t numSamples);

void plp_cmplx_mult_cmplx_i32_rv32im(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     int32_t *__restrict__ pDst,
                                     uint32_t numSamples);

void plp_cmplx_mult_cmplx_i16(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              int16_t *__restrict__ pDst,
                              uint32_t numSamples);

void plp_cmplx_mult_cmplx_i16_xpulpv2(const int16_t *__restrict__ pSrcA,
                                      const int16_t *__restrict__ pSrcB,
                                      int16_t *__restrict__ pDst,
                                      uint32_t numSamples);

void plp_cmplx_mult_cmplx_i16_rv32im(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     int16_t *__restrict__ pDst,
                                     uint32_t numSamples);

void plp_cmplx_mult_cmplx_i8(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             int8_t *__restrict__ pDst,
                             uint32_t numSamples);

void plp_cmplx_mult_cmplx_i8_xpulpv2(const int8_t *__restrict__ pSrcA,
                                     const int8_t *__restrict__ pSrcB,
                                     int8_t *__restrict__ pDst,
                                     uint32_t numSamples);

void plp_cmplx_mult_cmplx_i8_rv32im(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    int8_t *__restrict__ pDst,
                                    uint32_t numSamples);

void plp_cmplx_mult_cmplx_q32(const int32_t *__restrict__ pSrcA,
                              const int32_t *__restrict__ pSrcB,
                              int32_t *__restrict__ pDst,
                              uint32_t deciPoint,
                              uint32_t numSamples);

void plp_cmplx_mult_cmplx_q32_xpulpv2(const int32_t *__restrict__ pSrcA,
                                      const int32_t *__restrict__ pSrcB,
                                      int32_t *__restrict__ pDst,
                                      uint32_t deciPoint,
                                      uint32_t numSamples);

void plp_cmplx_mult_cmplx_q32_rv32im(const int32_t *__restrict__ pSrcA,
                                     const int32_t *__restrict__ pSrcB,
                                     int32_t *__restrict__ pDst,
                                     uint32_t deciPoint,
                                     uint32_t numSamples);

void plp_cmplx_mult_cmplx_q16(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              int16_t *__restrict__ pDst,
                              uint32_t deciPoint,
                              uint32_t numSamples);

void plp_cmplx_mult_cmplx_q16_xpulpv2(const int16_t *__restrict__ pSrcA,
                                      const int16_t *__restrict__ pSrcB,
                                      int16_t *__restrict__ pDst,
                                      uint32_t deciPoint,
                                      uint32_t numSamples);

void plp_cmplx_mult_cmplx_q16_rv32im(const int16_t *__restrict__ pSrcA,
                                     const int16_t *__restrict__ pSrcB,
                                     int16_t *__restrict__ pDst,
                                     uint32_t deciPoint,
                                     uint32_t numSamples);

void plp_cmplx_mult_cmplx_q8(const int8_t *__restrict__ pSrcA,
                             const int8_t *__restrict__ pSrcB,
                             int8_t *__restrict__ pDst,
                             uint32_t deciPoint,
                             uint32_t numSamples);

void plp_cmplx_mult_cmplx_q8_xpulpv2(const int8_t *__restrict__ pSrcA,
                                     const int8_t *__restrict__ pSrcB,
                                     int8_t *__restrict__ pDst,
                                     uint32_t deciPoint,
                                     uint32_t numSamples);

void plp_cmplx_mult_cmplx_q8_rv32im(const int8_t *__restrict__ pSrcA,
                                    const int8_t *__restrict__ pSrcB,
                                    int8_t *__restrict__ pDst,
                                    uint32_t deciPoint,
                                    uint32_t numSamples);


void plp_euclidean_distance_q32_parallel(   const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t blockSize,
                                            uint32_t fracBits,
                                            uint32_t nPE,
                                            uint32_t *__restrict__ pRes);

void plp_euclidean_distance_f32_parallel( const float32_t *__restrict__ pSrcA,
                                          const float32_t *__restrict__ pSrcB,
                                          uint32_t blockSize,
                                          uint32_t nPE,
                                          float32_t *__restrict__ pRes);

void plp_euclidean_distance_q32p_xpulpv2(void *S);

void plp_euclidean_distance_f32p_xpulpv2(void *S);

void plp_euclidean_distance_q32(  const int32_t *__restrict__ pSrcA,
                                  const int32_t *__restrict__ pSrcB,
                                  uint32_t blockSize,
                                  uint32_t fracBits,
                                  int32_t *__restrict__ pRes);

void plp_euclidean_distance_q32s_xpulpv2(   const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t blockSize,
                                            uint32_t fracBits,
                                            int32_t *__restrict__ pRes);

void plp_euclidean_distance_q32s_rv32im(    const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t blockSize,
                                            uint32_t fracBits,
                                            int32_t *__restrict__ pRes);


void plp_euclidean_distance_q16(  const int16_t *__restrict__ pSrcA,
                                  const int16_t *__restrict__ pSrcB,
                                  uint16_t blockSize,
                                  uint16_t fracBits,
                                  int32_t *__restrict__ pRes);

void plp_euclidean_distance_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                               const int16_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               uint32_t deciPoint,
                               int32_t *__restrict__ pRes);

void plp_euclidean_distance_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t blockSize,
                              uint32_t fracBits,
                              int32_t *__restrict__ pRes);

void plp_euclidean_distance_f32(  const float32_t *__restrict__ pSrcA,
                                  const float32_t *__restrict__ pSrcB,
                                  uint32_t blockSize,
                                  float32_t *__restrict__ pRes);

void plp_euclidean_distance_f32s_xpulpv2( const float32_t *__restrict__ pSrcA,
                                          const float32_t *__restrict__ pSrcB,
                                          uint32_t blockSize,
                                          float32_t *__restrict__ pRes);

void plp_euclidean_distance_f32s_rv32im(  const float32_t *__restrict__ pSrcA,
                                          const float32_t *__restrict__ pSrcB,
                                          uint32_t blockSize,
                                          float32_t *__restrict__ pRes);

void plp_cosine_distance_q32_parallel(   const int32_t *__restrict__ pSrcA,
                                         const int32_t *__restrict__ pSrcB,
                                         uint32_t blockSize,
                                         uint32_t fracBits,
                                         uint32_t nPE,
                                         int32_t *__restrict__ pRes);

void plp_cosine_distance_f32_parallel(  const float32_t *__restrict__ pSrcA,
                                        const float32_t *__restrict__ pSrcB,
                                        uint32_t blockSize,
                                        uint32_t nPE,
                                        float32_t *__restrict__ pRes);

void plp_cosine_distance_f32p_xpulpv2(void *S);


void plp_cosine_distance_f32(  const float32_t *__restrict__ pSrcA,
                                  const float32_t *__restrict__ pSrcB,
                                  uint32_t blockSize,
                                  float32_t *__restrict__ pRes);

void plp_cosine_distance_f32s_rv32im(  const float32_t *__restrict__ pSrcA,
                                          const float32_t *__restrict__ pSrcB,
                                          uint32_t blockSize,
                                          float32_t *__restrict__ pRes);

void plp_cosine_distance_f32s_xpulpv2(  const float32_t *__restrict__ pSrcA,
                                        const float32_t *__restrict__ pSrcB,
                                        uint32_t blockSize,
                                        float32_t *__restrict__ pRes);

void plp_cosine_distance_q32(   const int32_t *__restrict__ pSrcA,
                                const int32_t *__restrict__ pSrcB,
                                uint32_t blockSize,
                                uint32_t fracBits,
                                int32_t *__restrict__ pRes);

void plp_cosine_distance_q32s_rv32im(   const int32_t *__restrict__ pSrcA,
                                        const int32_t *__restrict__ pSrcB,
                                        uint32_t blockSize,
                                        uint32_t fracBits,
                                        int32_t *__restrict__ pRes);

void plp_cosine_distance_q32s_xpulpv2(   const int32_t *__restrict__ pSrcA,
                                            const int32_t *__restrict__ pSrcB,
                                            uint32_t blockSize,
                                            uint32_t fracBits,
                                            int32_t *__restrict__ pRes);

void plp_cosine_distance_q16(   const int16_t *__restrict__ pSrcA,
                                const int16_t *__restrict__ pSrcB,
                                uint16_t blockSize,
                                uint16_t fracBits,
                                int32_t *__restrict__ pRes);

void plp_cosine_distance_q16s_rv32im(const int16_t *__restrict__ pSrcA,
                              const int16_t *__restrict__ pSrcB,
                              uint32_t blockSize,
                              uint32_t fracBits,
                              int32_t *__restrict__ pRes);

void plp_cosine_distance_q16s_xpulpv2(const int16_t *__restrict__ pSrcA,
                               const int16_t *__restrict__ pSrcB,
                               uint32_t blockSize,
                               uint32_t fracBits,
                               int32_t *__restrict__ pRes);



#endif // __PLP_MATH_H__
</code></pre>
<hr />
<p>Updated on 2023-03-01 at 16:16:34 +0000</p>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.2a6f1dda.min.js"></script>
      
    
  </body>
</html>